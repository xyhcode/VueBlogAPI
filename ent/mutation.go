// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/anzhiyu-c/anheyu-app/ent/album"
	"github.com/anzhiyu-c/anheyu-app/ent/albumcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/article"
	"github.com/anzhiyu-c/anheyu-app/ent/articlehistory"
	"github.com/anzhiyu-c/anheyu-app/ent/comment"
	"github.com/anzhiyu-c/anheyu-app/ent/directlink"
	"github.com/anzhiyu-c/anheyu-app/ent/docseries"
	"github.com/anzhiyu-c/anheyu-app/ent/entity"
	"github.com/anzhiyu-c/anheyu-app/ent/essay"
	"github.com/anzhiyu-c/anheyu-app/ent/fcirclepost"
	"github.com/anzhiyu-c/anheyu-app/ent/fcirclestatistic"
	"github.com/anzhiyu-c/anheyu-app/ent/file"
	"github.com/anzhiyu-c/anheyu-app/ent/fileentity"
	"github.com/anzhiyu-c/anheyu-app/ent/givemoney"
	"github.com/anzhiyu-c/anheyu-app/ent/link"
	"github.com/anzhiyu-c/anheyu-app/ent/linkcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/linktag"
	"github.com/anzhiyu-c/anheyu-app/ent/metadata"
	"github.com/anzhiyu-c/anheyu-app/ent/notificationtype"
	"github.com/anzhiyu-c/anheyu-app/ent/page"
	"github.com/anzhiyu-c/anheyu-app/ent/postcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/posttag"
	"github.com/anzhiyu-c/anheyu-app/ent/predicate"
	"github.com/anzhiyu-c/anheyu-app/ent/setting"
	"github.com/anzhiyu-c/anheyu-app/ent/storagepolicy"
	"github.com/anzhiyu-c/anheyu-app/ent/subscriber"
	"github.com/anzhiyu-c/anheyu-app/ent/tag"
	"github.com/anzhiyu-c/anheyu-app/ent/urlstat"
	"github.com/anzhiyu-c/anheyu-app/ent/user"
	"github.com/anzhiyu-c/anheyu-app/ent/usergroup"
	"github.com/anzhiyu-c/anheyu-app/ent/userinstalledtheme"
	"github.com/anzhiyu-c/anheyu-app/ent/usernotificationconfig"
	"github.com/anzhiyu-c/anheyu-app/ent/visitorlog"
	"github.com/anzhiyu-c/anheyu-app/ent/visitorstat"
	"github.com/anzhiyu-c/anheyu-app/pkg/domain/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum                  = "Album"
	TypeAlbumCategory          = "AlbumCategory"
	TypeArticle                = "Article"
	TypeArticleHistory         = "ArticleHistory"
	TypeComment                = "Comment"
	TypeDirectLink             = "DirectLink"
	TypeDocSeries              = "DocSeries"
	TypeEntity                 = "Entity"
	TypeEssay                  = "Essay"
	TypeFCirclePost            = "FCirclePost"
	TypeFCircleStatistic       = "FCircleStatistic"
	TypeFile                   = "File"
	TypeFileEntity             = "FileEntity"
	TypeGiveMoney              = "GiveMoney"
	TypeLink                   = "Link"
	TypeLinkCategory           = "LinkCategory"
	TypeLinkTag                = "LinkTag"
	TypeMetadata               = "Metadata"
	TypeNotificationType       = "NotificationType"
	TypePage                   = "Page"
	TypePostCategory           = "PostCategory"
	TypePostTag                = "PostTag"
	TypeSetting                = "Setting"
	TypeStoragePolicy          = "StoragePolicy"
	TypeSubscriber             = "Subscriber"
	TypeTag                    = "Tag"
	TypeURLStat                = "URLStat"
	TypeUser                   = "User"
	TypeUserGroup              = "UserGroup"
	TypeUserInstalledTheme     = "UserInstalledTheme"
	TypeUserNotificationConfig = "UserNotificationConfig"
	TypeVisitorLog             = "VisitorLog"
	TypeVisitorStat            = "VisitorStat"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	deleted_at        *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	image_url         *string
	big_image_url     *string
	download_url      *string
	thumb_param       *string
	big_param         *string
	tags              *string
	view_count        *int
	addview_count     *int
	download_count    *int
	adddownload_count *int
	width             *int
	addwidth          *int
	height            *int
	addheight         *int
	file_size         *int64
	addfile_size      *int64
	format            *string
	aspect_ratio      *string
	file_hash         *string
	display_order     *int
	adddisplay_order  *int
	title             *string
	description       *string
	location          *string
	clearedFields     map[string]struct{}
	category          *uint
	clearedcategory   bool
	done              bool
	oldValue          func(context.Context) (*Album, error)
	predicates        []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id uint) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Album entities.
func (m *AlbumMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlbumMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlbumMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlbumMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[album.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlbumMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[album.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlbumMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, album.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImageURL sets the "image_url" field.
func (m *AlbumMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *AlbumMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *AlbumMutation) ResetImageURL() {
	m.image_url = nil
}

// SetBigImageURL sets the "big_image_url" field.
func (m *AlbumMutation) SetBigImageURL(s string) {
	m.big_image_url = &s
}

// BigImageURL returns the value of the "big_image_url" field in the mutation.
func (m *AlbumMutation) BigImageURL() (r string, exists bool) {
	v := m.big_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBigImageURL returns the old "big_image_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldBigImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigImageURL: %w", err)
	}
	return oldValue.BigImageURL, nil
}

// ClearBigImageURL clears the value of the "big_image_url" field.
func (m *AlbumMutation) ClearBigImageURL() {
	m.big_image_url = nil
	m.clearedFields[album.FieldBigImageURL] = struct{}{}
}

// BigImageURLCleared returns if the "big_image_url" field was cleared in this mutation.
func (m *AlbumMutation) BigImageURLCleared() bool {
	_, ok := m.clearedFields[album.FieldBigImageURL]
	return ok
}

// ResetBigImageURL resets all changes to the "big_image_url" field.
func (m *AlbumMutation) ResetBigImageURL() {
	m.big_image_url = nil
	delete(m.clearedFields, album.FieldBigImageURL)
}

// SetDownloadURL sets the "download_url" field.
func (m *AlbumMutation) SetDownloadURL(s string) {
	m.download_url = &s
}

// DownloadURL returns the value of the "download_url" field in the mutation.
func (m *AlbumMutation) DownloadURL() (r string, exists bool) {
	v := m.download_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadURL returns the old "download_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDownloadURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadURL: %w", err)
	}
	return oldValue.DownloadURL, nil
}

// ClearDownloadURL clears the value of the "download_url" field.
func (m *AlbumMutation) ClearDownloadURL() {
	m.download_url = nil
	m.clearedFields[album.FieldDownloadURL] = struct{}{}
}

// DownloadURLCleared returns if the "download_url" field was cleared in this mutation.
func (m *AlbumMutation) DownloadURLCleared() bool {
	_, ok := m.clearedFields[album.FieldDownloadURL]
	return ok
}

// ResetDownloadURL resets all changes to the "download_url" field.
func (m *AlbumMutation) ResetDownloadURL() {
	m.download_url = nil
	delete(m.clearedFields, album.FieldDownloadURL)
}

// SetThumbParam sets the "thumb_param" field.
func (m *AlbumMutation) SetThumbParam(s string) {
	m.thumb_param = &s
}

// ThumbParam returns the value of the "thumb_param" field in the mutation.
func (m *AlbumMutation) ThumbParam() (r string, exists bool) {
	v := m.thumb_param
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbParam returns the old "thumb_param" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldThumbParam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbParam: %w", err)
	}
	return oldValue.ThumbParam, nil
}

// ClearThumbParam clears the value of the "thumb_param" field.
func (m *AlbumMutation) ClearThumbParam() {
	m.thumb_param = nil
	m.clearedFields[album.FieldThumbParam] = struct{}{}
}

// ThumbParamCleared returns if the "thumb_param" field was cleared in this mutation.
func (m *AlbumMutation) ThumbParamCleared() bool {
	_, ok := m.clearedFields[album.FieldThumbParam]
	return ok
}

// ResetThumbParam resets all changes to the "thumb_param" field.
func (m *AlbumMutation) ResetThumbParam() {
	m.thumb_param = nil
	delete(m.clearedFields, album.FieldThumbParam)
}

// SetBigParam sets the "big_param" field.
func (m *AlbumMutation) SetBigParam(s string) {
	m.big_param = &s
}

// BigParam returns the value of the "big_param" field in the mutation.
func (m *AlbumMutation) BigParam() (r string, exists bool) {
	v := m.big_param
	if v == nil {
		return
	}
	return *v, true
}

// OldBigParam returns the old "big_param" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldBigParam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigParam: %w", err)
	}
	return oldValue.BigParam, nil
}

// ClearBigParam clears the value of the "big_param" field.
func (m *AlbumMutation) ClearBigParam() {
	m.big_param = nil
	m.clearedFields[album.FieldBigParam] = struct{}{}
}

// BigParamCleared returns if the "big_param" field was cleared in this mutation.
func (m *AlbumMutation) BigParamCleared() bool {
	_, ok := m.clearedFields[album.FieldBigParam]
	return ok
}

// ResetBigParam resets all changes to the "big_param" field.
func (m *AlbumMutation) ResetBigParam() {
	m.big_param = nil
	delete(m.clearedFields, album.FieldBigParam)
}

// SetTags sets the "tags" field.
func (m *AlbumMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AlbumMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *AlbumMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[album.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AlbumMutation) TagsCleared() bool {
	_, ok := m.clearedFields[album.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AlbumMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, album.FieldTags)
}

// SetViewCount sets the "view_count" field.
func (m *AlbumMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *AlbumMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *AlbumMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *AlbumMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *AlbumMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetDownloadCount sets the "download_count" field.
func (m *AlbumMutation) SetDownloadCount(i int) {
	m.download_count = &i
	m.adddownload_count = nil
}

// DownloadCount returns the value of the "download_count" field in the mutation.
func (m *AlbumMutation) DownloadCount() (r int, exists bool) {
	v := m.download_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadCount returns the old "download_count" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDownloadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadCount: %w", err)
	}
	return oldValue.DownloadCount, nil
}

// AddDownloadCount adds i to the "download_count" field.
func (m *AlbumMutation) AddDownloadCount(i int) {
	if m.adddownload_count != nil {
		*m.adddownload_count += i
	} else {
		m.adddownload_count = &i
	}
}

// AddedDownloadCount returns the value that was added to the "download_count" field in this mutation.
func (m *AlbumMutation) AddedDownloadCount() (r int, exists bool) {
	v := m.adddownload_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadCount resets all changes to the "download_count" field.
func (m *AlbumMutation) ResetDownloadCount() {
	m.download_count = nil
	m.adddownload_count = nil
}

// SetWidth sets the "width" field.
func (m *AlbumMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *AlbumMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *AlbumMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *AlbumMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *AlbumMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[album.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *AlbumMutation) WidthCleared() bool {
	_, ok := m.clearedFields[album.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *AlbumMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, album.FieldWidth)
}

// SetHeight sets the "height" field.
func (m *AlbumMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *AlbumMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *AlbumMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *AlbumMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *AlbumMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[album.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *AlbumMutation) HeightCleared() bool {
	_, ok := m.clearedFields[album.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *AlbumMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, album.FieldHeight)
}

// SetFileSize sets the "file_size" field.
func (m *AlbumMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *AlbumMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *AlbumMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *AlbumMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *AlbumMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[album.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *AlbumMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[album.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *AlbumMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, album.FieldFileSize)
}

// SetFormat sets the "format" field.
func (m *AlbumMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *AlbumMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ClearFormat clears the value of the "format" field.
func (m *AlbumMutation) ClearFormat() {
	m.format = nil
	m.clearedFields[album.FieldFormat] = struct{}{}
}

// FormatCleared returns if the "format" field was cleared in this mutation.
func (m *AlbumMutation) FormatCleared() bool {
	_, ok := m.clearedFields[album.FieldFormat]
	return ok
}

// ResetFormat resets all changes to the "format" field.
func (m *AlbumMutation) ResetFormat() {
	m.format = nil
	delete(m.clearedFields, album.FieldFormat)
}

// SetAspectRatio sets the "aspect_ratio" field.
func (m *AlbumMutation) SetAspectRatio(s string) {
	m.aspect_ratio = &s
}

// AspectRatio returns the value of the "aspect_ratio" field in the mutation.
func (m *AlbumMutation) AspectRatio() (r string, exists bool) {
	v := m.aspect_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldAspectRatio returns the old "aspect_ratio" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldAspectRatio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAspectRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAspectRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAspectRatio: %w", err)
	}
	return oldValue.AspectRatio, nil
}

// ClearAspectRatio clears the value of the "aspect_ratio" field.
func (m *AlbumMutation) ClearAspectRatio() {
	m.aspect_ratio = nil
	m.clearedFields[album.FieldAspectRatio] = struct{}{}
}

// AspectRatioCleared returns if the "aspect_ratio" field was cleared in this mutation.
func (m *AlbumMutation) AspectRatioCleared() bool {
	_, ok := m.clearedFields[album.FieldAspectRatio]
	return ok
}

// ResetAspectRatio resets all changes to the "aspect_ratio" field.
func (m *AlbumMutation) ResetAspectRatio() {
	m.aspect_ratio = nil
	delete(m.clearedFields, album.FieldAspectRatio)
}

// SetFileHash sets the "file_hash" field.
func (m *AlbumMutation) SetFileHash(s string) {
	m.file_hash = &s
}

// FileHash returns the value of the "file_hash" field in the mutation.
func (m *AlbumMutation) FileHash() (r string, exists bool) {
	v := m.file_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFileHash returns the old "file_hash" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldFileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileHash: %w", err)
	}
	return oldValue.FileHash, nil
}

// ResetFileHash resets all changes to the "file_hash" field.
func (m *AlbumMutation) ResetFileHash() {
	m.file_hash = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *AlbumMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *AlbumMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *AlbumMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *AlbumMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *AlbumMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetCategoryID sets the "category_id" field.
func (m *AlbumMutation) SetCategoryID(u uint) {
	m.category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *AlbumMutation) CategoryID() (r uint, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCategoryID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *AlbumMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[album.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *AlbumMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[album.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *AlbumMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, album.FieldCategoryID)
}

// SetTitle sets the "title" field.
func (m *AlbumMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlbumMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *AlbumMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[album.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *AlbumMutation) TitleCleared() bool {
	_, ok := m.clearedFields[album.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *AlbumMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, album.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *AlbumMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlbumMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlbumMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[album.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlbumMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[album.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlbumMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, album.FieldDescription)
}

// SetLocation sets the "location" field.
func (m *AlbumMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *AlbumMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *AlbumMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[album.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *AlbumMutation) LocationCleared() bool {
	_, ok := m.clearedFields[album.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *AlbumMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, album.FieldLocation)
}

// ClearCategory clears the "category" edge to the AlbumCategory entity.
func (m *AlbumMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[album.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the AlbumCategory entity was cleared.
func (m *AlbumMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *AlbumMutation) CategoryIDs() (ids []uint) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *AlbumMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Album, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.deleted_at != nil {
		fields = append(fields, album.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, album.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, album.FieldUpdatedAt)
	}
	if m.image_url != nil {
		fields = append(fields, album.FieldImageURL)
	}
	if m.big_image_url != nil {
		fields = append(fields, album.FieldBigImageURL)
	}
	if m.download_url != nil {
		fields = append(fields, album.FieldDownloadURL)
	}
	if m.thumb_param != nil {
		fields = append(fields, album.FieldThumbParam)
	}
	if m.big_param != nil {
		fields = append(fields, album.FieldBigParam)
	}
	if m.tags != nil {
		fields = append(fields, album.FieldTags)
	}
	if m.view_count != nil {
		fields = append(fields, album.FieldViewCount)
	}
	if m.download_count != nil {
		fields = append(fields, album.FieldDownloadCount)
	}
	if m.width != nil {
		fields = append(fields, album.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, album.FieldHeight)
	}
	if m.file_size != nil {
		fields = append(fields, album.FieldFileSize)
	}
	if m.format != nil {
		fields = append(fields, album.FieldFormat)
	}
	if m.aspect_ratio != nil {
		fields = append(fields, album.FieldAspectRatio)
	}
	if m.file_hash != nil {
		fields = append(fields, album.FieldFileHash)
	}
	if m.display_order != nil {
		fields = append(fields, album.FieldDisplayOrder)
	}
	if m.category != nil {
		fields = append(fields, album.FieldCategoryID)
	}
	if m.title != nil {
		fields = append(fields, album.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, album.FieldDescription)
	}
	if m.location != nil {
		fields = append(fields, album.FieldLocation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldDeletedAt:
		return m.DeletedAt()
	case album.FieldCreatedAt:
		return m.CreatedAt()
	case album.FieldUpdatedAt:
		return m.UpdatedAt()
	case album.FieldImageURL:
		return m.ImageURL()
	case album.FieldBigImageURL:
		return m.BigImageURL()
	case album.FieldDownloadURL:
		return m.DownloadURL()
	case album.FieldThumbParam:
		return m.ThumbParam()
	case album.FieldBigParam:
		return m.BigParam()
	case album.FieldTags:
		return m.Tags()
	case album.FieldViewCount:
		return m.ViewCount()
	case album.FieldDownloadCount:
		return m.DownloadCount()
	case album.FieldWidth:
		return m.Width()
	case album.FieldHeight:
		return m.Height()
	case album.FieldFileSize:
		return m.FileSize()
	case album.FieldFormat:
		return m.Format()
	case album.FieldAspectRatio:
		return m.AspectRatio()
	case album.FieldFileHash:
		return m.FileHash()
	case album.FieldDisplayOrder:
		return m.DisplayOrder()
	case album.FieldCategoryID:
		return m.CategoryID()
	case album.FieldTitle:
		return m.Title()
	case album.FieldDescription:
		return m.Description()
	case album.FieldLocation:
		return m.Location()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case album.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case album.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case album.FieldImageURL:
		return m.OldImageURL(ctx)
	case album.FieldBigImageURL:
		return m.OldBigImageURL(ctx)
	case album.FieldDownloadURL:
		return m.OldDownloadURL(ctx)
	case album.FieldThumbParam:
		return m.OldThumbParam(ctx)
	case album.FieldBigParam:
		return m.OldBigParam(ctx)
	case album.FieldTags:
		return m.OldTags(ctx)
	case album.FieldViewCount:
		return m.OldViewCount(ctx)
	case album.FieldDownloadCount:
		return m.OldDownloadCount(ctx)
	case album.FieldWidth:
		return m.OldWidth(ctx)
	case album.FieldHeight:
		return m.OldHeight(ctx)
	case album.FieldFileSize:
		return m.OldFileSize(ctx)
	case album.FieldFormat:
		return m.OldFormat(ctx)
	case album.FieldAspectRatio:
		return m.OldAspectRatio(ctx)
	case album.FieldFileHash:
		return m.OldFileHash(ctx)
	case album.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case album.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case album.FieldTitle:
		return m.OldTitle(ctx)
	case album.FieldDescription:
		return m.OldDescription(ctx)
	case album.FieldLocation:
		return m.OldLocation(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case album.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case album.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case album.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case album.FieldBigImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigImageURL(v)
		return nil
	case album.FieldDownloadURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadURL(v)
		return nil
	case album.FieldThumbParam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbParam(v)
		return nil
	case album.FieldBigParam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigParam(v)
		return nil
	case album.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case album.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case album.FieldDownloadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadCount(v)
		return nil
	case album.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case album.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case album.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case album.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case album.FieldAspectRatio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAspectRatio(v)
		return nil
	case album.FieldFileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileHash(v)
		return nil
	case album.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case album.FieldCategoryID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case album.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case album.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case album.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, album.FieldViewCount)
	}
	if m.adddownload_count != nil {
		fields = append(fields, album.FieldDownloadCount)
	}
	if m.addwidth != nil {
		fields = append(fields, album.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, album.FieldHeight)
	}
	if m.addfile_size != nil {
		fields = append(fields, album.FieldFileSize)
	}
	if m.adddisplay_order != nil {
		fields = append(fields, album.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case album.FieldViewCount:
		return m.AddedViewCount()
	case album.FieldDownloadCount:
		return m.AddedDownloadCount()
	case album.FieldWidth:
		return m.AddedWidth()
	case album.FieldHeight:
		return m.AddedHeight()
	case album.FieldFileSize:
		return m.AddedFileSize()
	case album.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case album.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case album.FieldDownloadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadCount(v)
		return nil
	case album.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case album.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case album.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case album.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(album.FieldDeletedAt) {
		fields = append(fields, album.FieldDeletedAt)
	}
	if m.FieldCleared(album.FieldBigImageURL) {
		fields = append(fields, album.FieldBigImageURL)
	}
	if m.FieldCleared(album.FieldDownloadURL) {
		fields = append(fields, album.FieldDownloadURL)
	}
	if m.FieldCleared(album.FieldThumbParam) {
		fields = append(fields, album.FieldThumbParam)
	}
	if m.FieldCleared(album.FieldBigParam) {
		fields = append(fields, album.FieldBigParam)
	}
	if m.FieldCleared(album.FieldTags) {
		fields = append(fields, album.FieldTags)
	}
	if m.FieldCleared(album.FieldWidth) {
		fields = append(fields, album.FieldWidth)
	}
	if m.FieldCleared(album.FieldHeight) {
		fields = append(fields, album.FieldHeight)
	}
	if m.FieldCleared(album.FieldFileSize) {
		fields = append(fields, album.FieldFileSize)
	}
	if m.FieldCleared(album.FieldFormat) {
		fields = append(fields, album.FieldFormat)
	}
	if m.FieldCleared(album.FieldAspectRatio) {
		fields = append(fields, album.FieldAspectRatio)
	}
	if m.FieldCleared(album.FieldCategoryID) {
		fields = append(fields, album.FieldCategoryID)
	}
	if m.FieldCleared(album.FieldTitle) {
		fields = append(fields, album.FieldTitle)
	}
	if m.FieldCleared(album.FieldDescription) {
		fields = append(fields, album.FieldDescription)
	}
	if m.FieldCleared(album.FieldLocation) {
		fields = append(fields, album.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	switch name {
	case album.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case album.FieldBigImageURL:
		m.ClearBigImageURL()
		return nil
	case album.FieldDownloadURL:
		m.ClearDownloadURL()
		return nil
	case album.FieldThumbParam:
		m.ClearThumbParam()
		return nil
	case album.FieldBigParam:
		m.ClearBigParam()
		return nil
	case album.FieldTags:
		m.ClearTags()
		return nil
	case album.FieldWidth:
		m.ClearWidth()
		return nil
	case album.FieldHeight:
		m.ClearHeight()
		return nil
	case album.FieldFileSize:
		m.ClearFileSize()
		return nil
	case album.FieldFormat:
		m.ClearFormat()
		return nil
	case album.FieldAspectRatio:
		m.ClearAspectRatio()
		return nil
	case album.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case album.FieldTitle:
		m.ClearTitle()
		return nil
	case album.FieldDescription:
		m.ClearDescription()
		return nil
	case album.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case album.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case album.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case album.FieldImageURL:
		m.ResetImageURL()
		return nil
	case album.FieldBigImageURL:
		m.ResetBigImageURL()
		return nil
	case album.FieldDownloadURL:
		m.ResetDownloadURL()
		return nil
	case album.FieldThumbParam:
		m.ResetThumbParam()
		return nil
	case album.FieldBigParam:
		m.ResetBigParam()
		return nil
	case album.FieldTags:
		m.ResetTags()
		return nil
	case album.FieldViewCount:
		m.ResetViewCount()
		return nil
	case album.FieldDownloadCount:
		m.ResetDownloadCount()
		return nil
	case album.FieldWidth:
		m.ResetWidth()
		return nil
	case album.FieldHeight:
		m.ResetHeight()
		return nil
	case album.FieldFileSize:
		m.ResetFileSize()
		return nil
	case album.FieldFormat:
		m.ResetFormat()
		return nil
	case album.FieldAspectRatio:
		m.ResetAspectRatio()
		return nil
	case album.FieldFileHash:
		m.ResetFileHash()
		return nil
	case album.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case album.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case album.FieldTitle:
		m.ResetTitle()
		return nil
	case album.FieldDescription:
		m.ResetDescription()
		return nil
	case album.FieldLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.category != nil {
		edges = append(edges, album.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategory {
		edges = append(edges, album.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	switch name {
	case album.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	switch name {
	case album.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	switch name {
	case album.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Album edge %s", name)
}

// AlbumCategoryMutation represents an operation that mutates the AlbumCategory nodes in the graph.
type AlbumCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *uint
	name             *string
	description      *string
	display_order    *int
	adddisplay_order *int
	clearedFields    map[string]struct{}
	albums           map[uint]struct{}
	removedalbums    map[uint]struct{}
	clearedalbums    bool
	done             bool
	oldValue         func(context.Context) (*AlbumCategory, error)
	predicates       []predicate.AlbumCategory
}

var _ ent.Mutation = (*AlbumCategoryMutation)(nil)

// albumcategoryOption allows management of the mutation configuration using functional options.
type albumcategoryOption func(*AlbumCategoryMutation)

// newAlbumCategoryMutation creates new mutation for the AlbumCategory entity.
func newAlbumCategoryMutation(c config, op Op, opts ...albumcategoryOption) *AlbumCategoryMutation {
	m := &AlbumCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbumCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumCategoryID sets the ID field of the mutation.
func withAlbumCategoryID(id uint) albumcategoryOption {
	return func(m *AlbumCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AlbumCategory
		)
		m.oldValue = func(ctx context.Context) (*AlbumCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlbumCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbumCategory sets the old AlbumCategory of the mutation.
func withAlbumCategory(node *AlbumCategory) albumcategoryOption {
	return func(m *AlbumCategoryMutation) {
		m.oldValue = func(context.Context) (*AlbumCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlbumCategory entities.
func (m *AlbumCategoryMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumCategoryMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumCategoryMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlbumCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlbumCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlbumCategory entity.
// If the AlbumCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlbumCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlbumCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlbumCategory entity.
// If the AlbumCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlbumCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[albumcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlbumCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[albumcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlbumCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, albumcategory.FieldDescription)
}

// SetDisplayOrder sets the "display_order" field.
func (m *AlbumCategoryMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *AlbumCategoryMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the AlbumCategory entity.
// If the AlbumCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumCategoryMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *AlbumCategoryMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *AlbumCategoryMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *AlbumCategoryMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *AlbumCategoryMutation) AddAlbumIDs(ids ...uint) {
	if m.albums == nil {
		m.albums = make(map[uint]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *AlbumCategoryMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *AlbumCategoryMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *AlbumCategoryMutation) RemoveAlbumIDs(ids ...uint) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *AlbumCategoryMutation) RemovedAlbumsIDs() (ids []uint) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *AlbumCategoryMutation) AlbumsIDs() (ids []uint) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *AlbumCategoryMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// Where appends a list predicates to the AlbumCategoryMutation builder.
func (m *AlbumCategoryMutation) Where(ps ...predicate.AlbumCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlbumCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlbumCategory).
func (m *AlbumCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, albumcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, albumcategory.FieldDescription)
	}
	if m.display_order != nil {
		fields = append(fields, albumcategory.FieldDisplayOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case albumcategory.FieldName:
		return m.Name()
	case albumcategory.FieldDescription:
		return m.Description()
	case albumcategory.FieldDisplayOrder:
		return m.DisplayOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case albumcategory.FieldName:
		return m.OldName(ctx)
	case albumcategory.FieldDescription:
		return m.OldDescription(ctx)
	case albumcategory.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	}
	return nil, fmt.Errorf("unknown AlbumCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case albumcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case albumcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case albumcategory.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumCategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, albumcategory.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case albumcategory.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case albumcategory.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(albumcategory.FieldDescription) {
		fields = append(fields, albumcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumCategoryMutation) ClearField(name string) error {
	switch name {
	case albumcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AlbumCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumCategoryMutation) ResetField(name string) error {
	switch name {
	case albumcategory.FieldName:
		m.ResetName()
		return nil
	case albumcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case albumcategory.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown AlbumCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.albums != nil {
		edges = append(edges, albumcategory.EdgeAlbums)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case albumcategory.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedalbums != nil {
		edges = append(edges, albumcategory.EdgeAlbums)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case albumcategory.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedalbums {
		edges = append(edges, albumcategory.EdgeAlbums)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case albumcategory.EdgeAlbums:
		return m.clearedalbums
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AlbumCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumCategoryMutation) ResetEdge(name string) error {
	switch name {
	case albumcategory.EdgeAlbums:
		m.ResetAlbums()
		return nil
	}
	return fmt.Errorf("unknown AlbumCategory edge %s", name)
}

// ArticleMutation represents an operation that mutates the Article nodes in the graph.
type ArticleMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint
	deleted_at              *time.Time
	owner_id                *uint
	addowner_id             *int
	created_at              *time.Time
	updated_at              *time.Time
	title                   *string
	content_md              *string
	content_html            *string
	cover_url               *string
	status                  *article.Status
	view_count              *int
	addview_count           *int
	word_count              *int
	addword_count           *int
	reading_time            *int
	addreading_time         *int
	ip_location             *string
	primary_color           *string
	is_primary_color_manual *bool
	show_on_home            *bool
	home_sort               *int
	addhome_sort            *int
	pin_sort                *int
	addpin_sort             *int
	top_img_url             *string
	summaries               *[]string
	appendsummaries         []string
	abbrlink                *string
	copyright               *bool
	is_reprint              *bool
	copyright_author        *string
	copyright_author_href   *string
	copyright_url           *string
	keywords                *string
	scheduled_at            *time.Time
	review_status           *article.ReviewStatus
	review_comment          *string
	reviewed_at             *time.Time
	reviewed_by             *uint
	addreviewed_by          *int
	is_takedown             *bool
	takedown_reason         *string
	takedown_at             *time.Time
	takedown_by             *uint
	addtakedown_by          *int
	extra_config            *map[string]interface{}
	exclude_from_membership *bool
	is_doc                  *bool
	doc_sort                *int
	adddoc_sort             *int
	show_reward_button      *bool
	show_share_button       *bool
	show_subscribe_button   *bool
	clearedFields           map[string]struct{}
	post_tags               map[uint]struct{}
	removedpost_tags        map[uint]struct{}
	clearedpost_tags        bool
	post_categories         map[uint]struct{}
	removedpost_categories  map[uint]struct{}
	clearedpost_categories  bool
	comments                map[uint]struct{}
	removedcomments         map[uint]struct{}
	clearedcomments         bool
	histories               map[uint]struct{}
	removedhistories        map[uint]struct{}
	clearedhistories        bool
	doc_series              *uint
	cleareddoc_series       bool
	done                    bool
	oldValue                func(context.Context) (*Article, error)
	predicates              []predicate.Article
}

var _ ent.Mutation = (*ArticleMutation)(nil)

// articleOption allows management of the mutation configuration using functional options.
type articleOption func(*ArticleMutation)

// newArticleMutation creates new mutation for the Article entity.
func newArticleMutation(c config, op Op, opts ...articleOption) *ArticleMutation {
	m := &ArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleID sets the ID field of the mutation.
func withArticleID(id uint) articleOption {
	return func(m *ArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *Article
		)
		m.oldValue = func(ctx context.Context) (*Article, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Article.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticle sets the old Article of the mutation.
func withArticle(node *Article) articleOption {
	return func(m *ArticleMutation) {
		m.oldValue = func(context.Context) (*Article, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Article entities.
func (m *ArticleMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Article.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArticleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArticleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ArticleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[article.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ArticleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[article.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArticleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, article.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *ArticleMutation) SetOwnerID(u uint) {
	m.owner_id = &u
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ArticleMutation) OwnerID() (r uint, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldOwnerID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds u to the "owner_id" field.
func (m *ArticleMutation) AddOwnerID(u int) {
	if m.addowner_id != nil {
		*m.addowner_id += u
	} else {
		m.addowner_id = &u
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *ArticleMutation) AddedOwnerID() (r int, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ArticleMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *ArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContentMd sets the "content_md" field.
func (m *ArticleMutation) SetContentMd(s string) {
	m.content_md = &s
}

// ContentMd returns the value of the "content_md" field in the mutation.
func (m *ArticleMutation) ContentMd() (r string, exists bool) {
	v := m.content_md
	if v == nil {
		return
	}
	return *v, true
}

// OldContentMd returns the old "content_md" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldContentMd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentMd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentMd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentMd: %w", err)
	}
	return oldValue.ContentMd, nil
}

// ClearContentMd clears the value of the "content_md" field.
func (m *ArticleMutation) ClearContentMd() {
	m.content_md = nil
	m.clearedFields[article.FieldContentMd] = struct{}{}
}

// ContentMdCleared returns if the "content_md" field was cleared in this mutation.
func (m *ArticleMutation) ContentMdCleared() bool {
	_, ok := m.clearedFields[article.FieldContentMd]
	return ok
}

// ResetContentMd resets all changes to the "content_md" field.
func (m *ArticleMutation) ResetContentMd() {
	m.content_md = nil
	delete(m.clearedFields, article.FieldContentMd)
}

// SetContentHTML sets the "content_html" field.
func (m *ArticleMutation) SetContentHTML(s string) {
	m.content_html = &s
}

// ContentHTML returns the value of the "content_html" field in the mutation.
func (m *ArticleMutation) ContentHTML() (r string, exists bool) {
	v := m.content_html
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHTML returns the old "content_html" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldContentHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHTML: %w", err)
	}
	return oldValue.ContentHTML, nil
}

// ClearContentHTML clears the value of the "content_html" field.
func (m *ArticleMutation) ClearContentHTML() {
	m.content_html = nil
	m.clearedFields[article.FieldContentHTML] = struct{}{}
}

// ContentHTMLCleared returns if the "content_html" field was cleared in this mutation.
func (m *ArticleMutation) ContentHTMLCleared() bool {
	_, ok := m.clearedFields[article.FieldContentHTML]
	return ok
}

// ResetContentHTML resets all changes to the "content_html" field.
func (m *ArticleMutation) ResetContentHTML() {
	m.content_html = nil
	delete(m.clearedFields, article.FieldContentHTML)
}

// SetCoverURL sets the "cover_url" field.
func (m *ArticleMutation) SetCoverURL(s string) {
	m.cover_url = &s
}

// CoverURL returns the value of the "cover_url" field in the mutation.
func (m *ArticleMutation) CoverURL() (r string, exists bool) {
	v := m.cover_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverURL returns the old "cover_url" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCoverURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverURL: %w", err)
	}
	return oldValue.CoverURL, nil
}

// ClearCoverURL clears the value of the "cover_url" field.
func (m *ArticleMutation) ClearCoverURL() {
	m.cover_url = nil
	m.clearedFields[article.FieldCoverURL] = struct{}{}
}

// CoverURLCleared returns if the "cover_url" field was cleared in this mutation.
func (m *ArticleMutation) CoverURLCleared() bool {
	_, ok := m.clearedFields[article.FieldCoverURL]
	return ok
}

// ResetCoverURL resets all changes to the "cover_url" field.
func (m *ArticleMutation) ResetCoverURL() {
	m.cover_url = nil
	delete(m.clearedFields, article.FieldCoverURL)
}

// SetStatus sets the "status" field.
func (m *ArticleMutation) SetStatus(a article.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ArticleMutation) Status() (r article.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldStatus(ctx context.Context) (v article.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ArticleMutation) ResetStatus() {
	m.status = nil
}

// SetViewCount sets the "view_count" field.
func (m *ArticleMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *ArticleMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *ArticleMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *ArticleMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *ArticleMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetWordCount sets the "word_count" field.
func (m *ArticleMutation) SetWordCount(i int) {
	m.word_count = &i
	m.addword_count = nil
}

// WordCount returns the value of the "word_count" field in the mutation.
func (m *ArticleMutation) WordCount() (r int, exists bool) {
	v := m.word_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWordCount returns the old "word_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldWordCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordCount: %w", err)
	}
	return oldValue.WordCount, nil
}

// AddWordCount adds i to the "word_count" field.
func (m *ArticleMutation) AddWordCount(i int) {
	if m.addword_count != nil {
		*m.addword_count += i
	} else {
		m.addword_count = &i
	}
}

// AddedWordCount returns the value that was added to the "word_count" field in this mutation.
func (m *ArticleMutation) AddedWordCount() (r int, exists bool) {
	v := m.addword_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWordCount resets all changes to the "word_count" field.
func (m *ArticleMutation) ResetWordCount() {
	m.word_count = nil
	m.addword_count = nil
}

// SetReadingTime sets the "reading_time" field.
func (m *ArticleMutation) SetReadingTime(i int) {
	m.reading_time = &i
	m.addreading_time = nil
}

// ReadingTime returns the value of the "reading_time" field in the mutation.
func (m *ArticleMutation) ReadingTime() (r int, exists bool) {
	v := m.reading_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingTime returns the old "reading_time" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldReadingTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingTime: %w", err)
	}
	return oldValue.ReadingTime, nil
}

// AddReadingTime adds i to the "reading_time" field.
func (m *ArticleMutation) AddReadingTime(i int) {
	if m.addreading_time != nil {
		*m.addreading_time += i
	} else {
		m.addreading_time = &i
	}
}

// AddedReadingTime returns the value that was added to the "reading_time" field in this mutation.
func (m *ArticleMutation) AddedReadingTime() (r int, exists bool) {
	v := m.addreading_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadingTime resets all changes to the "reading_time" field.
func (m *ArticleMutation) ResetReadingTime() {
	m.reading_time = nil
	m.addreading_time = nil
}

// SetIPLocation sets the "ip_location" field.
func (m *ArticleMutation) SetIPLocation(s string) {
	m.ip_location = &s
}

// IPLocation returns the value of the "ip_location" field in the mutation.
func (m *ArticleMutation) IPLocation() (r string, exists bool) {
	v := m.ip_location
	if v == nil {
		return
	}
	return *v, true
}

// OldIPLocation returns the old "ip_location" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIPLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPLocation: %w", err)
	}
	return oldValue.IPLocation, nil
}

// ClearIPLocation clears the value of the "ip_location" field.
func (m *ArticleMutation) ClearIPLocation() {
	m.ip_location = nil
	m.clearedFields[article.FieldIPLocation] = struct{}{}
}

// IPLocationCleared returns if the "ip_location" field was cleared in this mutation.
func (m *ArticleMutation) IPLocationCleared() bool {
	_, ok := m.clearedFields[article.FieldIPLocation]
	return ok
}

// ResetIPLocation resets all changes to the "ip_location" field.
func (m *ArticleMutation) ResetIPLocation() {
	m.ip_location = nil
	delete(m.clearedFields, article.FieldIPLocation)
}

// SetPrimaryColor sets the "primary_color" field.
func (m *ArticleMutation) SetPrimaryColor(s string) {
	m.primary_color = &s
}

// PrimaryColor returns the value of the "primary_color" field in the mutation.
func (m *ArticleMutation) PrimaryColor() (r string, exists bool) {
	v := m.primary_color
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryColor returns the old "primary_color" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldPrimaryColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryColor: %w", err)
	}
	return oldValue.PrimaryColor, nil
}

// ClearPrimaryColor clears the value of the "primary_color" field.
func (m *ArticleMutation) ClearPrimaryColor() {
	m.primary_color = nil
	m.clearedFields[article.FieldPrimaryColor] = struct{}{}
}

// PrimaryColorCleared returns if the "primary_color" field was cleared in this mutation.
func (m *ArticleMutation) PrimaryColorCleared() bool {
	_, ok := m.clearedFields[article.FieldPrimaryColor]
	return ok
}

// ResetPrimaryColor resets all changes to the "primary_color" field.
func (m *ArticleMutation) ResetPrimaryColor() {
	m.primary_color = nil
	delete(m.clearedFields, article.FieldPrimaryColor)
}

// SetIsPrimaryColorManual sets the "is_primary_color_manual" field.
func (m *ArticleMutation) SetIsPrimaryColorManual(b bool) {
	m.is_primary_color_manual = &b
}

// IsPrimaryColorManual returns the value of the "is_primary_color_manual" field in the mutation.
func (m *ArticleMutation) IsPrimaryColorManual() (r bool, exists bool) {
	v := m.is_primary_color_manual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimaryColorManual returns the old "is_primary_color_manual" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIsPrimaryColorManual(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimaryColorManual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimaryColorManual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimaryColorManual: %w", err)
	}
	return oldValue.IsPrimaryColorManual, nil
}

// ResetIsPrimaryColorManual resets all changes to the "is_primary_color_manual" field.
func (m *ArticleMutation) ResetIsPrimaryColorManual() {
	m.is_primary_color_manual = nil
}

// SetShowOnHome sets the "show_on_home" field.
func (m *ArticleMutation) SetShowOnHome(b bool) {
	m.show_on_home = &b
}

// ShowOnHome returns the value of the "show_on_home" field in the mutation.
func (m *ArticleMutation) ShowOnHome() (r bool, exists bool) {
	v := m.show_on_home
	if v == nil {
		return
	}
	return *v, true
}

// OldShowOnHome returns the old "show_on_home" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldShowOnHome(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowOnHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowOnHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowOnHome: %w", err)
	}
	return oldValue.ShowOnHome, nil
}

// ResetShowOnHome resets all changes to the "show_on_home" field.
func (m *ArticleMutation) ResetShowOnHome() {
	m.show_on_home = nil
}

// SetHomeSort sets the "home_sort" field.
func (m *ArticleMutation) SetHomeSort(i int) {
	m.home_sort = &i
	m.addhome_sort = nil
}

// HomeSort returns the value of the "home_sort" field in the mutation.
func (m *ArticleMutation) HomeSort() (r int, exists bool) {
	v := m.home_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeSort returns the old "home_sort" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldHomeSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeSort: %w", err)
	}
	return oldValue.HomeSort, nil
}

// AddHomeSort adds i to the "home_sort" field.
func (m *ArticleMutation) AddHomeSort(i int) {
	if m.addhome_sort != nil {
		*m.addhome_sort += i
	} else {
		m.addhome_sort = &i
	}
}

// AddedHomeSort returns the value that was added to the "home_sort" field in this mutation.
func (m *ArticleMutation) AddedHomeSort() (r int, exists bool) {
	v := m.addhome_sort
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeSort resets all changes to the "home_sort" field.
func (m *ArticleMutation) ResetHomeSort() {
	m.home_sort = nil
	m.addhome_sort = nil
}

// SetPinSort sets the "pin_sort" field.
func (m *ArticleMutation) SetPinSort(i int) {
	m.pin_sort = &i
	m.addpin_sort = nil
}

// PinSort returns the value of the "pin_sort" field in the mutation.
func (m *ArticleMutation) PinSort() (r int, exists bool) {
	v := m.pin_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldPinSort returns the old "pin_sort" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldPinSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinSort: %w", err)
	}
	return oldValue.PinSort, nil
}

// AddPinSort adds i to the "pin_sort" field.
func (m *ArticleMutation) AddPinSort(i int) {
	if m.addpin_sort != nil {
		*m.addpin_sort += i
	} else {
		m.addpin_sort = &i
	}
}

// AddedPinSort returns the value that was added to the "pin_sort" field in this mutation.
func (m *ArticleMutation) AddedPinSort() (r int, exists bool) {
	v := m.addpin_sort
	if v == nil {
		return
	}
	return *v, true
}

// ResetPinSort resets all changes to the "pin_sort" field.
func (m *ArticleMutation) ResetPinSort() {
	m.pin_sort = nil
	m.addpin_sort = nil
}

// SetTopImgURL sets the "top_img_url" field.
func (m *ArticleMutation) SetTopImgURL(s string) {
	m.top_img_url = &s
}

// TopImgURL returns the value of the "top_img_url" field in the mutation.
func (m *ArticleMutation) TopImgURL() (r string, exists bool) {
	v := m.top_img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTopImgURL returns the old "top_img_url" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTopImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopImgURL: %w", err)
	}
	return oldValue.TopImgURL, nil
}

// ClearTopImgURL clears the value of the "top_img_url" field.
func (m *ArticleMutation) ClearTopImgURL() {
	m.top_img_url = nil
	m.clearedFields[article.FieldTopImgURL] = struct{}{}
}

// TopImgURLCleared returns if the "top_img_url" field was cleared in this mutation.
func (m *ArticleMutation) TopImgURLCleared() bool {
	_, ok := m.clearedFields[article.FieldTopImgURL]
	return ok
}

// ResetTopImgURL resets all changes to the "top_img_url" field.
func (m *ArticleMutation) ResetTopImgURL() {
	m.top_img_url = nil
	delete(m.clearedFields, article.FieldTopImgURL)
}

// SetSummaries sets the "summaries" field.
func (m *ArticleMutation) SetSummaries(s []string) {
	m.summaries = &s
	m.appendsummaries = nil
}

// Summaries returns the value of the "summaries" field in the mutation.
func (m *ArticleMutation) Summaries() (r []string, exists bool) {
	v := m.summaries
	if v == nil {
		return
	}
	return *v, true
}

// OldSummaries returns the old "summaries" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldSummaries(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummaries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummaries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummaries: %w", err)
	}
	return oldValue.Summaries, nil
}

// AppendSummaries adds s to the "summaries" field.
func (m *ArticleMutation) AppendSummaries(s []string) {
	m.appendsummaries = append(m.appendsummaries, s...)
}

// AppendedSummaries returns the list of values that were appended to the "summaries" field in this mutation.
func (m *ArticleMutation) AppendedSummaries() ([]string, bool) {
	if len(m.appendsummaries) == 0 {
		return nil, false
	}
	return m.appendsummaries, true
}

// ClearSummaries clears the value of the "summaries" field.
func (m *ArticleMutation) ClearSummaries() {
	m.summaries = nil
	m.appendsummaries = nil
	m.clearedFields[article.FieldSummaries] = struct{}{}
}

// SummariesCleared returns if the "summaries" field was cleared in this mutation.
func (m *ArticleMutation) SummariesCleared() bool {
	_, ok := m.clearedFields[article.FieldSummaries]
	return ok
}

// ResetSummaries resets all changes to the "summaries" field.
func (m *ArticleMutation) ResetSummaries() {
	m.summaries = nil
	m.appendsummaries = nil
	delete(m.clearedFields, article.FieldSummaries)
}

// SetAbbrlink sets the "abbrlink" field.
func (m *ArticleMutation) SetAbbrlink(s string) {
	m.abbrlink = &s
}

// Abbrlink returns the value of the "abbrlink" field in the mutation.
func (m *ArticleMutation) Abbrlink() (r string, exists bool) {
	v := m.abbrlink
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbrlink returns the old "abbrlink" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldAbbrlink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbrlink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbrlink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbrlink: %w", err)
	}
	return oldValue.Abbrlink, nil
}

// ClearAbbrlink clears the value of the "abbrlink" field.
func (m *ArticleMutation) ClearAbbrlink() {
	m.abbrlink = nil
	m.clearedFields[article.FieldAbbrlink] = struct{}{}
}

// AbbrlinkCleared returns if the "abbrlink" field was cleared in this mutation.
func (m *ArticleMutation) AbbrlinkCleared() bool {
	_, ok := m.clearedFields[article.FieldAbbrlink]
	return ok
}

// ResetAbbrlink resets all changes to the "abbrlink" field.
func (m *ArticleMutation) ResetAbbrlink() {
	m.abbrlink = nil
	delete(m.clearedFields, article.FieldAbbrlink)
}

// SetCopyright sets the "copyright" field.
func (m *ArticleMutation) SetCopyright(b bool) {
	m.copyright = &b
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *ArticleMutation) Copyright() (r bool, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyright(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *ArticleMutation) ResetCopyright() {
	m.copyright = nil
}

// SetIsReprint sets the "is_reprint" field.
func (m *ArticleMutation) SetIsReprint(b bool) {
	m.is_reprint = &b
}

// IsReprint returns the value of the "is_reprint" field in the mutation.
func (m *ArticleMutation) IsReprint() (r bool, exists bool) {
	v := m.is_reprint
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReprint returns the old "is_reprint" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIsReprint(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReprint: %w", err)
	}
	return oldValue.IsReprint, nil
}

// ResetIsReprint resets all changes to the "is_reprint" field.
func (m *ArticleMutation) ResetIsReprint() {
	m.is_reprint = nil
}

// SetCopyrightAuthor sets the "copyright_author" field.
func (m *ArticleMutation) SetCopyrightAuthor(s string) {
	m.copyright_author = &s
}

// CopyrightAuthor returns the value of the "copyright_author" field in the mutation.
func (m *ArticleMutation) CopyrightAuthor() (r string, exists bool) {
	v := m.copyright_author
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightAuthor returns the old "copyright_author" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyrightAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightAuthor: %w", err)
	}
	return oldValue.CopyrightAuthor, nil
}

// ClearCopyrightAuthor clears the value of the "copyright_author" field.
func (m *ArticleMutation) ClearCopyrightAuthor() {
	m.copyright_author = nil
	m.clearedFields[article.FieldCopyrightAuthor] = struct{}{}
}

// CopyrightAuthorCleared returns if the "copyright_author" field was cleared in this mutation.
func (m *ArticleMutation) CopyrightAuthorCleared() bool {
	_, ok := m.clearedFields[article.FieldCopyrightAuthor]
	return ok
}

// ResetCopyrightAuthor resets all changes to the "copyright_author" field.
func (m *ArticleMutation) ResetCopyrightAuthor() {
	m.copyright_author = nil
	delete(m.clearedFields, article.FieldCopyrightAuthor)
}

// SetCopyrightAuthorHref sets the "copyright_author_href" field.
func (m *ArticleMutation) SetCopyrightAuthorHref(s string) {
	m.copyright_author_href = &s
}

// CopyrightAuthorHref returns the value of the "copyright_author_href" field in the mutation.
func (m *ArticleMutation) CopyrightAuthorHref() (r string, exists bool) {
	v := m.copyright_author_href
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightAuthorHref returns the old "copyright_author_href" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyrightAuthorHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightAuthorHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightAuthorHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightAuthorHref: %w", err)
	}
	return oldValue.CopyrightAuthorHref, nil
}

// ClearCopyrightAuthorHref clears the value of the "copyright_author_href" field.
func (m *ArticleMutation) ClearCopyrightAuthorHref() {
	m.copyright_author_href = nil
	m.clearedFields[article.FieldCopyrightAuthorHref] = struct{}{}
}

// CopyrightAuthorHrefCleared returns if the "copyright_author_href" field was cleared in this mutation.
func (m *ArticleMutation) CopyrightAuthorHrefCleared() bool {
	_, ok := m.clearedFields[article.FieldCopyrightAuthorHref]
	return ok
}

// ResetCopyrightAuthorHref resets all changes to the "copyright_author_href" field.
func (m *ArticleMutation) ResetCopyrightAuthorHref() {
	m.copyright_author_href = nil
	delete(m.clearedFields, article.FieldCopyrightAuthorHref)
}

// SetCopyrightURL sets the "copyright_url" field.
func (m *ArticleMutation) SetCopyrightURL(s string) {
	m.copyright_url = &s
}

// CopyrightURL returns the value of the "copyright_url" field in the mutation.
func (m *ArticleMutation) CopyrightURL() (r string, exists bool) {
	v := m.copyright_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightURL returns the old "copyright_url" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyrightURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightURL: %w", err)
	}
	return oldValue.CopyrightURL, nil
}

// ClearCopyrightURL clears the value of the "copyright_url" field.
func (m *ArticleMutation) ClearCopyrightURL() {
	m.copyright_url = nil
	m.clearedFields[article.FieldCopyrightURL] = struct{}{}
}

// CopyrightURLCleared returns if the "copyright_url" field was cleared in this mutation.
func (m *ArticleMutation) CopyrightURLCleared() bool {
	_, ok := m.clearedFields[article.FieldCopyrightURL]
	return ok
}

// ResetCopyrightURL resets all changes to the "copyright_url" field.
func (m *ArticleMutation) ResetCopyrightURL() {
	m.copyright_url = nil
	delete(m.clearedFields, article.FieldCopyrightURL)
}

// SetKeywords sets the "keywords" field.
func (m *ArticleMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *ArticleMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *ArticleMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[article.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *ArticleMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[article.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *ArticleMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, article.FieldKeywords)
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *ArticleMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *ArticleMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldScheduledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ClearScheduledAt clears the value of the "scheduled_at" field.
func (m *ArticleMutation) ClearScheduledAt() {
	m.scheduled_at = nil
	m.clearedFields[article.FieldScheduledAt] = struct{}{}
}

// ScheduledAtCleared returns if the "scheduled_at" field was cleared in this mutation.
func (m *ArticleMutation) ScheduledAtCleared() bool {
	_, ok := m.clearedFields[article.FieldScheduledAt]
	return ok
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *ArticleMutation) ResetScheduledAt() {
	m.scheduled_at = nil
	delete(m.clearedFields, article.FieldScheduledAt)
}

// SetReviewStatus sets the "review_status" field.
func (m *ArticleMutation) SetReviewStatus(as article.ReviewStatus) {
	m.review_status = &as
}

// ReviewStatus returns the value of the "review_status" field in the mutation.
func (m *ArticleMutation) ReviewStatus() (r article.ReviewStatus, exists bool) {
	v := m.review_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewStatus returns the old "review_status" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldReviewStatus(ctx context.Context) (v article.ReviewStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewStatus: %w", err)
	}
	return oldValue.ReviewStatus, nil
}

// ResetReviewStatus resets all changes to the "review_status" field.
func (m *ArticleMutation) ResetReviewStatus() {
	m.review_status = nil
}

// SetReviewComment sets the "review_comment" field.
func (m *ArticleMutation) SetReviewComment(s string) {
	m.review_comment = &s
}

// ReviewComment returns the value of the "review_comment" field in the mutation.
func (m *ArticleMutation) ReviewComment() (r string, exists bool) {
	v := m.review_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewComment returns the old "review_comment" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldReviewComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewComment: %w", err)
	}
	return oldValue.ReviewComment, nil
}

// ClearReviewComment clears the value of the "review_comment" field.
func (m *ArticleMutation) ClearReviewComment() {
	m.review_comment = nil
	m.clearedFields[article.FieldReviewComment] = struct{}{}
}

// ReviewCommentCleared returns if the "review_comment" field was cleared in this mutation.
func (m *ArticleMutation) ReviewCommentCleared() bool {
	_, ok := m.clearedFields[article.FieldReviewComment]
	return ok
}

// ResetReviewComment resets all changes to the "review_comment" field.
func (m *ArticleMutation) ResetReviewComment() {
	m.review_comment = nil
	delete(m.clearedFields, article.FieldReviewComment)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *ArticleMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *ArticleMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldReviewedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *ArticleMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[article.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *ArticleMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[article.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *ArticleMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, article.FieldReviewedAt)
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *ArticleMutation) SetReviewedBy(u uint) {
	m.reviewed_by = &u
	m.addreviewed_by = nil
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *ArticleMutation) ReviewedBy() (r uint, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldReviewedBy(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// AddReviewedBy adds u to the "reviewed_by" field.
func (m *ArticleMutation) AddReviewedBy(u int) {
	if m.addreviewed_by != nil {
		*m.addreviewed_by += u
	} else {
		m.addreviewed_by = &u
	}
}

// AddedReviewedBy returns the value that was added to the "reviewed_by" field in this mutation.
func (m *ArticleMutation) AddedReviewedBy() (r int, exists bool) {
	v := m.addreviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearReviewedBy clears the value of the "reviewed_by" field.
func (m *ArticleMutation) ClearReviewedBy() {
	m.reviewed_by = nil
	m.addreviewed_by = nil
	m.clearedFields[article.FieldReviewedBy] = struct{}{}
}

// ReviewedByCleared returns if the "reviewed_by" field was cleared in this mutation.
func (m *ArticleMutation) ReviewedByCleared() bool {
	_, ok := m.clearedFields[article.FieldReviewedBy]
	return ok
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *ArticleMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	m.addreviewed_by = nil
	delete(m.clearedFields, article.FieldReviewedBy)
}

// SetIsTakedown sets the "is_takedown" field.
func (m *ArticleMutation) SetIsTakedown(b bool) {
	m.is_takedown = &b
}

// IsTakedown returns the value of the "is_takedown" field in the mutation.
func (m *ArticleMutation) IsTakedown() (r bool, exists bool) {
	v := m.is_takedown
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTakedown returns the old "is_takedown" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIsTakedown(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTakedown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTakedown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTakedown: %w", err)
	}
	return oldValue.IsTakedown, nil
}

// ResetIsTakedown resets all changes to the "is_takedown" field.
func (m *ArticleMutation) ResetIsTakedown() {
	m.is_takedown = nil
}

// SetTakedownReason sets the "takedown_reason" field.
func (m *ArticleMutation) SetTakedownReason(s string) {
	m.takedown_reason = &s
}

// TakedownReason returns the value of the "takedown_reason" field in the mutation.
func (m *ArticleMutation) TakedownReason() (r string, exists bool) {
	v := m.takedown_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldTakedownReason returns the old "takedown_reason" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTakedownReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakedownReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakedownReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakedownReason: %w", err)
	}
	return oldValue.TakedownReason, nil
}

// ClearTakedownReason clears the value of the "takedown_reason" field.
func (m *ArticleMutation) ClearTakedownReason() {
	m.takedown_reason = nil
	m.clearedFields[article.FieldTakedownReason] = struct{}{}
}

// TakedownReasonCleared returns if the "takedown_reason" field was cleared in this mutation.
func (m *ArticleMutation) TakedownReasonCleared() bool {
	_, ok := m.clearedFields[article.FieldTakedownReason]
	return ok
}

// ResetTakedownReason resets all changes to the "takedown_reason" field.
func (m *ArticleMutation) ResetTakedownReason() {
	m.takedown_reason = nil
	delete(m.clearedFields, article.FieldTakedownReason)
}

// SetTakedownAt sets the "takedown_at" field.
func (m *ArticleMutation) SetTakedownAt(t time.Time) {
	m.takedown_at = &t
}

// TakedownAt returns the value of the "takedown_at" field in the mutation.
func (m *ArticleMutation) TakedownAt() (r time.Time, exists bool) {
	v := m.takedown_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTakedownAt returns the old "takedown_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTakedownAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakedownAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakedownAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakedownAt: %w", err)
	}
	return oldValue.TakedownAt, nil
}

// ClearTakedownAt clears the value of the "takedown_at" field.
func (m *ArticleMutation) ClearTakedownAt() {
	m.takedown_at = nil
	m.clearedFields[article.FieldTakedownAt] = struct{}{}
}

// TakedownAtCleared returns if the "takedown_at" field was cleared in this mutation.
func (m *ArticleMutation) TakedownAtCleared() bool {
	_, ok := m.clearedFields[article.FieldTakedownAt]
	return ok
}

// ResetTakedownAt resets all changes to the "takedown_at" field.
func (m *ArticleMutation) ResetTakedownAt() {
	m.takedown_at = nil
	delete(m.clearedFields, article.FieldTakedownAt)
}

// SetTakedownBy sets the "takedown_by" field.
func (m *ArticleMutation) SetTakedownBy(u uint) {
	m.takedown_by = &u
	m.addtakedown_by = nil
}

// TakedownBy returns the value of the "takedown_by" field in the mutation.
func (m *ArticleMutation) TakedownBy() (r uint, exists bool) {
	v := m.takedown_by
	if v == nil {
		return
	}
	return *v, true
}

// OldTakedownBy returns the old "takedown_by" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTakedownBy(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakedownBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakedownBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakedownBy: %w", err)
	}
	return oldValue.TakedownBy, nil
}

// AddTakedownBy adds u to the "takedown_by" field.
func (m *ArticleMutation) AddTakedownBy(u int) {
	if m.addtakedown_by != nil {
		*m.addtakedown_by += u
	} else {
		m.addtakedown_by = &u
	}
}

// AddedTakedownBy returns the value that was added to the "takedown_by" field in this mutation.
func (m *ArticleMutation) AddedTakedownBy() (r int, exists bool) {
	v := m.addtakedown_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearTakedownBy clears the value of the "takedown_by" field.
func (m *ArticleMutation) ClearTakedownBy() {
	m.takedown_by = nil
	m.addtakedown_by = nil
	m.clearedFields[article.FieldTakedownBy] = struct{}{}
}

// TakedownByCleared returns if the "takedown_by" field was cleared in this mutation.
func (m *ArticleMutation) TakedownByCleared() bool {
	_, ok := m.clearedFields[article.FieldTakedownBy]
	return ok
}

// ResetTakedownBy resets all changes to the "takedown_by" field.
func (m *ArticleMutation) ResetTakedownBy() {
	m.takedown_by = nil
	m.addtakedown_by = nil
	delete(m.clearedFields, article.FieldTakedownBy)
}

// SetExtraConfig sets the "extra_config" field.
func (m *ArticleMutation) SetExtraConfig(value map[string]interface{}) {
	m.extra_config = &value
}

// ExtraConfig returns the value of the "extra_config" field in the mutation.
func (m *ArticleMutation) ExtraConfig() (r map[string]interface{}, exists bool) {
	v := m.extra_config
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraConfig returns the old "extra_config" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldExtraConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraConfig: %w", err)
	}
	return oldValue.ExtraConfig, nil
}

// ClearExtraConfig clears the value of the "extra_config" field.
func (m *ArticleMutation) ClearExtraConfig() {
	m.extra_config = nil
	m.clearedFields[article.FieldExtraConfig] = struct{}{}
}

// ExtraConfigCleared returns if the "extra_config" field was cleared in this mutation.
func (m *ArticleMutation) ExtraConfigCleared() bool {
	_, ok := m.clearedFields[article.FieldExtraConfig]
	return ok
}

// ResetExtraConfig resets all changes to the "extra_config" field.
func (m *ArticleMutation) ResetExtraConfig() {
	m.extra_config = nil
	delete(m.clearedFields, article.FieldExtraConfig)
}

// SetExcludeFromMembership sets the "exclude_from_membership" field.
func (m *ArticleMutation) SetExcludeFromMembership(b bool) {
	m.exclude_from_membership = &b
}

// ExcludeFromMembership returns the value of the "exclude_from_membership" field in the mutation.
func (m *ArticleMutation) ExcludeFromMembership() (r bool, exists bool) {
	v := m.exclude_from_membership
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludeFromMembership returns the old "exclude_from_membership" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldExcludeFromMembership(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludeFromMembership is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludeFromMembership requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludeFromMembership: %w", err)
	}
	return oldValue.ExcludeFromMembership, nil
}

// ResetExcludeFromMembership resets all changes to the "exclude_from_membership" field.
func (m *ArticleMutation) ResetExcludeFromMembership() {
	m.exclude_from_membership = nil
}

// SetIsDoc sets the "is_doc" field.
func (m *ArticleMutation) SetIsDoc(b bool) {
	m.is_doc = &b
}

// IsDoc returns the value of the "is_doc" field in the mutation.
func (m *ArticleMutation) IsDoc() (r bool, exists bool) {
	v := m.is_doc
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDoc returns the old "is_doc" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIsDoc(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDoc: %w", err)
	}
	return oldValue.IsDoc, nil
}

// ResetIsDoc resets all changes to the "is_doc" field.
func (m *ArticleMutation) ResetIsDoc() {
	m.is_doc = nil
}

// SetDocSeriesID sets the "doc_series_id" field.
func (m *ArticleMutation) SetDocSeriesID(u uint) {
	m.doc_series = &u
}

// DocSeriesID returns the value of the "doc_series_id" field in the mutation.
func (m *ArticleMutation) DocSeriesID() (r uint, exists bool) {
	v := m.doc_series
	if v == nil {
		return
	}
	return *v, true
}

// OldDocSeriesID returns the old "doc_series_id" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldDocSeriesID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocSeriesID: %w", err)
	}
	return oldValue.DocSeriesID, nil
}

// ClearDocSeriesID clears the value of the "doc_series_id" field.
func (m *ArticleMutation) ClearDocSeriesID() {
	m.doc_series = nil
	m.clearedFields[article.FieldDocSeriesID] = struct{}{}
}

// DocSeriesIDCleared returns if the "doc_series_id" field was cleared in this mutation.
func (m *ArticleMutation) DocSeriesIDCleared() bool {
	_, ok := m.clearedFields[article.FieldDocSeriesID]
	return ok
}

// ResetDocSeriesID resets all changes to the "doc_series_id" field.
func (m *ArticleMutation) ResetDocSeriesID() {
	m.doc_series = nil
	delete(m.clearedFields, article.FieldDocSeriesID)
}

// SetDocSort sets the "doc_sort" field.
func (m *ArticleMutation) SetDocSort(i int) {
	m.doc_sort = &i
	m.adddoc_sort = nil
}

// DocSort returns the value of the "doc_sort" field in the mutation.
func (m *ArticleMutation) DocSort() (r int, exists bool) {
	v := m.doc_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDocSort returns the old "doc_sort" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldDocSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocSort: %w", err)
	}
	return oldValue.DocSort, nil
}

// AddDocSort adds i to the "doc_sort" field.
func (m *ArticleMutation) AddDocSort(i int) {
	if m.adddoc_sort != nil {
		*m.adddoc_sort += i
	} else {
		m.adddoc_sort = &i
	}
}

// AddedDocSort returns the value that was added to the "doc_sort" field in this mutation.
func (m *ArticleMutation) AddedDocSort() (r int, exists bool) {
	v := m.adddoc_sort
	if v == nil {
		return
	}
	return *v, true
}

// ResetDocSort resets all changes to the "doc_sort" field.
func (m *ArticleMutation) ResetDocSort() {
	m.doc_sort = nil
	m.adddoc_sort = nil
}

// SetShowRewardButton sets the "show_reward_button" field.
func (m *ArticleMutation) SetShowRewardButton(b bool) {
	m.show_reward_button = &b
}

// ShowRewardButton returns the value of the "show_reward_button" field in the mutation.
func (m *ArticleMutation) ShowRewardButton() (r bool, exists bool) {
	v := m.show_reward_button
	if v == nil {
		return
	}
	return *v, true
}

// OldShowRewardButton returns the old "show_reward_button" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldShowRewardButton(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowRewardButton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowRewardButton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowRewardButton: %w", err)
	}
	return oldValue.ShowRewardButton, nil
}

// ResetShowRewardButton resets all changes to the "show_reward_button" field.
func (m *ArticleMutation) ResetShowRewardButton() {
	m.show_reward_button = nil
}

// SetShowShareButton sets the "show_share_button" field.
func (m *ArticleMutation) SetShowShareButton(b bool) {
	m.show_share_button = &b
}

// ShowShareButton returns the value of the "show_share_button" field in the mutation.
func (m *ArticleMutation) ShowShareButton() (r bool, exists bool) {
	v := m.show_share_button
	if v == nil {
		return
	}
	return *v, true
}

// OldShowShareButton returns the old "show_share_button" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldShowShareButton(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowShareButton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowShareButton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowShareButton: %w", err)
	}
	return oldValue.ShowShareButton, nil
}

// ResetShowShareButton resets all changes to the "show_share_button" field.
func (m *ArticleMutation) ResetShowShareButton() {
	m.show_share_button = nil
}

// SetShowSubscribeButton sets the "show_subscribe_button" field.
func (m *ArticleMutation) SetShowSubscribeButton(b bool) {
	m.show_subscribe_button = &b
}

// ShowSubscribeButton returns the value of the "show_subscribe_button" field in the mutation.
func (m *ArticleMutation) ShowSubscribeButton() (r bool, exists bool) {
	v := m.show_subscribe_button
	if v == nil {
		return
	}
	return *v, true
}

// OldShowSubscribeButton returns the old "show_subscribe_button" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldShowSubscribeButton(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowSubscribeButton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowSubscribeButton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowSubscribeButton: %w", err)
	}
	return oldValue.ShowSubscribeButton, nil
}

// ResetShowSubscribeButton resets all changes to the "show_subscribe_button" field.
func (m *ArticleMutation) ResetShowSubscribeButton() {
	m.show_subscribe_button = nil
}

// AddPostTagIDs adds the "post_tags" edge to the PostTag entity by ids.
func (m *ArticleMutation) AddPostTagIDs(ids ...uint) {
	if m.post_tags == nil {
		m.post_tags = make(map[uint]struct{})
	}
	for i := range ids {
		m.post_tags[ids[i]] = struct{}{}
	}
}

// ClearPostTags clears the "post_tags" edge to the PostTag entity.
func (m *ArticleMutation) ClearPostTags() {
	m.clearedpost_tags = true
}

// PostTagsCleared reports if the "post_tags" edge to the PostTag entity was cleared.
func (m *ArticleMutation) PostTagsCleared() bool {
	return m.clearedpost_tags
}

// RemovePostTagIDs removes the "post_tags" edge to the PostTag entity by IDs.
func (m *ArticleMutation) RemovePostTagIDs(ids ...uint) {
	if m.removedpost_tags == nil {
		m.removedpost_tags = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.post_tags, ids[i])
		m.removedpost_tags[ids[i]] = struct{}{}
	}
}

// RemovedPostTags returns the removed IDs of the "post_tags" edge to the PostTag entity.
func (m *ArticleMutation) RemovedPostTagsIDs() (ids []uint) {
	for id := range m.removedpost_tags {
		ids = append(ids, id)
	}
	return
}

// PostTagsIDs returns the "post_tags" edge IDs in the mutation.
func (m *ArticleMutation) PostTagsIDs() (ids []uint) {
	for id := range m.post_tags {
		ids = append(ids, id)
	}
	return
}

// ResetPostTags resets all changes to the "post_tags" edge.
func (m *ArticleMutation) ResetPostTags() {
	m.post_tags = nil
	m.clearedpost_tags = false
	m.removedpost_tags = nil
}

// AddPostCategoryIDs adds the "post_categories" edge to the PostCategory entity by ids.
func (m *ArticleMutation) AddPostCategoryIDs(ids ...uint) {
	if m.post_categories == nil {
		m.post_categories = make(map[uint]struct{})
	}
	for i := range ids {
		m.post_categories[ids[i]] = struct{}{}
	}
}

// ClearPostCategories clears the "post_categories" edge to the PostCategory entity.
func (m *ArticleMutation) ClearPostCategories() {
	m.clearedpost_categories = true
}

// PostCategoriesCleared reports if the "post_categories" edge to the PostCategory entity was cleared.
func (m *ArticleMutation) PostCategoriesCleared() bool {
	return m.clearedpost_categories
}

// RemovePostCategoryIDs removes the "post_categories" edge to the PostCategory entity by IDs.
func (m *ArticleMutation) RemovePostCategoryIDs(ids ...uint) {
	if m.removedpost_categories == nil {
		m.removedpost_categories = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.post_categories, ids[i])
		m.removedpost_categories[ids[i]] = struct{}{}
	}
}

// RemovedPostCategories returns the removed IDs of the "post_categories" edge to the PostCategory entity.
func (m *ArticleMutation) RemovedPostCategoriesIDs() (ids []uint) {
	for id := range m.removedpost_categories {
		ids = append(ids, id)
	}
	return
}

// PostCategoriesIDs returns the "post_categories" edge IDs in the mutation.
func (m *ArticleMutation) PostCategoriesIDs() (ids []uint) {
	for id := range m.post_categories {
		ids = append(ids, id)
	}
	return
}

// ResetPostCategories resets all changes to the "post_categories" edge.
func (m *ArticleMutation) ResetPostCategories() {
	m.post_categories = nil
	m.clearedpost_categories = false
	m.removedpost_categories = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ArticleMutation) AddCommentIDs(ids ...uint) {
	if m.comments == nil {
		m.comments = make(map[uint]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ArticleMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ArticleMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ArticleMutation) RemoveCommentIDs(ids ...uint) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ArticleMutation) RemovedCommentsIDs() (ids []uint) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ArticleMutation) CommentsIDs() (ids []uint) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ArticleMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddHistoryIDs adds the "histories" edge to the ArticleHistory entity by ids.
func (m *ArticleMutation) AddHistoryIDs(ids ...uint) {
	if m.histories == nil {
		m.histories = make(map[uint]struct{})
	}
	for i := range ids {
		m.histories[ids[i]] = struct{}{}
	}
}

// ClearHistories clears the "histories" edge to the ArticleHistory entity.
func (m *ArticleMutation) ClearHistories() {
	m.clearedhistories = true
}

// HistoriesCleared reports if the "histories" edge to the ArticleHistory entity was cleared.
func (m *ArticleMutation) HistoriesCleared() bool {
	return m.clearedhistories
}

// RemoveHistoryIDs removes the "histories" edge to the ArticleHistory entity by IDs.
func (m *ArticleMutation) RemoveHistoryIDs(ids ...uint) {
	if m.removedhistories == nil {
		m.removedhistories = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.histories, ids[i])
		m.removedhistories[ids[i]] = struct{}{}
	}
}

// RemovedHistories returns the removed IDs of the "histories" edge to the ArticleHistory entity.
func (m *ArticleMutation) RemovedHistoriesIDs() (ids []uint) {
	for id := range m.removedhistories {
		ids = append(ids, id)
	}
	return
}

// HistoriesIDs returns the "histories" edge IDs in the mutation.
func (m *ArticleMutation) HistoriesIDs() (ids []uint) {
	for id := range m.histories {
		ids = append(ids, id)
	}
	return
}

// ResetHistories resets all changes to the "histories" edge.
func (m *ArticleMutation) ResetHistories() {
	m.histories = nil
	m.clearedhistories = false
	m.removedhistories = nil
}

// ClearDocSeries clears the "doc_series" edge to the DocSeries entity.
func (m *ArticleMutation) ClearDocSeries() {
	m.cleareddoc_series = true
	m.clearedFields[article.FieldDocSeriesID] = struct{}{}
}

// DocSeriesCleared reports if the "doc_series" edge to the DocSeries entity was cleared.
func (m *ArticleMutation) DocSeriesCleared() bool {
	return m.DocSeriesIDCleared() || m.cleareddoc_series
}

// DocSeriesIDs returns the "doc_series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocSeriesID instead. It exists only for internal usage by the builders.
func (m *ArticleMutation) DocSeriesIDs() (ids []uint) {
	if id := m.doc_series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocSeries resets all changes to the "doc_series" edge.
func (m *ArticleMutation) ResetDocSeries() {
	m.doc_series = nil
	m.cleareddoc_series = false
}

// Where appends a list predicates to the ArticleMutation builder.
func (m *ArticleMutation) Where(ps ...predicate.Article) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Article, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Article).
func (m *ArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleMutation) Fields() []string {
	fields := make([]string, 0, 44)
	if m.deleted_at != nil {
		fields = append(fields, article.FieldDeletedAt)
	}
	if m.owner_id != nil {
		fields = append(fields, article.FieldOwnerID)
	}
	if m.created_at != nil {
		fields = append(fields, article.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, article.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, article.FieldTitle)
	}
	if m.content_md != nil {
		fields = append(fields, article.FieldContentMd)
	}
	if m.content_html != nil {
		fields = append(fields, article.FieldContentHTML)
	}
	if m.cover_url != nil {
		fields = append(fields, article.FieldCoverURL)
	}
	if m.status != nil {
		fields = append(fields, article.FieldStatus)
	}
	if m.view_count != nil {
		fields = append(fields, article.FieldViewCount)
	}
	if m.word_count != nil {
		fields = append(fields, article.FieldWordCount)
	}
	if m.reading_time != nil {
		fields = append(fields, article.FieldReadingTime)
	}
	if m.ip_location != nil {
		fields = append(fields, article.FieldIPLocation)
	}
	if m.primary_color != nil {
		fields = append(fields, article.FieldPrimaryColor)
	}
	if m.is_primary_color_manual != nil {
		fields = append(fields, article.FieldIsPrimaryColorManual)
	}
	if m.show_on_home != nil {
		fields = append(fields, article.FieldShowOnHome)
	}
	if m.home_sort != nil {
		fields = append(fields, article.FieldHomeSort)
	}
	if m.pin_sort != nil {
		fields = append(fields, article.FieldPinSort)
	}
	if m.top_img_url != nil {
		fields = append(fields, article.FieldTopImgURL)
	}
	if m.summaries != nil {
		fields = append(fields, article.FieldSummaries)
	}
	if m.abbrlink != nil {
		fields = append(fields, article.FieldAbbrlink)
	}
	if m.copyright != nil {
		fields = append(fields, article.FieldCopyright)
	}
	if m.is_reprint != nil {
		fields = append(fields, article.FieldIsReprint)
	}
	if m.copyright_author != nil {
		fields = append(fields, article.FieldCopyrightAuthor)
	}
	if m.copyright_author_href != nil {
		fields = append(fields, article.FieldCopyrightAuthorHref)
	}
	if m.copyright_url != nil {
		fields = append(fields, article.FieldCopyrightURL)
	}
	if m.keywords != nil {
		fields = append(fields, article.FieldKeywords)
	}
	if m.scheduled_at != nil {
		fields = append(fields, article.FieldScheduledAt)
	}
	if m.review_status != nil {
		fields = append(fields, article.FieldReviewStatus)
	}
	if m.review_comment != nil {
		fields = append(fields, article.FieldReviewComment)
	}
	if m.reviewed_at != nil {
		fields = append(fields, article.FieldReviewedAt)
	}
	if m.reviewed_by != nil {
		fields = append(fields, article.FieldReviewedBy)
	}
	if m.is_takedown != nil {
		fields = append(fields, article.FieldIsTakedown)
	}
	if m.takedown_reason != nil {
		fields = append(fields, article.FieldTakedownReason)
	}
	if m.takedown_at != nil {
		fields = append(fields, article.FieldTakedownAt)
	}
	if m.takedown_by != nil {
		fields = append(fields, article.FieldTakedownBy)
	}
	if m.extra_config != nil {
		fields = append(fields, article.FieldExtraConfig)
	}
	if m.exclude_from_membership != nil {
		fields = append(fields, article.FieldExcludeFromMembership)
	}
	if m.is_doc != nil {
		fields = append(fields, article.FieldIsDoc)
	}
	if m.doc_series != nil {
		fields = append(fields, article.FieldDocSeriesID)
	}
	if m.doc_sort != nil {
		fields = append(fields, article.FieldDocSort)
	}
	if m.show_reward_button != nil {
		fields = append(fields, article.FieldShowRewardButton)
	}
	if m.show_share_button != nil {
		fields = append(fields, article.FieldShowShareButton)
	}
	if m.show_subscribe_button != nil {
		fields = append(fields, article.FieldShowSubscribeButton)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case article.FieldDeletedAt:
		return m.DeletedAt()
	case article.FieldOwnerID:
		return m.OwnerID()
	case article.FieldCreatedAt:
		return m.CreatedAt()
	case article.FieldUpdatedAt:
		return m.UpdatedAt()
	case article.FieldTitle:
		return m.Title()
	case article.FieldContentMd:
		return m.ContentMd()
	case article.FieldContentHTML:
		return m.ContentHTML()
	case article.FieldCoverURL:
		return m.CoverURL()
	case article.FieldStatus:
		return m.Status()
	case article.FieldViewCount:
		return m.ViewCount()
	case article.FieldWordCount:
		return m.WordCount()
	case article.FieldReadingTime:
		return m.ReadingTime()
	case article.FieldIPLocation:
		return m.IPLocation()
	case article.FieldPrimaryColor:
		return m.PrimaryColor()
	case article.FieldIsPrimaryColorManual:
		return m.IsPrimaryColorManual()
	case article.FieldShowOnHome:
		return m.ShowOnHome()
	case article.FieldHomeSort:
		return m.HomeSort()
	case article.FieldPinSort:
		return m.PinSort()
	case article.FieldTopImgURL:
		return m.TopImgURL()
	case article.FieldSummaries:
		return m.Summaries()
	case article.FieldAbbrlink:
		return m.Abbrlink()
	case article.FieldCopyright:
		return m.Copyright()
	case article.FieldIsReprint:
		return m.IsReprint()
	case article.FieldCopyrightAuthor:
		return m.CopyrightAuthor()
	case article.FieldCopyrightAuthorHref:
		return m.CopyrightAuthorHref()
	case article.FieldCopyrightURL:
		return m.CopyrightURL()
	case article.FieldKeywords:
		return m.Keywords()
	case article.FieldScheduledAt:
		return m.ScheduledAt()
	case article.FieldReviewStatus:
		return m.ReviewStatus()
	case article.FieldReviewComment:
		return m.ReviewComment()
	case article.FieldReviewedAt:
		return m.ReviewedAt()
	case article.FieldReviewedBy:
		return m.ReviewedBy()
	case article.FieldIsTakedown:
		return m.IsTakedown()
	case article.FieldTakedownReason:
		return m.TakedownReason()
	case article.FieldTakedownAt:
		return m.TakedownAt()
	case article.FieldTakedownBy:
		return m.TakedownBy()
	case article.FieldExtraConfig:
		return m.ExtraConfig()
	case article.FieldExcludeFromMembership:
		return m.ExcludeFromMembership()
	case article.FieldIsDoc:
		return m.IsDoc()
	case article.FieldDocSeriesID:
		return m.DocSeriesID()
	case article.FieldDocSort:
		return m.DocSort()
	case article.FieldShowRewardButton:
		return m.ShowRewardButton()
	case article.FieldShowShareButton:
		return m.ShowShareButton()
	case article.FieldShowSubscribeButton:
		return m.ShowSubscribeButton()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case article.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case article.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case article.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case article.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case article.FieldTitle:
		return m.OldTitle(ctx)
	case article.FieldContentMd:
		return m.OldContentMd(ctx)
	case article.FieldContentHTML:
		return m.OldContentHTML(ctx)
	case article.FieldCoverURL:
		return m.OldCoverURL(ctx)
	case article.FieldStatus:
		return m.OldStatus(ctx)
	case article.FieldViewCount:
		return m.OldViewCount(ctx)
	case article.FieldWordCount:
		return m.OldWordCount(ctx)
	case article.FieldReadingTime:
		return m.OldReadingTime(ctx)
	case article.FieldIPLocation:
		return m.OldIPLocation(ctx)
	case article.FieldPrimaryColor:
		return m.OldPrimaryColor(ctx)
	case article.FieldIsPrimaryColorManual:
		return m.OldIsPrimaryColorManual(ctx)
	case article.FieldShowOnHome:
		return m.OldShowOnHome(ctx)
	case article.FieldHomeSort:
		return m.OldHomeSort(ctx)
	case article.FieldPinSort:
		return m.OldPinSort(ctx)
	case article.FieldTopImgURL:
		return m.OldTopImgURL(ctx)
	case article.FieldSummaries:
		return m.OldSummaries(ctx)
	case article.FieldAbbrlink:
		return m.OldAbbrlink(ctx)
	case article.FieldCopyright:
		return m.OldCopyright(ctx)
	case article.FieldIsReprint:
		return m.OldIsReprint(ctx)
	case article.FieldCopyrightAuthor:
		return m.OldCopyrightAuthor(ctx)
	case article.FieldCopyrightAuthorHref:
		return m.OldCopyrightAuthorHref(ctx)
	case article.FieldCopyrightURL:
		return m.OldCopyrightURL(ctx)
	case article.FieldKeywords:
		return m.OldKeywords(ctx)
	case article.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case article.FieldReviewStatus:
		return m.OldReviewStatus(ctx)
	case article.FieldReviewComment:
		return m.OldReviewComment(ctx)
	case article.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	case article.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case article.FieldIsTakedown:
		return m.OldIsTakedown(ctx)
	case article.FieldTakedownReason:
		return m.OldTakedownReason(ctx)
	case article.FieldTakedownAt:
		return m.OldTakedownAt(ctx)
	case article.FieldTakedownBy:
		return m.OldTakedownBy(ctx)
	case article.FieldExtraConfig:
		return m.OldExtraConfig(ctx)
	case article.FieldExcludeFromMembership:
		return m.OldExcludeFromMembership(ctx)
	case article.FieldIsDoc:
		return m.OldIsDoc(ctx)
	case article.FieldDocSeriesID:
		return m.OldDocSeriesID(ctx)
	case article.FieldDocSort:
		return m.OldDocSort(ctx)
	case article.FieldShowRewardButton:
		return m.OldShowRewardButton(ctx)
	case article.FieldShowShareButton:
		return m.OldShowShareButton(ctx)
	case article.FieldShowSubscribeButton:
		return m.OldShowSubscribeButton(ctx)
	}
	return nil, fmt.Errorf("unknown Article field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case article.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case article.FieldOwnerID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case article.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case article.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case article.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case article.FieldContentMd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentMd(v)
		return nil
	case article.FieldContentHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHTML(v)
		return nil
	case article.FieldCoverURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverURL(v)
		return nil
	case article.FieldStatus:
		v, ok := value.(article.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case article.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case article.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordCount(v)
		return nil
	case article.FieldReadingTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingTime(v)
		return nil
	case article.FieldIPLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPLocation(v)
		return nil
	case article.FieldPrimaryColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryColor(v)
		return nil
	case article.FieldIsPrimaryColorManual:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimaryColorManual(v)
		return nil
	case article.FieldShowOnHome:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowOnHome(v)
		return nil
	case article.FieldHomeSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeSort(v)
		return nil
	case article.FieldPinSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinSort(v)
		return nil
	case article.FieldTopImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopImgURL(v)
		return nil
	case article.FieldSummaries:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummaries(v)
		return nil
	case article.FieldAbbrlink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbrlink(v)
		return nil
	case article.FieldCopyright:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case article.FieldIsReprint:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReprint(v)
		return nil
	case article.FieldCopyrightAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightAuthor(v)
		return nil
	case article.FieldCopyrightAuthorHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightAuthorHref(v)
		return nil
	case article.FieldCopyrightURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightURL(v)
		return nil
	case article.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case article.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case article.FieldReviewStatus:
		v, ok := value.(article.ReviewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewStatus(v)
		return nil
	case article.FieldReviewComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewComment(v)
		return nil
	case article.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	case article.FieldReviewedBy:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case article.FieldIsTakedown:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTakedown(v)
		return nil
	case article.FieldTakedownReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakedownReason(v)
		return nil
	case article.FieldTakedownAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakedownAt(v)
		return nil
	case article.FieldTakedownBy:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakedownBy(v)
		return nil
	case article.FieldExtraConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraConfig(v)
		return nil
	case article.FieldExcludeFromMembership:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludeFromMembership(v)
		return nil
	case article.FieldIsDoc:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDoc(v)
		return nil
	case article.FieldDocSeriesID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocSeriesID(v)
		return nil
	case article.FieldDocSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocSort(v)
		return nil
	case article.FieldShowRewardButton:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowRewardButton(v)
		return nil
	case article.FieldShowShareButton:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowShareButton(v)
		return nil
	case article.FieldShowSubscribeButton:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowSubscribeButton(v)
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleMutation) AddedFields() []string {
	var fields []string
	if m.addowner_id != nil {
		fields = append(fields, article.FieldOwnerID)
	}
	if m.addview_count != nil {
		fields = append(fields, article.FieldViewCount)
	}
	if m.addword_count != nil {
		fields = append(fields, article.FieldWordCount)
	}
	if m.addreading_time != nil {
		fields = append(fields, article.FieldReadingTime)
	}
	if m.addhome_sort != nil {
		fields = append(fields, article.FieldHomeSort)
	}
	if m.addpin_sort != nil {
		fields = append(fields, article.FieldPinSort)
	}
	if m.addreviewed_by != nil {
		fields = append(fields, article.FieldReviewedBy)
	}
	if m.addtakedown_by != nil {
		fields = append(fields, article.FieldTakedownBy)
	}
	if m.adddoc_sort != nil {
		fields = append(fields, article.FieldDocSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case article.FieldOwnerID:
		return m.AddedOwnerID()
	case article.FieldViewCount:
		return m.AddedViewCount()
	case article.FieldWordCount:
		return m.AddedWordCount()
	case article.FieldReadingTime:
		return m.AddedReadingTime()
	case article.FieldHomeSort:
		return m.AddedHomeSort()
	case article.FieldPinSort:
		return m.AddedPinSort()
	case article.FieldReviewedBy:
		return m.AddedReviewedBy()
	case article.FieldTakedownBy:
		return m.AddedTakedownBy()
	case article.FieldDocSort:
		return m.AddedDocSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case article.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case article.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case article.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordCount(v)
		return nil
	case article.FieldReadingTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingTime(v)
		return nil
	case article.FieldHomeSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeSort(v)
		return nil
	case article.FieldPinSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPinSort(v)
		return nil
	case article.FieldReviewedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewedBy(v)
		return nil
	case article.FieldTakedownBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTakedownBy(v)
		return nil
	case article.FieldDocSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDocSort(v)
		return nil
	}
	return fmt.Errorf("unknown Article numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(article.FieldDeletedAt) {
		fields = append(fields, article.FieldDeletedAt)
	}
	if m.FieldCleared(article.FieldContentMd) {
		fields = append(fields, article.FieldContentMd)
	}
	if m.FieldCleared(article.FieldContentHTML) {
		fields = append(fields, article.FieldContentHTML)
	}
	if m.FieldCleared(article.FieldCoverURL) {
		fields = append(fields, article.FieldCoverURL)
	}
	if m.FieldCleared(article.FieldIPLocation) {
		fields = append(fields, article.FieldIPLocation)
	}
	if m.FieldCleared(article.FieldPrimaryColor) {
		fields = append(fields, article.FieldPrimaryColor)
	}
	if m.FieldCleared(article.FieldTopImgURL) {
		fields = append(fields, article.FieldTopImgURL)
	}
	if m.FieldCleared(article.FieldSummaries) {
		fields = append(fields, article.FieldSummaries)
	}
	if m.FieldCleared(article.FieldAbbrlink) {
		fields = append(fields, article.FieldAbbrlink)
	}
	if m.FieldCleared(article.FieldCopyrightAuthor) {
		fields = append(fields, article.FieldCopyrightAuthor)
	}
	if m.FieldCleared(article.FieldCopyrightAuthorHref) {
		fields = append(fields, article.FieldCopyrightAuthorHref)
	}
	if m.FieldCleared(article.FieldCopyrightURL) {
		fields = append(fields, article.FieldCopyrightURL)
	}
	if m.FieldCleared(article.FieldKeywords) {
		fields = append(fields, article.FieldKeywords)
	}
	if m.FieldCleared(article.FieldScheduledAt) {
		fields = append(fields, article.FieldScheduledAt)
	}
	if m.FieldCleared(article.FieldReviewComment) {
		fields = append(fields, article.FieldReviewComment)
	}
	if m.FieldCleared(article.FieldReviewedAt) {
		fields = append(fields, article.FieldReviewedAt)
	}
	if m.FieldCleared(article.FieldReviewedBy) {
		fields = append(fields, article.FieldReviewedBy)
	}
	if m.FieldCleared(article.FieldTakedownReason) {
		fields = append(fields, article.FieldTakedownReason)
	}
	if m.FieldCleared(article.FieldTakedownAt) {
		fields = append(fields, article.FieldTakedownAt)
	}
	if m.FieldCleared(article.FieldTakedownBy) {
		fields = append(fields, article.FieldTakedownBy)
	}
	if m.FieldCleared(article.FieldExtraConfig) {
		fields = append(fields, article.FieldExtraConfig)
	}
	if m.FieldCleared(article.FieldDocSeriesID) {
		fields = append(fields, article.FieldDocSeriesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleMutation) ClearField(name string) error {
	switch name {
	case article.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case article.FieldContentMd:
		m.ClearContentMd()
		return nil
	case article.FieldContentHTML:
		m.ClearContentHTML()
		return nil
	case article.FieldCoverURL:
		m.ClearCoverURL()
		return nil
	case article.FieldIPLocation:
		m.ClearIPLocation()
		return nil
	case article.FieldPrimaryColor:
		m.ClearPrimaryColor()
		return nil
	case article.FieldTopImgURL:
		m.ClearTopImgURL()
		return nil
	case article.FieldSummaries:
		m.ClearSummaries()
		return nil
	case article.FieldAbbrlink:
		m.ClearAbbrlink()
		return nil
	case article.FieldCopyrightAuthor:
		m.ClearCopyrightAuthor()
		return nil
	case article.FieldCopyrightAuthorHref:
		m.ClearCopyrightAuthorHref()
		return nil
	case article.FieldCopyrightURL:
		m.ClearCopyrightURL()
		return nil
	case article.FieldKeywords:
		m.ClearKeywords()
		return nil
	case article.FieldScheduledAt:
		m.ClearScheduledAt()
		return nil
	case article.FieldReviewComment:
		m.ClearReviewComment()
		return nil
	case article.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	case article.FieldReviewedBy:
		m.ClearReviewedBy()
		return nil
	case article.FieldTakedownReason:
		m.ClearTakedownReason()
		return nil
	case article.FieldTakedownAt:
		m.ClearTakedownAt()
		return nil
	case article.FieldTakedownBy:
		m.ClearTakedownBy()
		return nil
	case article.FieldExtraConfig:
		m.ClearExtraConfig()
		return nil
	case article.FieldDocSeriesID:
		m.ClearDocSeriesID()
		return nil
	}
	return fmt.Errorf("unknown Article nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleMutation) ResetField(name string) error {
	switch name {
	case article.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case article.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case article.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case article.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case article.FieldTitle:
		m.ResetTitle()
		return nil
	case article.FieldContentMd:
		m.ResetContentMd()
		return nil
	case article.FieldContentHTML:
		m.ResetContentHTML()
		return nil
	case article.FieldCoverURL:
		m.ResetCoverURL()
		return nil
	case article.FieldStatus:
		m.ResetStatus()
		return nil
	case article.FieldViewCount:
		m.ResetViewCount()
		return nil
	case article.FieldWordCount:
		m.ResetWordCount()
		return nil
	case article.FieldReadingTime:
		m.ResetReadingTime()
		return nil
	case article.FieldIPLocation:
		m.ResetIPLocation()
		return nil
	case article.FieldPrimaryColor:
		m.ResetPrimaryColor()
		return nil
	case article.FieldIsPrimaryColorManual:
		m.ResetIsPrimaryColorManual()
		return nil
	case article.FieldShowOnHome:
		m.ResetShowOnHome()
		return nil
	case article.FieldHomeSort:
		m.ResetHomeSort()
		return nil
	case article.FieldPinSort:
		m.ResetPinSort()
		return nil
	case article.FieldTopImgURL:
		m.ResetTopImgURL()
		return nil
	case article.FieldSummaries:
		m.ResetSummaries()
		return nil
	case article.FieldAbbrlink:
		m.ResetAbbrlink()
		return nil
	case article.FieldCopyright:
		m.ResetCopyright()
		return nil
	case article.FieldIsReprint:
		m.ResetIsReprint()
		return nil
	case article.FieldCopyrightAuthor:
		m.ResetCopyrightAuthor()
		return nil
	case article.FieldCopyrightAuthorHref:
		m.ResetCopyrightAuthorHref()
		return nil
	case article.FieldCopyrightURL:
		m.ResetCopyrightURL()
		return nil
	case article.FieldKeywords:
		m.ResetKeywords()
		return nil
	case article.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case article.FieldReviewStatus:
		m.ResetReviewStatus()
		return nil
	case article.FieldReviewComment:
		m.ResetReviewComment()
		return nil
	case article.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	case article.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case article.FieldIsTakedown:
		m.ResetIsTakedown()
		return nil
	case article.FieldTakedownReason:
		m.ResetTakedownReason()
		return nil
	case article.FieldTakedownAt:
		m.ResetTakedownAt()
		return nil
	case article.FieldTakedownBy:
		m.ResetTakedownBy()
		return nil
	case article.FieldExtraConfig:
		m.ResetExtraConfig()
		return nil
	case article.FieldExcludeFromMembership:
		m.ResetExcludeFromMembership()
		return nil
	case article.FieldIsDoc:
		m.ResetIsDoc()
		return nil
	case article.FieldDocSeriesID:
		m.ResetDocSeriesID()
		return nil
	case article.FieldDocSort:
		m.ResetDocSort()
		return nil
	case article.FieldShowRewardButton:
		m.ResetShowRewardButton()
		return nil
	case article.FieldShowShareButton:
		m.ResetShowShareButton()
		return nil
	case article.FieldShowSubscribeButton:
		m.ResetShowSubscribeButton()
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.post_tags != nil {
		edges = append(edges, article.EdgePostTags)
	}
	if m.post_categories != nil {
		edges = append(edges, article.EdgePostCategories)
	}
	if m.comments != nil {
		edges = append(edges, article.EdgeComments)
	}
	if m.histories != nil {
		edges = append(edges, article.EdgeHistories)
	}
	if m.doc_series != nil {
		edges = append(edges, article.EdgeDocSeries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case article.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.post_tags))
		for id := range m.post_tags {
			ids = append(ids, id)
		}
		return ids
	case article.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.post_categories))
		for id := range m.post_categories {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeHistories:
		ids := make([]ent.Value, 0, len(m.histories))
		for id := range m.histories {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeDocSeries:
		if id := m.doc_series; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpost_tags != nil {
		edges = append(edges, article.EdgePostTags)
	}
	if m.removedpost_categories != nil {
		edges = append(edges, article.EdgePostCategories)
	}
	if m.removedcomments != nil {
		edges = append(edges, article.EdgeComments)
	}
	if m.removedhistories != nil {
		edges = append(edges, article.EdgeHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case article.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.removedpost_tags))
		for id := range m.removedpost_tags {
			ids = append(ids, id)
		}
		return ids
	case article.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.removedpost_categories))
		for id := range m.removedpost_categories {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeHistories:
		ids := make([]ent.Value, 0, len(m.removedhistories))
		for id := range m.removedhistories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpost_tags {
		edges = append(edges, article.EdgePostTags)
	}
	if m.clearedpost_categories {
		edges = append(edges, article.EdgePostCategories)
	}
	if m.clearedcomments {
		edges = append(edges, article.EdgeComments)
	}
	if m.clearedhistories {
		edges = append(edges, article.EdgeHistories)
	}
	if m.cleareddoc_series {
		edges = append(edges, article.EdgeDocSeries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleMutation) EdgeCleared(name string) bool {
	switch name {
	case article.EdgePostTags:
		return m.clearedpost_tags
	case article.EdgePostCategories:
		return m.clearedpost_categories
	case article.EdgeComments:
		return m.clearedcomments
	case article.EdgeHistories:
		return m.clearedhistories
	case article.EdgeDocSeries:
		return m.cleareddoc_series
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleMutation) ClearEdge(name string) error {
	switch name {
	case article.EdgeDocSeries:
		m.ClearDocSeries()
		return nil
	}
	return fmt.Errorf("unknown Article unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleMutation) ResetEdge(name string) error {
	switch name {
	case article.EdgePostTags:
		m.ResetPostTags()
		return nil
	case article.EdgePostCategories:
		m.ResetPostCategories()
		return nil
	case article.EdgeComments:
		m.ResetComments()
		return nil
	case article.EdgeHistories:
		m.ResetHistories()
		return nil
	case article.EdgeDocSeries:
		m.ResetDocSeries()
		return nil
	}
	return fmt.Errorf("unknown Article edge %s", name)
}

// ArticleHistoryMutation represents an operation that mutates the ArticleHistory nodes in the graph.
type ArticleHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	version         *int
	addversion      *int
	title           *string
	content_md      *string
	content_html    *string
	cover_url       *string
	top_img_url     *string
	primary_color   *string
	summaries       *[]string
	appendsummaries []string
	word_count      *int
	addword_count   *int
	keywords        *string
	editor_id       *uint
	addeditor_id    *int
	editor_nickname *string
	change_note     *string
	created_at      *time.Time
	extra_data      *map[string]interface{}
	clearedFields   map[string]struct{}
	article         *uint
	clearedarticle  bool
	done            bool
	oldValue        func(context.Context) (*ArticleHistory, error)
	predicates      []predicate.ArticleHistory
}

var _ ent.Mutation = (*ArticleHistoryMutation)(nil)

// articlehistoryOption allows management of the mutation configuration using functional options.
type articlehistoryOption func(*ArticleHistoryMutation)

// newArticleHistoryMutation creates new mutation for the ArticleHistory entity.
func newArticleHistoryMutation(c config, op Op, opts ...articlehistoryOption) *ArticleHistoryMutation {
	m := &ArticleHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeArticleHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleHistoryID sets the ID field of the mutation.
func withArticleHistoryID(id uint) articlehistoryOption {
	return func(m *ArticleHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticleHistory
		)
		m.oldValue = func(ctx context.Context) (*ArticleHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticleHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticleHistory sets the old ArticleHistory of the mutation.
func withArticleHistory(node *ArticleHistory) articlehistoryOption {
	return func(m *ArticleHistoryMutation) {
		m.oldValue = func(context.Context) (*ArticleHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArticleHistory entities.
func (m *ArticleHistoryMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleHistoryMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleHistoryMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticleHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArticleID sets the "article_id" field.
func (m *ArticleHistoryMutation) SetArticleID(u uint) {
	m.article = &u
}

// ArticleID returns the value of the "article_id" field in the mutation.
func (m *ArticleHistoryMutation) ArticleID() (r uint, exists bool) {
	v := m.article
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleID returns the old "article_id" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldArticleID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleID: %w", err)
	}
	return oldValue.ArticleID, nil
}

// ResetArticleID resets all changes to the "article_id" field.
func (m *ArticleHistoryMutation) ResetArticleID() {
	m.article = nil
}

// SetVersion sets the "version" field.
func (m *ArticleHistoryMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ArticleHistoryMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ArticleHistoryMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ArticleHistoryMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ArticleHistoryMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetTitle sets the "title" field.
func (m *ArticleHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ArticleHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ArticleHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetContentMd sets the "content_md" field.
func (m *ArticleHistoryMutation) SetContentMd(s string) {
	m.content_md = &s
}

// ContentMd returns the value of the "content_md" field in the mutation.
func (m *ArticleHistoryMutation) ContentMd() (r string, exists bool) {
	v := m.content_md
	if v == nil {
		return
	}
	return *v, true
}

// OldContentMd returns the old "content_md" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldContentMd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentMd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentMd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentMd: %w", err)
	}
	return oldValue.ContentMd, nil
}

// ClearContentMd clears the value of the "content_md" field.
func (m *ArticleHistoryMutation) ClearContentMd() {
	m.content_md = nil
	m.clearedFields[articlehistory.FieldContentMd] = struct{}{}
}

// ContentMdCleared returns if the "content_md" field was cleared in this mutation.
func (m *ArticleHistoryMutation) ContentMdCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldContentMd]
	return ok
}

// ResetContentMd resets all changes to the "content_md" field.
func (m *ArticleHistoryMutation) ResetContentMd() {
	m.content_md = nil
	delete(m.clearedFields, articlehistory.FieldContentMd)
}

// SetContentHTML sets the "content_html" field.
func (m *ArticleHistoryMutation) SetContentHTML(s string) {
	m.content_html = &s
}

// ContentHTML returns the value of the "content_html" field in the mutation.
func (m *ArticleHistoryMutation) ContentHTML() (r string, exists bool) {
	v := m.content_html
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHTML returns the old "content_html" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldContentHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHTML: %w", err)
	}
	return oldValue.ContentHTML, nil
}

// ClearContentHTML clears the value of the "content_html" field.
func (m *ArticleHistoryMutation) ClearContentHTML() {
	m.content_html = nil
	m.clearedFields[articlehistory.FieldContentHTML] = struct{}{}
}

// ContentHTMLCleared returns if the "content_html" field was cleared in this mutation.
func (m *ArticleHistoryMutation) ContentHTMLCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldContentHTML]
	return ok
}

// ResetContentHTML resets all changes to the "content_html" field.
func (m *ArticleHistoryMutation) ResetContentHTML() {
	m.content_html = nil
	delete(m.clearedFields, articlehistory.FieldContentHTML)
}

// SetCoverURL sets the "cover_url" field.
func (m *ArticleHistoryMutation) SetCoverURL(s string) {
	m.cover_url = &s
}

// CoverURL returns the value of the "cover_url" field in the mutation.
func (m *ArticleHistoryMutation) CoverURL() (r string, exists bool) {
	v := m.cover_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverURL returns the old "cover_url" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldCoverURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverURL: %w", err)
	}
	return oldValue.CoverURL, nil
}

// ClearCoverURL clears the value of the "cover_url" field.
func (m *ArticleHistoryMutation) ClearCoverURL() {
	m.cover_url = nil
	m.clearedFields[articlehistory.FieldCoverURL] = struct{}{}
}

// CoverURLCleared returns if the "cover_url" field was cleared in this mutation.
func (m *ArticleHistoryMutation) CoverURLCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldCoverURL]
	return ok
}

// ResetCoverURL resets all changes to the "cover_url" field.
func (m *ArticleHistoryMutation) ResetCoverURL() {
	m.cover_url = nil
	delete(m.clearedFields, articlehistory.FieldCoverURL)
}

// SetTopImgURL sets the "top_img_url" field.
func (m *ArticleHistoryMutation) SetTopImgURL(s string) {
	m.top_img_url = &s
}

// TopImgURL returns the value of the "top_img_url" field in the mutation.
func (m *ArticleHistoryMutation) TopImgURL() (r string, exists bool) {
	v := m.top_img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTopImgURL returns the old "top_img_url" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldTopImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopImgURL: %w", err)
	}
	return oldValue.TopImgURL, nil
}

// ClearTopImgURL clears the value of the "top_img_url" field.
func (m *ArticleHistoryMutation) ClearTopImgURL() {
	m.top_img_url = nil
	m.clearedFields[articlehistory.FieldTopImgURL] = struct{}{}
}

// TopImgURLCleared returns if the "top_img_url" field was cleared in this mutation.
func (m *ArticleHistoryMutation) TopImgURLCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldTopImgURL]
	return ok
}

// ResetTopImgURL resets all changes to the "top_img_url" field.
func (m *ArticleHistoryMutation) ResetTopImgURL() {
	m.top_img_url = nil
	delete(m.clearedFields, articlehistory.FieldTopImgURL)
}

// SetPrimaryColor sets the "primary_color" field.
func (m *ArticleHistoryMutation) SetPrimaryColor(s string) {
	m.primary_color = &s
}

// PrimaryColor returns the value of the "primary_color" field in the mutation.
func (m *ArticleHistoryMutation) PrimaryColor() (r string, exists bool) {
	v := m.primary_color
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryColor returns the old "primary_color" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldPrimaryColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryColor: %w", err)
	}
	return oldValue.PrimaryColor, nil
}

// ClearPrimaryColor clears the value of the "primary_color" field.
func (m *ArticleHistoryMutation) ClearPrimaryColor() {
	m.primary_color = nil
	m.clearedFields[articlehistory.FieldPrimaryColor] = struct{}{}
}

// PrimaryColorCleared returns if the "primary_color" field was cleared in this mutation.
func (m *ArticleHistoryMutation) PrimaryColorCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldPrimaryColor]
	return ok
}

// ResetPrimaryColor resets all changes to the "primary_color" field.
func (m *ArticleHistoryMutation) ResetPrimaryColor() {
	m.primary_color = nil
	delete(m.clearedFields, articlehistory.FieldPrimaryColor)
}

// SetSummaries sets the "summaries" field.
func (m *ArticleHistoryMutation) SetSummaries(s []string) {
	m.summaries = &s
	m.appendsummaries = nil
}

// Summaries returns the value of the "summaries" field in the mutation.
func (m *ArticleHistoryMutation) Summaries() (r []string, exists bool) {
	v := m.summaries
	if v == nil {
		return
	}
	return *v, true
}

// OldSummaries returns the old "summaries" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldSummaries(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummaries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummaries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummaries: %w", err)
	}
	return oldValue.Summaries, nil
}

// AppendSummaries adds s to the "summaries" field.
func (m *ArticleHistoryMutation) AppendSummaries(s []string) {
	m.appendsummaries = append(m.appendsummaries, s...)
}

// AppendedSummaries returns the list of values that were appended to the "summaries" field in this mutation.
func (m *ArticleHistoryMutation) AppendedSummaries() ([]string, bool) {
	if len(m.appendsummaries) == 0 {
		return nil, false
	}
	return m.appendsummaries, true
}

// ClearSummaries clears the value of the "summaries" field.
func (m *ArticleHistoryMutation) ClearSummaries() {
	m.summaries = nil
	m.appendsummaries = nil
	m.clearedFields[articlehistory.FieldSummaries] = struct{}{}
}

// SummariesCleared returns if the "summaries" field was cleared in this mutation.
func (m *ArticleHistoryMutation) SummariesCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldSummaries]
	return ok
}

// ResetSummaries resets all changes to the "summaries" field.
func (m *ArticleHistoryMutation) ResetSummaries() {
	m.summaries = nil
	m.appendsummaries = nil
	delete(m.clearedFields, articlehistory.FieldSummaries)
}

// SetWordCount sets the "word_count" field.
func (m *ArticleHistoryMutation) SetWordCount(i int) {
	m.word_count = &i
	m.addword_count = nil
}

// WordCount returns the value of the "word_count" field in the mutation.
func (m *ArticleHistoryMutation) WordCount() (r int, exists bool) {
	v := m.word_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWordCount returns the old "word_count" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldWordCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordCount: %w", err)
	}
	return oldValue.WordCount, nil
}

// AddWordCount adds i to the "word_count" field.
func (m *ArticleHistoryMutation) AddWordCount(i int) {
	if m.addword_count != nil {
		*m.addword_count += i
	} else {
		m.addword_count = &i
	}
}

// AddedWordCount returns the value that was added to the "word_count" field in this mutation.
func (m *ArticleHistoryMutation) AddedWordCount() (r int, exists bool) {
	v := m.addword_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWordCount resets all changes to the "word_count" field.
func (m *ArticleHistoryMutation) ResetWordCount() {
	m.word_count = nil
	m.addword_count = nil
}

// SetKeywords sets the "keywords" field.
func (m *ArticleHistoryMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *ArticleHistoryMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *ArticleHistoryMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[articlehistory.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *ArticleHistoryMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *ArticleHistoryMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, articlehistory.FieldKeywords)
}

// SetEditorID sets the "editor_id" field.
func (m *ArticleHistoryMutation) SetEditorID(u uint) {
	m.editor_id = &u
	m.addeditor_id = nil
}

// EditorID returns the value of the "editor_id" field in the mutation.
func (m *ArticleHistoryMutation) EditorID() (r uint, exists bool) {
	v := m.editor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEditorID returns the old "editor_id" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldEditorID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditorID: %w", err)
	}
	return oldValue.EditorID, nil
}

// AddEditorID adds u to the "editor_id" field.
func (m *ArticleHistoryMutation) AddEditorID(u int) {
	if m.addeditor_id != nil {
		*m.addeditor_id += u
	} else {
		m.addeditor_id = &u
	}
}

// AddedEditorID returns the value that was added to the "editor_id" field in this mutation.
func (m *ArticleHistoryMutation) AddedEditorID() (r int, exists bool) {
	v := m.addeditor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEditorID resets all changes to the "editor_id" field.
func (m *ArticleHistoryMutation) ResetEditorID() {
	m.editor_id = nil
	m.addeditor_id = nil
}

// SetEditorNickname sets the "editor_nickname" field.
func (m *ArticleHistoryMutation) SetEditorNickname(s string) {
	m.editor_nickname = &s
}

// EditorNickname returns the value of the "editor_nickname" field in the mutation.
func (m *ArticleHistoryMutation) EditorNickname() (r string, exists bool) {
	v := m.editor_nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldEditorNickname returns the old "editor_nickname" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldEditorNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditorNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditorNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditorNickname: %w", err)
	}
	return oldValue.EditorNickname, nil
}

// ClearEditorNickname clears the value of the "editor_nickname" field.
func (m *ArticleHistoryMutation) ClearEditorNickname() {
	m.editor_nickname = nil
	m.clearedFields[articlehistory.FieldEditorNickname] = struct{}{}
}

// EditorNicknameCleared returns if the "editor_nickname" field was cleared in this mutation.
func (m *ArticleHistoryMutation) EditorNicknameCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldEditorNickname]
	return ok
}

// ResetEditorNickname resets all changes to the "editor_nickname" field.
func (m *ArticleHistoryMutation) ResetEditorNickname() {
	m.editor_nickname = nil
	delete(m.clearedFields, articlehistory.FieldEditorNickname)
}

// SetChangeNote sets the "change_note" field.
func (m *ArticleHistoryMutation) SetChangeNote(s string) {
	m.change_note = &s
}

// ChangeNote returns the value of the "change_note" field in the mutation.
func (m *ArticleHistoryMutation) ChangeNote() (r string, exists bool) {
	v := m.change_note
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeNote returns the old "change_note" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldChangeNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeNote: %w", err)
	}
	return oldValue.ChangeNote, nil
}

// ClearChangeNote clears the value of the "change_note" field.
func (m *ArticleHistoryMutation) ClearChangeNote() {
	m.change_note = nil
	m.clearedFields[articlehistory.FieldChangeNote] = struct{}{}
}

// ChangeNoteCleared returns if the "change_note" field was cleared in this mutation.
func (m *ArticleHistoryMutation) ChangeNoteCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldChangeNote]
	return ok
}

// ResetChangeNote resets all changes to the "change_note" field.
func (m *ArticleHistoryMutation) ResetChangeNote() {
	m.change_note = nil
	delete(m.clearedFields, articlehistory.FieldChangeNote)
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExtraData sets the "extra_data" field.
func (m *ArticleHistoryMutation) SetExtraData(value map[string]interface{}) {
	m.extra_data = &value
}

// ExtraData returns the value of the "extra_data" field in the mutation.
func (m *ArticleHistoryMutation) ExtraData() (r map[string]interface{}, exists bool) {
	v := m.extra_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extra_data" field's value of the ArticleHistory entity.
// If the ArticleHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleHistoryMutation) OldExtraData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// ClearExtraData clears the value of the "extra_data" field.
func (m *ArticleHistoryMutation) ClearExtraData() {
	m.extra_data = nil
	m.clearedFields[articlehistory.FieldExtraData] = struct{}{}
}

// ExtraDataCleared returns if the "extra_data" field was cleared in this mutation.
func (m *ArticleHistoryMutation) ExtraDataCleared() bool {
	_, ok := m.clearedFields[articlehistory.FieldExtraData]
	return ok
}

// ResetExtraData resets all changes to the "extra_data" field.
func (m *ArticleHistoryMutation) ResetExtraData() {
	m.extra_data = nil
	delete(m.clearedFields, articlehistory.FieldExtraData)
}

// ClearArticle clears the "article" edge to the Article entity.
func (m *ArticleHistoryMutation) ClearArticle() {
	m.clearedarticle = true
	m.clearedFields[articlehistory.FieldArticleID] = struct{}{}
}

// ArticleCleared reports if the "article" edge to the Article entity was cleared.
func (m *ArticleHistoryMutation) ArticleCleared() bool {
	return m.clearedarticle
}

// ArticleIDs returns the "article" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArticleID instead. It exists only for internal usage by the builders.
func (m *ArticleHistoryMutation) ArticleIDs() (ids []uint) {
	if id := m.article; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArticle resets all changes to the "article" edge.
func (m *ArticleHistoryMutation) ResetArticle() {
	m.article = nil
	m.clearedarticle = false
}

// Where appends a list predicates to the ArticleHistoryMutation builder.
func (m *ArticleHistoryMutation) Where(ps ...predicate.ArticleHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticleHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticleHistory).
func (m *ArticleHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleHistoryMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.article != nil {
		fields = append(fields, articlehistory.FieldArticleID)
	}
	if m.version != nil {
		fields = append(fields, articlehistory.FieldVersion)
	}
	if m.title != nil {
		fields = append(fields, articlehistory.FieldTitle)
	}
	if m.content_md != nil {
		fields = append(fields, articlehistory.FieldContentMd)
	}
	if m.content_html != nil {
		fields = append(fields, articlehistory.FieldContentHTML)
	}
	if m.cover_url != nil {
		fields = append(fields, articlehistory.FieldCoverURL)
	}
	if m.top_img_url != nil {
		fields = append(fields, articlehistory.FieldTopImgURL)
	}
	if m.primary_color != nil {
		fields = append(fields, articlehistory.FieldPrimaryColor)
	}
	if m.summaries != nil {
		fields = append(fields, articlehistory.FieldSummaries)
	}
	if m.word_count != nil {
		fields = append(fields, articlehistory.FieldWordCount)
	}
	if m.keywords != nil {
		fields = append(fields, articlehistory.FieldKeywords)
	}
	if m.editor_id != nil {
		fields = append(fields, articlehistory.FieldEditorID)
	}
	if m.editor_nickname != nil {
		fields = append(fields, articlehistory.FieldEditorNickname)
	}
	if m.change_note != nil {
		fields = append(fields, articlehistory.FieldChangeNote)
	}
	if m.created_at != nil {
		fields = append(fields, articlehistory.FieldCreatedAt)
	}
	if m.extra_data != nil {
		fields = append(fields, articlehistory.FieldExtraData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlehistory.FieldArticleID:
		return m.ArticleID()
	case articlehistory.FieldVersion:
		return m.Version()
	case articlehistory.FieldTitle:
		return m.Title()
	case articlehistory.FieldContentMd:
		return m.ContentMd()
	case articlehistory.FieldContentHTML:
		return m.ContentHTML()
	case articlehistory.FieldCoverURL:
		return m.CoverURL()
	case articlehistory.FieldTopImgURL:
		return m.TopImgURL()
	case articlehistory.FieldPrimaryColor:
		return m.PrimaryColor()
	case articlehistory.FieldSummaries:
		return m.Summaries()
	case articlehistory.FieldWordCount:
		return m.WordCount()
	case articlehistory.FieldKeywords:
		return m.Keywords()
	case articlehistory.FieldEditorID:
		return m.EditorID()
	case articlehistory.FieldEditorNickname:
		return m.EditorNickname()
	case articlehistory.FieldChangeNote:
		return m.ChangeNote()
	case articlehistory.FieldCreatedAt:
		return m.CreatedAt()
	case articlehistory.FieldExtraData:
		return m.ExtraData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlehistory.FieldArticleID:
		return m.OldArticleID(ctx)
	case articlehistory.FieldVersion:
		return m.OldVersion(ctx)
	case articlehistory.FieldTitle:
		return m.OldTitle(ctx)
	case articlehistory.FieldContentMd:
		return m.OldContentMd(ctx)
	case articlehistory.FieldContentHTML:
		return m.OldContentHTML(ctx)
	case articlehistory.FieldCoverURL:
		return m.OldCoverURL(ctx)
	case articlehistory.FieldTopImgURL:
		return m.OldTopImgURL(ctx)
	case articlehistory.FieldPrimaryColor:
		return m.OldPrimaryColor(ctx)
	case articlehistory.FieldSummaries:
		return m.OldSummaries(ctx)
	case articlehistory.FieldWordCount:
		return m.OldWordCount(ctx)
	case articlehistory.FieldKeywords:
		return m.OldKeywords(ctx)
	case articlehistory.FieldEditorID:
		return m.OldEditorID(ctx)
	case articlehistory.FieldEditorNickname:
		return m.OldEditorNickname(ctx)
	case articlehistory.FieldChangeNote:
		return m.OldChangeNote(ctx)
	case articlehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlehistory.FieldExtraData:
		return m.OldExtraData(ctx)
	}
	return nil, fmt.Errorf("unknown ArticleHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlehistory.FieldArticleID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleID(v)
		return nil
	case articlehistory.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case articlehistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case articlehistory.FieldContentMd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentMd(v)
		return nil
	case articlehistory.FieldContentHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHTML(v)
		return nil
	case articlehistory.FieldCoverURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverURL(v)
		return nil
	case articlehistory.FieldTopImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopImgURL(v)
		return nil
	case articlehistory.FieldPrimaryColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryColor(v)
		return nil
	case articlehistory.FieldSummaries:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummaries(v)
		return nil
	case articlehistory.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordCount(v)
		return nil
	case articlehistory.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case articlehistory.FieldEditorID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditorID(v)
		return nil
	case articlehistory.FieldEditorNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditorNickname(v)
		return nil
	case articlehistory.FieldChangeNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeNote(v)
		return nil
	case articlehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlehistory.FieldExtraData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, articlehistory.FieldVersion)
	}
	if m.addword_count != nil {
		fields = append(fields, articlehistory.FieldWordCount)
	}
	if m.addeditor_id != nil {
		fields = append(fields, articlehistory.FieldEditorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case articlehistory.FieldVersion:
		return m.AddedVersion()
	case articlehistory.FieldWordCount:
		return m.AddedWordCount()
	case articlehistory.FieldEditorID:
		return m.AddedEditorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case articlehistory.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case articlehistory.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordCount(v)
		return nil
	case articlehistory.FieldEditorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEditorID(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(articlehistory.FieldContentMd) {
		fields = append(fields, articlehistory.FieldContentMd)
	}
	if m.FieldCleared(articlehistory.FieldContentHTML) {
		fields = append(fields, articlehistory.FieldContentHTML)
	}
	if m.FieldCleared(articlehistory.FieldCoverURL) {
		fields = append(fields, articlehistory.FieldCoverURL)
	}
	if m.FieldCleared(articlehistory.FieldTopImgURL) {
		fields = append(fields, articlehistory.FieldTopImgURL)
	}
	if m.FieldCleared(articlehistory.FieldPrimaryColor) {
		fields = append(fields, articlehistory.FieldPrimaryColor)
	}
	if m.FieldCleared(articlehistory.FieldSummaries) {
		fields = append(fields, articlehistory.FieldSummaries)
	}
	if m.FieldCleared(articlehistory.FieldKeywords) {
		fields = append(fields, articlehistory.FieldKeywords)
	}
	if m.FieldCleared(articlehistory.FieldEditorNickname) {
		fields = append(fields, articlehistory.FieldEditorNickname)
	}
	if m.FieldCleared(articlehistory.FieldChangeNote) {
		fields = append(fields, articlehistory.FieldChangeNote)
	}
	if m.FieldCleared(articlehistory.FieldExtraData) {
		fields = append(fields, articlehistory.FieldExtraData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleHistoryMutation) ClearField(name string) error {
	switch name {
	case articlehistory.FieldContentMd:
		m.ClearContentMd()
		return nil
	case articlehistory.FieldContentHTML:
		m.ClearContentHTML()
		return nil
	case articlehistory.FieldCoverURL:
		m.ClearCoverURL()
		return nil
	case articlehistory.FieldTopImgURL:
		m.ClearTopImgURL()
		return nil
	case articlehistory.FieldPrimaryColor:
		m.ClearPrimaryColor()
		return nil
	case articlehistory.FieldSummaries:
		m.ClearSummaries()
		return nil
	case articlehistory.FieldKeywords:
		m.ClearKeywords()
		return nil
	case articlehistory.FieldEditorNickname:
		m.ClearEditorNickname()
		return nil
	case articlehistory.FieldChangeNote:
		m.ClearChangeNote()
		return nil
	case articlehistory.FieldExtraData:
		m.ClearExtraData()
		return nil
	}
	return fmt.Errorf("unknown ArticleHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleHistoryMutation) ResetField(name string) error {
	switch name {
	case articlehistory.FieldArticleID:
		m.ResetArticleID()
		return nil
	case articlehistory.FieldVersion:
		m.ResetVersion()
		return nil
	case articlehistory.FieldTitle:
		m.ResetTitle()
		return nil
	case articlehistory.FieldContentMd:
		m.ResetContentMd()
		return nil
	case articlehistory.FieldContentHTML:
		m.ResetContentHTML()
		return nil
	case articlehistory.FieldCoverURL:
		m.ResetCoverURL()
		return nil
	case articlehistory.FieldTopImgURL:
		m.ResetTopImgURL()
		return nil
	case articlehistory.FieldPrimaryColor:
		m.ResetPrimaryColor()
		return nil
	case articlehistory.FieldSummaries:
		m.ResetSummaries()
		return nil
	case articlehistory.FieldWordCount:
		m.ResetWordCount()
		return nil
	case articlehistory.FieldKeywords:
		m.ResetKeywords()
		return nil
	case articlehistory.FieldEditorID:
		m.ResetEditorID()
		return nil
	case articlehistory.FieldEditorNickname:
		m.ResetEditorNickname()
		return nil
	case articlehistory.FieldChangeNote:
		m.ResetChangeNote()
		return nil
	case articlehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlehistory.FieldExtraData:
		m.ResetExtraData()
		return nil
	}
	return fmt.Errorf("unknown ArticleHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.article != nil {
		edges = append(edges, articlehistory.EdgeArticle)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlehistory.EdgeArticle:
		if id := m.article; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticle {
		edges = append(edges, articlehistory.EdgeArticle)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case articlehistory.EdgeArticle:
		return m.clearedarticle
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleHistoryMutation) ClearEdge(name string) error {
	switch name {
	case articlehistory.EdgeArticle:
		m.ClearArticle()
		return nil
	}
	return fmt.Errorf("unknown ArticleHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleHistoryMutation) ResetEdge(name string) error {
	switch name {
	case articlehistory.EdgeArticle:
		m.ResetArticle()
		return nil
	}
	return fmt.Errorf("unknown ArticleHistory edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op               Op
	typ              string
	id               *uint
	deleted_at       *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	target_path      *string
	target_title     *string
	reply_to_id      *uint
	addreply_to_id   *int
	nickname         *string
	email            *string
	email_md5        *string
	website          *string
	content          *string
	content_html     *string
	status           *int
	addstatus        *int
	is_admin_comment *bool
	is_anonymous     *bool
	user_agent       *string
	ip_address       *string
	ip_location      *string
	like_count       *int
	addlike_count    *int
	pinned_at        *time.Time
	clearedFields    map[string]struct{}
	user             *uint
	cleareduser      bool
	children         *uint
	clearedchildren  bool
	parent           map[uint]struct{}
	removedparent    map[uint]struct{}
	clearedparent    bool
	done             bool
	oldValue         func(context.Context) (*Comment, error)
	predicates       []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uint) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comment.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTargetPath sets the "target_path" field.
func (m *CommentMutation) SetTargetPath(s string) {
	m.target_path = &s
}

// TargetPath returns the value of the "target_path" field in the mutation.
func (m *CommentMutation) TargetPath() (r string, exists bool) {
	v := m.target_path
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetPath returns the old "target_path" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTargetPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetPath: %w", err)
	}
	return oldValue.TargetPath, nil
}

// ResetTargetPath resets all changes to the "target_path" field.
func (m *CommentMutation) ResetTargetPath() {
	m.target_path = nil
}

// SetTargetTitle sets the "target_title" field.
func (m *CommentMutation) SetTargetTitle(s string) {
	m.target_title = &s
}

// TargetTitle returns the value of the "target_title" field in the mutation.
func (m *CommentMutation) TargetTitle() (r string, exists bool) {
	v := m.target_title
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetTitle returns the old "target_title" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTargetTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetTitle: %w", err)
	}
	return oldValue.TargetTitle, nil
}

// ClearTargetTitle clears the value of the "target_title" field.
func (m *CommentMutation) ClearTargetTitle() {
	m.target_title = nil
	m.clearedFields[comment.FieldTargetTitle] = struct{}{}
}

// TargetTitleCleared returns if the "target_title" field was cleared in this mutation.
func (m *CommentMutation) TargetTitleCleared() bool {
	_, ok := m.clearedFields[comment.FieldTargetTitle]
	return ok
}

// ResetTargetTitle resets all changes to the "target_title" field.
func (m *CommentMutation) ResetTargetTitle() {
	m.target_title = nil
	delete(m.clearedFields, comment.FieldTargetTitle)
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommentMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, comment.FieldUserID)
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(u uint) {
	m.children = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r uint, exists bool) {
	v := m.children
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.children = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.children = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetReplyToID sets the "reply_to_id" field.
func (m *CommentMutation) SetReplyToID(u uint) {
	m.reply_to_id = &u
	m.addreply_to_id = nil
}

// ReplyToID returns the value of the "reply_to_id" field in the mutation.
func (m *CommentMutation) ReplyToID() (r uint, exists bool) {
	v := m.reply_to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToID returns the old "reply_to_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyToID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToID: %w", err)
	}
	return oldValue.ReplyToID, nil
}

// AddReplyToID adds u to the "reply_to_id" field.
func (m *CommentMutation) AddReplyToID(u int) {
	if m.addreply_to_id != nil {
		*m.addreply_to_id += u
	} else {
		m.addreply_to_id = &u
	}
}

// AddedReplyToID returns the value that was added to the "reply_to_id" field in this mutation.
func (m *CommentMutation) AddedReplyToID() (r int, exists bool) {
	v := m.addreply_to_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplyToID clears the value of the "reply_to_id" field.
func (m *CommentMutation) ClearReplyToID() {
	m.reply_to_id = nil
	m.addreply_to_id = nil
	m.clearedFields[comment.FieldReplyToID] = struct{}{}
}

// ReplyToIDCleared returns if the "reply_to_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyToIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyToID]
	return ok
}

// ResetReplyToID resets all changes to the "reply_to_id" field.
func (m *CommentMutation) ResetReplyToID() {
	m.reply_to_id = nil
	m.addreply_to_id = nil
	delete(m.clearedFields, comment.FieldReplyToID)
}

// SetNickname sets the "nickname" field.
func (m *CommentMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *CommentMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *CommentMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *CommentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CommentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CommentMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[comment.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CommentMutation) EmailCleared() bool {
	_, ok := m.clearedFields[comment.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CommentMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, comment.FieldEmail)
}

// SetEmailMd5 sets the "email_md5" field.
func (m *CommentMutation) SetEmailMd5(s string) {
	m.email_md5 = &s
}

// EmailMd5 returns the value of the "email_md5" field in the mutation.
func (m *CommentMutation) EmailMd5() (r string, exists bool) {
	v := m.email_md5
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailMd5 returns the old "email_md5" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEmailMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailMd5: %w", err)
	}
	return oldValue.EmailMd5, nil
}

// ResetEmailMd5 resets all changes to the "email_md5" field.
func (m *CommentMutation) ResetEmailMd5() {
	m.email_md5 = nil
}

// SetWebsite sets the "website" field.
func (m *CommentMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *CommentMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *CommentMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[comment.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *CommentMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[comment.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *CommentMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, comment.FieldWebsite)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetContentHTML sets the "content_html" field.
func (m *CommentMutation) SetContentHTML(s string) {
	m.content_html = &s
}

// ContentHTML returns the value of the "content_html" field in the mutation.
func (m *CommentMutation) ContentHTML() (r string, exists bool) {
	v := m.content_html
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHTML returns the old "content_html" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContentHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHTML: %w", err)
	}
	return oldValue.ContentHTML, nil
}

// ResetContentHTML resets all changes to the "content_html" field.
func (m *CommentMutation) ResetContentHTML() {
	m.content_html = nil
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommentMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommentMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsAdminComment sets the "is_admin_comment" field.
func (m *CommentMutation) SetIsAdminComment(b bool) {
	m.is_admin_comment = &b
}

// IsAdminComment returns the value of the "is_admin_comment" field in the mutation.
func (m *CommentMutation) IsAdminComment() (r bool, exists bool) {
	v := m.is_admin_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdminComment returns the old "is_admin_comment" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsAdminComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdminComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdminComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdminComment: %w", err)
	}
	return oldValue.IsAdminComment, nil
}

// ResetIsAdminComment resets all changes to the "is_admin_comment" field.
func (m *CommentMutation) ResetIsAdminComment() {
	m.is_admin_comment = nil
}

// SetIsAnonymous sets the "is_anonymous" field.
func (m *CommentMutation) SetIsAnonymous(b bool) {
	m.is_anonymous = &b
}

// IsAnonymous returns the value of the "is_anonymous" field in the mutation.
func (m *CommentMutation) IsAnonymous() (r bool, exists bool) {
	v := m.is_anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAnonymous returns the old "is_anonymous" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAnonymous: %w", err)
	}
	return oldValue.IsAnonymous, nil
}

// ResetIsAnonymous resets all changes to the "is_anonymous" field.
func (m *CommentMutation) ResetIsAnonymous() {
	m.is_anonymous = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *CommentMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *CommentMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *CommentMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[comment.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *CommentMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *CommentMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, comment.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *CommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CommentMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetIPLocation sets the "ip_location" field.
func (m *CommentMutation) SetIPLocation(s string) {
	m.ip_location = &s
}

// IPLocation returns the value of the "ip_location" field in the mutation.
func (m *CommentMutation) IPLocation() (r string, exists bool) {
	v := m.ip_location
	if v == nil {
		return
	}
	return *v, true
}

// OldIPLocation returns the old "ip_location" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPLocation: %w", err)
	}
	return oldValue.IPLocation, nil
}

// ClearIPLocation clears the value of the "ip_location" field.
func (m *CommentMutation) ClearIPLocation() {
	m.ip_location = nil
	m.clearedFields[comment.FieldIPLocation] = struct{}{}
}

// IPLocationCleared returns if the "ip_location" field was cleared in this mutation.
func (m *CommentMutation) IPLocationCleared() bool {
	_, ok := m.clearedFields[comment.FieldIPLocation]
	return ok
}

// ResetIPLocation resets all changes to the "ip_location" field.
func (m *CommentMutation) ResetIPLocation() {
	m.ip_location = nil
	delete(m.clearedFields, comment.FieldIPLocation)
}

// SetLikeCount sets the "like_count" field.
func (m *CommentMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *CommentMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *CommentMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *CommentMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *CommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetPinnedAt sets the "pinned_at" field.
func (m *CommentMutation) SetPinnedAt(t time.Time) {
	m.pinned_at = &t
}

// PinnedAt returns the value of the "pinned_at" field in the mutation.
func (m *CommentMutation) PinnedAt() (r time.Time, exists bool) {
	v := m.pinned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPinnedAt returns the old "pinned_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPinnedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinnedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinnedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinnedAt: %w", err)
	}
	return oldValue.PinnedAt, nil
}

// ClearPinnedAt clears the value of the "pinned_at" field.
func (m *CommentMutation) ClearPinnedAt() {
	m.pinned_at = nil
	m.clearedFields[comment.FieldPinnedAt] = struct{}{}
}

// PinnedAtCleared returns if the "pinned_at" field was cleared in this mutation.
func (m *CommentMutation) PinnedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldPinnedAt]
	return ok
}

// ResetPinnedAt resets all changes to the "pinned_at" field.
func (m *CommentMutation) ResetPinnedAt() {
	m.pinned_at = nil
	delete(m.clearedFields, comment.FieldPinnedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetChildrenID sets the "children" edge to the Comment entity by id.
func (m *CommentMutation) SetChildrenID(id uint) {
	m.children = &id
}

// ClearChildren clears the "children" edge to the Comment entity.
func (m *CommentMutation) ClearChildren() {
	m.clearedchildren = true
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ChildrenCleared reports if the "children" edge to the Comment entity was cleared.
func (m *CommentMutation) ChildrenCleared() bool {
	return m.ParentIDCleared() || m.clearedchildren
}

// ChildrenID returns the "children" edge ID in the mutation.
func (m *CommentMutation) ChildrenID() (id uint, exists bool) {
	if m.children != nil {
		return *m.children, true
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildrenID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ChildrenIDs() (ids []uint) {
	if id := m.children; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CommentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
}

// AddParentIDs adds the "parent" edge to the Comment entity by ids.
func (m *CommentMutation) AddParentIDs(ids ...uint) {
	if m.parent == nil {
		m.parent = make(map[uint]struct{})
	}
	for i := range ids {
		m.parent[ids[i]] = struct{}{}
	}
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.clearedparent
}

// RemoveParentIDs removes the "parent" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveParentIDs(ids ...uint) {
	if m.removedparent == nil {
		m.removedparent = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.parent, ids[i])
		m.removedparent[ids[i]] = struct{}{}
	}
}

// RemovedParent returns the removed IDs of the "parent" edge to the Comment entity.
func (m *CommentMutation) RemovedParentIDs() (ids []uint) {
	for id := range m.removedparent {
		ids = append(ids, id)
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
func (m *CommentMutation) ParentIDs() (ids []uint) {
	for id := range m.parent {
		ids = append(ids, id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
	m.removedparent = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.target_path != nil {
		fields = append(fields, comment.FieldTargetPath)
	}
	if m.target_title != nil {
		fields = append(fields, comment.FieldTargetTitle)
	}
	if m.user != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.children != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.reply_to_id != nil {
		fields = append(fields, comment.FieldReplyToID)
	}
	if m.nickname != nil {
		fields = append(fields, comment.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, comment.FieldEmail)
	}
	if m.email_md5 != nil {
		fields = append(fields, comment.FieldEmailMd5)
	}
	if m.website != nil {
		fields = append(fields, comment.FieldWebsite)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.content_html != nil {
		fields = append(fields, comment.FieldContentHTML)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.is_admin_comment != nil {
		fields = append(fields, comment.FieldIsAdminComment)
	}
	if m.is_anonymous != nil {
		fields = append(fields, comment.FieldIsAnonymous)
	}
	if m.user_agent != nil {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, comment.FieldIPAddress)
	}
	if m.ip_location != nil {
		fields = append(fields, comment.FieldIPLocation)
	}
	if m.like_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.pinned_at != nil {
		fields = append(fields, comment.FieldPinnedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldTargetPath:
		return m.TargetPath()
	case comment.FieldTargetTitle:
		return m.TargetTitle()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldReplyToID:
		return m.ReplyToID()
	case comment.FieldNickname:
		return m.Nickname()
	case comment.FieldEmail:
		return m.Email()
	case comment.FieldEmailMd5:
		return m.EmailMd5()
	case comment.FieldWebsite:
		return m.Website()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldContentHTML:
		return m.ContentHTML()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldIsAdminComment:
		return m.IsAdminComment()
	case comment.FieldIsAnonymous:
		return m.IsAnonymous()
	case comment.FieldUserAgent:
		return m.UserAgent()
	case comment.FieldIPAddress:
		return m.IPAddress()
	case comment.FieldIPLocation:
		return m.IPLocation()
	case comment.FieldLikeCount:
		return m.LikeCount()
	case comment.FieldPinnedAt:
		return m.PinnedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldTargetPath:
		return m.OldTargetPath(ctx)
	case comment.FieldTargetTitle:
		return m.OldTargetTitle(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldReplyToID:
		return m.OldReplyToID(ctx)
	case comment.FieldNickname:
		return m.OldNickname(ctx)
	case comment.FieldEmail:
		return m.OldEmail(ctx)
	case comment.FieldEmailMd5:
		return m.OldEmailMd5(ctx)
	case comment.FieldWebsite:
		return m.OldWebsite(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldContentHTML:
		return m.OldContentHTML(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldIsAdminComment:
		return m.OldIsAdminComment(ctx)
	case comment.FieldIsAnonymous:
		return m.OldIsAnonymous(ctx)
	case comment.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case comment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case comment.FieldIPLocation:
		return m.OldIPLocation(ctx)
	case comment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case comment.FieldPinnedAt:
		return m.OldPinnedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldTargetPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetPath(v)
		return nil
	case comment.FieldTargetTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetTitle(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldReplyToID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToID(v)
		return nil
	case comment.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case comment.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case comment.FieldEmailMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailMd5(v)
		return nil
	case comment.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldContentHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHTML(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldIsAdminComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdminComment(v)
		return nil
	case comment.FieldIsAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAnonymous(v)
		return nil
	case comment.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case comment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case comment.FieldIPLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPLocation(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case comment.FieldPinnedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinnedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addreply_to_id != nil {
		fields = append(fields, comment.FieldReplyToID)
	}
	if m.addstatus != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.addlike_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldReplyToID:
		return m.AddedReplyToID()
	case comment.FieldStatus:
		return m.AddedStatus()
	case comment.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldReplyToID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyToID(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldDeletedAt) {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.FieldCleared(comment.FieldTargetTitle) {
		fields = append(fields, comment.FieldTargetTitle)
	}
	if m.FieldCleared(comment.FieldUserID) {
		fields = append(fields, comment.FieldUserID)
	}
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	if m.FieldCleared(comment.FieldReplyToID) {
		fields = append(fields, comment.FieldReplyToID)
	}
	if m.FieldCleared(comment.FieldEmail) {
		fields = append(fields, comment.FieldEmail)
	}
	if m.FieldCleared(comment.FieldWebsite) {
		fields = append(fields, comment.FieldWebsite)
	}
	if m.FieldCleared(comment.FieldUserAgent) {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.FieldCleared(comment.FieldIPLocation) {
		fields = append(fields, comment.FieldIPLocation)
	}
	if m.FieldCleared(comment.FieldPinnedAt) {
		fields = append(fields, comment.FieldPinnedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case comment.FieldTargetTitle:
		m.ClearTargetTitle()
		return nil
	case comment.FieldUserID:
		m.ClearUserID()
		return nil
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	case comment.FieldReplyToID:
		m.ClearReplyToID()
		return nil
	case comment.FieldEmail:
		m.ClearEmail()
		return nil
	case comment.FieldWebsite:
		m.ClearWebsite()
		return nil
	case comment.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case comment.FieldIPLocation:
		m.ClearIPLocation()
		return nil
	case comment.FieldPinnedAt:
		m.ClearPinnedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldTargetPath:
		m.ResetTargetPath()
		return nil
	case comment.FieldTargetTitle:
		m.ResetTargetTitle()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldReplyToID:
		m.ResetReplyToID()
		return nil
	case comment.FieldNickname:
		m.ResetNickname()
		return nil
	case comment.FieldEmail:
		m.ResetEmail()
		return nil
	case comment.FieldEmailMd5:
		m.ResetEmailMd5()
		return nil
	case comment.FieldWebsite:
		m.ResetWebsite()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldContentHTML:
		m.ResetContentHTML()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldIsAdminComment:
		m.ResetIsAdminComment()
		return nil
	case comment.FieldIsAnonymous:
		m.ResetIsAnonymous()
		return nil
	case comment.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case comment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case comment.FieldIPLocation:
		m.ResetIPLocation()
		return nil
	case comment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case comment.FieldPinnedAt:
		m.ResetPinnedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.children != nil {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeChildren:
		if id := m.children; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParent:
		ids := make([]ent.Value, 0, len(m.parent))
		for id := range m.parent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeParent:
		ids := make([]ent.Value, 0, len(m.removedparent))
		for id := range m.removedparent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedchildren {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgeChildren:
		return m.clearedchildren
	case comment.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	case comment.EdgeChildren:
		m.ClearChildren()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgeChildren:
		m.ResetChildren()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DirectLinkMutation represents an operation that mutates the DirectLink nodes in the graph.
type DirectLinkMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	deleted_at     *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	file_name      *string
	speed_limit    *int64
	addspeed_limit *int64
	downloads      *int64
	adddownloads   *int64
	clearedFields  map[string]struct{}
	file           *uint
	clearedfile    bool
	done           bool
	oldValue       func(context.Context) (*DirectLink, error)
	predicates     []predicate.DirectLink
}

var _ ent.Mutation = (*DirectLinkMutation)(nil)

// directlinkOption allows management of the mutation configuration using functional options.
type directlinkOption func(*DirectLinkMutation)

// newDirectLinkMutation creates new mutation for the DirectLink entity.
func newDirectLinkMutation(c config, op Op, opts ...directlinkOption) *DirectLinkMutation {
	m := &DirectLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectLinkID sets the ID field of the mutation.
func withDirectLinkID(id uint) directlinkOption {
	return func(m *DirectLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectLink
		)
		m.oldValue = func(ctx context.Context) (*DirectLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectLink sets the old DirectLink of the mutation.
func withDirectLink(node *DirectLink) directlinkOption {
	return func(m *DirectLinkMutation) {
		m.oldValue = func(context.Context) (*DirectLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DirectLink entities.
func (m *DirectLinkMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectLinkMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectLinkMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DirectLinkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DirectLinkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DirectLinkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[directlink.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DirectLinkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[directlink.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DirectLinkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, directlink.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *DirectLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DirectLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DirectLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DirectLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DirectLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DirectLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFileID sets the "file_id" field.
func (m *DirectLinkMutation) SetFileID(u uint) {
	m.file = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *DirectLinkMutation) FileID() (r uint, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldFileID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *DirectLinkMutation) ResetFileID() {
	m.file = nil
}

// SetFileName sets the "file_name" field.
func (m *DirectLinkMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *DirectLinkMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *DirectLinkMutation) ResetFileName() {
	m.file_name = nil
}

// SetSpeedLimit sets the "speed_limit" field.
func (m *DirectLinkMutation) SetSpeedLimit(i int64) {
	m.speed_limit = &i
	m.addspeed_limit = nil
}

// SpeedLimit returns the value of the "speed_limit" field in the mutation.
func (m *DirectLinkMutation) SpeedLimit() (r int64, exists bool) {
	v := m.speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedLimit returns the old "speed_limit" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldSpeedLimit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedLimit: %w", err)
	}
	return oldValue.SpeedLimit, nil
}

// AddSpeedLimit adds i to the "speed_limit" field.
func (m *DirectLinkMutation) AddSpeedLimit(i int64) {
	if m.addspeed_limit != nil {
		*m.addspeed_limit += i
	} else {
		m.addspeed_limit = &i
	}
}

// AddedSpeedLimit returns the value that was added to the "speed_limit" field in this mutation.
func (m *DirectLinkMutation) AddedSpeedLimit() (r int64, exists bool) {
	v := m.addspeed_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeedLimit resets all changes to the "speed_limit" field.
func (m *DirectLinkMutation) ResetSpeedLimit() {
	m.speed_limit = nil
	m.addspeed_limit = nil
}

// SetDownloads sets the "downloads" field.
func (m *DirectLinkMutation) SetDownloads(i int64) {
	m.downloads = &i
	m.adddownloads = nil
}

// Downloads returns the value of the "downloads" field in the mutation.
func (m *DirectLinkMutation) Downloads() (r int64, exists bool) {
	v := m.downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloads returns the old "downloads" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldDownloads(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloads: %w", err)
	}
	return oldValue.Downloads, nil
}

// AddDownloads adds i to the "downloads" field.
func (m *DirectLinkMutation) AddDownloads(i int64) {
	if m.adddownloads != nil {
		*m.adddownloads += i
	} else {
		m.adddownloads = &i
	}
}

// AddedDownloads returns the value that was added to the "downloads" field in this mutation.
func (m *DirectLinkMutation) AddedDownloads() (r int64, exists bool) {
	v := m.adddownloads
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloads resets all changes to the "downloads" field.
func (m *DirectLinkMutation) ResetDownloads() {
	m.downloads = nil
	m.adddownloads = nil
}

// ClearFile clears the "file" edge to the File entity.
func (m *DirectLinkMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[directlink.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *DirectLinkMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *DirectLinkMutation) FileIDs() (ids []uint) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *DirectLinkMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the DirectLinkMutation builder.
func (m *DirectLinkMutation) Where(ps ...predicate.DirectLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectLink).
func (m *DirectLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, directlink.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, directlink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, directlink.FieldUpdatedAt)
	}
	if m.file != nil {
		fields = append(fields, directlink.FieldFileID)
	}
	if m.file_name != nil {
		fields = append(fields, directlink.FieldFileName)
	}
	if m.speed_limit != nil {
		fields = append(fields, directlink.FieldSpeedLimit)
	}
	if m.downloads != nil {
		fields = append(fields, directlink.FieldDownloads)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directlink.FieldDeletedAt:
		return m.DeletedAt()
	case directlink.FieldCreatedAt:
		return m.CreatedAt()
	case directlink.FieldUpdatedAt:
		return m.UpdatedAt()
	case directlink.FieldFileID:
		return m.FileID()
	case directlink.FieldFileName:
		return m.FileName()
	case directlink.FieldSpeedLimit:
		return m.SpeedLimit()
	case directlink.FieldDownloads:
		return m.Downloads()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directlink.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case directlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case directlink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case directlink.FieldFileID:
		return m.OldFileID(ctx)
	case directlink.FieldFileName:
		return m.OldFileName(ctx)
	case directlink.FieldSpeedLimit:
		return m.OldSpeedLimit(ctx)
	case directlink.FieldDownloads:
		return m.OldDownloads(ctx)
	}
	return nil, fmt.Errorf("unknown DirectLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directlink.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case directlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case directlink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case directlink.FieldFileID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case directlink.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case directlink.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedLimit(v)
		return nil
	case directlink.FieldDownloads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown DirectLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectLinkMutation) AddedFields() []string {
	var fields []string
	if m.addspeed_limit != nil {
		fields = append(fields, directlink.FieldSpeedLimit)
	}
	if m.adddownloads != nil {
		fields = append(fields, directlink.FieldDownloads)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case directlink.FieldSpeedLimit:
		return m.AddedSpeedLimit()
	case directlink.FieldDownloads:
		return m.AddedDownloads()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case directlink.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedLimit(v)
		return nil
	case directlink.FieldDownloads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown DirectLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directlink.FieldDeletedAt) {
		fields = append(fields, directlink.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectLinkMutation) ClearField(name string) error {
	switch name {
	case directlink.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DirectLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectLinkMutation) ResetField(name string) error {
	switch name {
	case directlink.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case directlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case directlink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case directlink.FieldFileID:
		m.ResetFileID()
		return nil
	case directlink.FieldFileName:
		m.ResetFileName()
		return nil
	case directlink.FieldSpeedLimit:
		m.ResetSpeedLimit()
		return nil
	case directlink.FieldDownloads:
		m.ResetDownloads()
		return nil
	}
	return fmt.Errorf("unknown DirectLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, directlink.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case directlink.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, directlink.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case directlink.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectLinkMutation) ClearEdge(name string) error {
	switch name {
	case directlink.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown DirectLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectLinkMutation) ResetEdge(name string) error {
	switch name {
	case directlink.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown DirectLink edge %s", name)
}

// DocSeriesMutation represents an operation that mutates the DocSeries nodes in the graph.
type DocSeriesMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	cover_url       *string
	sort            *int
	addsort         *int
	doc_count       *int
	adddoc_count    *int
	clearedFields   map[string]struct{}
	articles        map[uint]struct{}
	removedarticles map[uint]struct{}
	clearedarticles bool
	done            bool
	oldValue        func(context.Context) (*DocSeries, error)
	predicates      []predicate.DocSeries
}

var _ ent.Mutation = (*DocSeriesMutation)(nil)

// docseriesOption allows management of the mutation configuration using functional options.
type docseriesOption func(*DocSeriesMutation)

// newDocSeriesMutation creates new mutation for the DocSeries entity.
func newDocSeriesMutation(c config, op Op, opts ...docseriesOption) *DocSeriesMutation {
	m := &DocSeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeDocSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocSeriesID sets the ID field of the mutation.
func withDocSeriesID(id uint) docseriesOption {
	return func(m *DocSeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *DocSeries
		)
		m.oldValue = func(ctx context.Context) (*DocSeries, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocSeries.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocSeries sets the old DocSeries of the mutation.
func withDocSeries(node *DocSeries) docseriesOption {
	return func(m *DocSeriesMutation) {
		m.oldValue = func(context.Context) (*DocSeries, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocSeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocSeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocSeries entities.
func (m *DocSeriesMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocSeriesMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocSeriesMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocSeries.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DocSeriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocSeriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocSeriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocSeriesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocSeriesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocSeriesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *DocSeriesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocSeriesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocSeriesMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DocSeriesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DocSeriesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocSeriesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[docseries.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocSeriesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[docseries.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocSeriesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, docseries.FieldDescription)
}

// SetCoverURL sets the "cover_url" field.
func (m *DocSeriesMutation) SetCoverURL(s string) {
	m.cover_url = &s
}

// CoverURL returns the value of the "cover_url" field in the mutation.
func (m *DocSeriesMutation) CoverURL() (r string, exists bool) {
	v := m.cover_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverURL returns the old "cover_url" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldCoverURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverURL: %w", err)
	}
	return oldValue.CoverURL, nil
}

// ClearCoverURL clears the value of the "cover_url" field.
func (m *DocSeriesMutation) ClearCoverURL() {
	m.cover_url = nil
	m.clearedFields[docseries.FieldCoverURL] = struct{}{}
}

// CoverURLCleared returns if the "cover_url" field was cleared in this mutation.
func (m *DocSeriesMutation) CoverURLCleared() bool {
	_, ok := m.clearedFields[docseries.FieldCoverURL]
	return ok
}

// ResetCoverURL resets all changes to the "cover_url" field.
func (m *DocSeriesMutation) ResetCoverURL() {
	m.cover_url = nil
	delete(m.clearedFields, docseries.FieldCoverURL)
}

// SetSort sets the "sort" field.
func (m *DocSeriesMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DocSeriesMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *DocSeriesMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DocSeriesMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *DocSeriesMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetDocCount sets the "doc_count" field.
func (m *DocSeriesMutation) SetDocCount(i int) {
	m.doc_count = &i
	m.adddoc_count = nil
}

// DocCount returns the value of the "doc_count" field in the mutation.
func (m *DocSeriesMutation) DocCount() (r int, exists bool) {
	v := m.doc_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDocCount returns the old "doc_count" field's value of the DocSeries entity.
// If the DocSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocSeriesMutation) OldDocCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocCount: %w", err)
	}
	return oldValue.DocCount, nil
}

// AddDocCount adds i to the "doc_count" field.
func (m *DocSeriesMutation) AddDocCount(i int) {
	if m.adddoc_count != nil {
		*m.adddoc_count += i
	} else {
		m.adddoc_count = &i
	}
}

// AddedDocCount returns the value that was added to the "doc_count" field in this mutation.
func (m *DocSeriesMutation) AddedDocCount() (r int, exists bool) {
	v := m.adddoc_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDocCount resets all changes to the "doc_count" field.
func (m *DocSeriesMutation) ResetDocCount() {
	m.doc_count = nil
	m.adddoc_count = nil
}

// AddArticleIDs adds the "articles" edge to the Article entity by ids.
func (m *DocSeriesMutation) AddArticleIDs(ids ...uint) {
	if m.articles == nil {
		m.articles = make(map[uint]struct{})
	}
	for i := range ids {
		m.articles[ids[i]] = struct{}{}
	}
}

// ClearArticles clears the "articles" edge to the Article entity.
func (m *DocSeriesMutation) ClearArticles() {
	m.clearedarticles = true
}

// ArticlesCleared reports if the "articles" edge to the Article entity was cleared.
func (m *DocSeriesMutation) ArticlesCleared() bool {
	return m.clearedarticles
}

// RemoveArticleIDs removes the "articles" edge to the Article entity by IDs.
func (m *DocSeriesMutation) RemoveArticleIDs(ids ...uint) {
	if m.removedarticles == nil {
		m.removedarticles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.articles, ids[i])
		m.removedarticles[ids[i]] = struct{}{}
	}
}

// RemovedArticles returns the removed IDs of the "articles" edge to the Article entity.
func (m *DocSeriesMutation) RemovedArticlesIDs() (ids []uint) {
	for id := range m.removedarticles {
		ids = append(ids, id)
	}
	return
}

// ArticlesIDs returns the "articles" edge IDs in the mutation.
func (m *DocSeriesMutation) ArticlesIDs() (ids []uint) {
	for id := range m.articles {
		ids = append(ids, id)
	}
	return
}

// ResetArticles resets all changes to the "articles" edge.
func (m *DocSeriesMutation) ResetArticles() {
	m.articles = nil
	m.clearedarticles = false
	m.removedarticles = nil
}

// Where appends a list predicates to the DocSeriesMutation builder.
func (m *DocSeriesMutation) Where(ps ...predicate.DocSeries) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocSeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocSeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocSeries, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocSeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocSeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocSeries).
func (m *DocSeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocSeriesMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, docseries.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, docseries.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, docseries.FieldName)
	}
	if m.description != nil {
		fields = append(fields, docseries.FieldDescription)
	}
	if m.cover_url != nil {
		fields = append(fields, docseries.FieldCoverURL)
	}
	if m.sort != nil {
		fields = append(fields, docseries.FieldSort)
	}
	if m.doc_count != nil {
		fields = append(fields, docseries.FieldDocCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocSeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case docseries.FieldCreatedAt:
		return m.CreatedAt()
	case docseries.FieldUpdatedAt:
		return m.UpdatedAt()
	case docseries.FieldName:
		return m.Name()
	case docseries.FieldDescription:
		return m.Description()
	case docseries.FieldCoverURL:
		return m.CoverURL()
	case docseries.FieldSort:
		return m.Sort()
	case docseries.FieldDocCount:
		return m.DocCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocSeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case docseries.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case docseries.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case docseries.FieldName:
		return m.OldName(ctx)
	case docseries.FieldDescription:
		return m.OldDescription(ctx)
	case docseries.FieldCoverURL:
		return m.OldCoverURL(ctx)
	case docseries.FieldSort:
		return m.OldSort(ctx)
	case docseries.FieldDocCount:
		return m.OldDocCount(ctx)
	}
	return nil, fmt.Errorf("unknown DocSeries field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocSeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case docseries.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case docseries.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case docseries.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case docseries.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case docseries.FieldCoverURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverURL(v)
		return nil
	case docseries.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case docseries.FieldDocCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocCount(v)
		return nil
	}
	return fmt.Errorf("unknown DocSeries field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocSeriesMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, docseries.FieldSort)
	}
	if m.adddoc_count != nil {
		fields = append(fields, docseries.FieldDocCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocSeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case docseries.FieldSort:
		return m.AddedSort()
	case docseries.FieldDocCount:
		return m.AddedDocCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocSeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case docseries.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case docseries.FieldDocCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDocCount(v)
		return nil
	}
	return fmt.Errorf("unknown DocSeries numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocSeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(docseries.FieldDescription) {
		fields = append(fields, docseries.FieldDescription)
	}
	if m.FieldCleared(docseries.FieldCoverURL) {
		fields = append(fields, docseries.FieldCoverURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocSeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocSeriesMutation) ClearField(name string) error {
	switch name {
	case docseries.FieldDescription:
		m.ClearDescription()
		return nil
	case docseries.FieldCoverURL:
		m.ClearCoverURL()
		return nil
	}
	return fmt.Errorf("unknown DocSeries nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocSeriesMutation) ResetField(name string) error {
	switch name {
	case docseries.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case docseries.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case docseries.FieldName:
		m.ResetName()
		return nil
	case docseries.FieldDescription:
		m.ResetDescription()
		return nil
	case docseries.FieldCoverURL:
		m.ResetCoverURL()
		return nil
	case docseries.FieldSort:
		m.ResetSort()
		return nil
	case docseries.FieldDocCount:
		m.ResetDocCount()
		return nil
	}
	return fmt.Errorf("unknown DocSeries field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocSeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.articles != nil {
		edges = append(edges, docseries.EdgeArticles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocSeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case docseries.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.articles))
		for id := range m.articles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocSeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedarticles != nil {
		edges = append(edges, docseries.EdgeArticles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocSeriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case docseries.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.removedarticles))
		for id := range m.removedarticles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocSeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticles {
		edges = append(edges, docseries.EdgeArticles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocSeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case docseries.EdgeArticles:
		return m.clearedarticles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocSeriesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DocSeries unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocSeriesMutation) ResetEdge(name string) error {
	switch name {
	case docseries.EdgeArticles:
		m.ResetArticles()
		return nil
	}
	return fmt.Errorf("unknown DocSeries edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint
	created_at           *time.Time
	updated_at           *time.Time
	_type                *string
	source               *string
	size                 *int64
	addsize              *int64
	upload_session_id    *string
	recycle_options      *string
	policy_id            *uint
	addpolicy_id         *int
	created_by           *uint64
	addcreated_by        *int64
	etag                 *string
	mime_type            *string
	dimension            *string
	storage_metadata     *model.JSONMap
	clearedFields        map[string]struct{}
	file_versions        map[uint]struct{}
	removedfile_versions map[uint]struct{}
	clearedfile_versions bool
	done                 bool
	oldValue             func(context.Context) (*Entity, error)
	predicates           []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id uint) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entity entities.
func (m *EntityMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *EntityMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EntityMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EntityMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *EntityMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *EntityMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *EntityMutation) ClearSource() {
	m.source = nil
	m.clearedFields[entity.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *EntityMutation) SourceCleared() bool {
	_, ok := m.clearedFields[entity.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *EntityMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, entity.FieldSource)
}

// SetSize sets the "size" field.
func (m *EntityMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *EntityMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *EntityMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *EntityMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *EntityMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetUploadSessionID sets the "upload_session_id" field.
func (m *EntityMutation) SetUploadSessionID(s string) {
	m.upload_session_id = &s
}

// UploadSessionID returns the value of the "upload_session_id" field in the mutation.
func (m *EntityMutation) UploadSessionID() (r string, exists bool) {
	v := m.upload_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadSessionID returns the old "upload_session_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUploadSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadSessionID: %w", err)
	}
	return oldValue.UploadSessionID, nil
}

// ClearUploadSessionID clears the value of the "upload_session_id" field.
func (m *EntityMutation) ClearUploadSessionID() {
	m.upload_session_id = nil
	m.clearedFields[entity.FieldUploadSessionID] = struct{}{}
}

// UploadSessionIDCleared returns if the "upload_session_id" field was cleared in this mutation.
func (m *EntityMutation) UploadSessionIDCleared() bool {
	_, ok := m.clearedFields[entity.FieldUploadSessionID]
	return ok
}

// ResetUploadSessionID resets all changes to the "upload_session_id" field.
func (m *EntityMutation) ResetUploadSessionID() {
	m.upload_session_id = nil
	delete(m.clearedFields, entity.FieldUploadSessionID)
}

// SetRecycleOptions sets the "recycle_options" field.
func (m *EntityMutation) SetRecycleOptions(s string) {
	m.recycle_options = &s
}

// RecycleOptions returns the value of the "recycle_options" field in the mutation.
func (m *EntityMutation) RecycleOptions() (r string, exists bool) {
	v := m.recycle_options
	if v == nil {
		return
	}
	return *v, true
}

// OldRecycleOptions returns the old "recycle_options" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldRecycleOptions(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecycleOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecycleOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecycleOptions: %w", err)
	}
	return oldValue.RecycleOptions, nil
}

// ClearRecycleOptions clears the value of the "recycle_options" field.
func (m *EntityMutation) ClearRecycleOptions() {
	m.recycle_options = nil
	m.clearedFields[entity.FieldRecycleOptions] = struct{}{}
}

// RecycleOptionsCleared returns if the "recycle_options" field was cleared in this mutation.
func (m *EntityMutation) RecycleOptionsCleared() bool {
	_, ok := m.clearedFields[entity.FieldRecycleOptions]
	return ok
}

// ResetRecycleOptions resets all changes to the "recycle_options" field.
func (m *EntityMutation) ResetRecycleOptions() {
	m.recycle_options = nil
	delete(m.clearedFields, entity.FieldRecycleOptions)
}

// SetPolicyID sets the "policy_id" field.
func (m *EntityMutation) SetPolicyID(u uint) {
	m.policy_id = &u
	m.addpolicy_id = nil
}

// PolicyID returns the value of the "policy_id" field in the mutation.
func (m *EntityMutation) PolicyID() (r uint, exists bool) {
	v := m.policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyID returns the old "policy_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldPolicyID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyID: %w", err)
	}
	return oldValue.PolicyID, nil
}

// AddPolicyID adds u to the "policy_id" field.
func (m *EntityMutation) AddPolicyID(u int) {
	if m.addpolicy_id != nil {
		*m.addpolicy_id += u
	} else {
		m.addpolicy_id = &u
	}
}

// AddedPolicyID returns the value that was added to the "policy_id" field in this mutation.
func (m *EntityMutation) AddedPolicyID() (r int, exists bool) {
	v := m.addpolicy_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPolicyID resets all changes to the "policy_id" field.
func (m *EntityMutation) ResetPolicyID() {
	m.policy_id = nil
	m.addpolicy_id = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityMutation) SetCreatedBy(u uint64) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityMutation) CreatedBy() (r uint64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedBy(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *EntityMutation) AddCreatedBy(u int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EntityMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[entity.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entity.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, entity.FieldCreatedBy)
}

// SetEtag sets the "etag" field.
func (m *EntityMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *EntityMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldEtag(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ClearEtag clears the value of the "etag" field.
func (m *EntityMutation) ClearEtag() {
	m.etag = nil
	m.clearedFields[entity.FieldEtag] = struct{}{}
}

// EtagCleared returns if the "etag" field was cleared in this mutation.
func (m *EntityMutation) EtagCleared() bool {
	_, ok := m.clearedFields[entity.FieldEtag]
	return ok
}

// ResetEtag resets all changes to the "etag" field.
func (m *EntityMutation) ResetEtag() {
	m.etag = nil
	delete(m.clearedFields, entity.FieldEtag)
}

// SetMimeType sets the "mime_type" field.
func (m *EntityMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *EntityMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *EntityMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[entity.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *EntityMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[entity.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *EntityMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, entity.FieldMimeType)
}

// SetDimension sets the "dimension" field.
func (m *EntityMutation) SetDimension(s string) {
	m.dimension = &s
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *EntityMutation) Dimension() (r string, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDimension(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// ClearDimension clears the value of the "dimension" field.
func (m *EntityMutation) ClearDimension() {
	m.dimension = nil
	m.clearedFields[entity.FieldDimension] = struct{}{}
}

// DimensionCleared returns if the "dimension" field was cleared in this mutation.
func (m *EntityMutation) DimensionCleared() bool {
	_, ok := m.clearedFields[entity.FieldDimension]
	return ok
}

// ResetDimension resets all changes to the "dimension" field.
func (m *EntityMutation) ResetDimension() {
	m.dimension = nil
	delete(m.clearedFields, entity.FieldDimension)
}

// SetStorageMetadata sets the "storage_metadata" field.
func (m *EntityMutation) SetStorageMetadata(mm model.JSONMap) {
	m.storage_metadata = &mm
}

// StorageMetadata returns the value of the "storage_metadata" field in the mutation.
func (m *EntityMutation) StorageMetadata() (r model.JSONMap, exists bool) {
	v := m.storage_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageMetadata returns the old "storage_metadata" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldStorageMetadata(ctx context.Context) (v model.JSONMap, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageMetadata: %w", err)
	}
	return oldValue.StorageMetadata, nil
}

// ClearStorageMetadata clears the value of the "storage_metadata" field.
func (m *EntityMutation) ClearStorageMetadata() {
	m.storage_metadata = nil
	m.clearedFields[entity.FieldStorageMetadata] = struct{}{}
}

// StorageMetadataCleared returns if the "storage_metadata" field was cleared in this mutation.
func (m *EntityMutation) StorageMetadataCleared() bool {
	_, ok := m.clearedFields[entity.FieldStorageMetadata]
	return ok
}

// ResetStorageMetadata resets all changes to the "storage_metadata" field.
func (m *EntityMutation) ResetStorageMetadata() {
	m.storage_metadata = nil
	delete(m.clearedFields, entity.FieldStorageMetadata)
}

// AddFileVersionIDs adds the "file_versions" edge to the FileEntity entity by ids.
func (m *EntityMutation) AddFileVersionIDs(ids ...uint) {
	if m.file_versions == nil {
		m.file_versions = make(map[uint]struct{})
	}
	for i := range ids {
		m.file_versions[ids[i]] = struct{}{}
	}
}

// ClearFileVersions clears the "file_versions" edge to the FileEntity entity.
func (m *EntityMutation) ClearFileVersions() {
	m.clearedfile_versions = true
}

// FileVersionsCleared reports if the "file_versions" edge to the FileEntity entity was cleared.
func (m *EntityMutation) FileVersionsCleared() bool {
	return m.clearedfile_versions
}

// RemoveFileVersionIDs removes the "file_versions" edge to the FileEntity entity by IDs.
func (m *EntityMutation) RemoveFileVersionIDs(ids ...uint) {
	if m.removedfile_versions == nil {
		m.removedfile_versions = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.file_versions, ids[i])
		m.removedfile_versions[ids[i]] = struct{}{}
	}
}

// RemovedFileVersions returns the removed IDs of the "file_versions" edge to the FileEntity entity.
func (m *EntityMutation) RemovedFileVersionsIDs() (ids []uint) {
	for id := range m.removedfile_versions {
		ids = append(ids, id)
	}
	return
}

// FileVersionsIDs returns the "file_versions" edge IDs in the mutation.
func (m *EntityMutation) FileVersionsIDs() (ids []uint) {
	for id := range m.file_versions {
		ids = append(ids, id)
	}
	return
}

// ResetFileVersions resets all changes to the "file_versions" edge.
func (m *EntityMutation) ResetFileVersions() {
	m.file_versions = nil
	m.clearedfile_versions = false
	m.removedfile_versions = nil
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, entity.FieldType)
	}
	if m.source != nil {
		fields = append(fields, entity.FieldSource)
	}
	if m.size != nil {
		fields = append(fields, entity.FieldSize)
	}
	if m.upload_session_id != nil {
		fields = append(fields, entity.FieldUploadSessionID)
	}
	if m.recycle_options != nil {
		fields = append(fields, entity.FieldRecycleOptions)
	}
	if m.policy_id != nil {
		fields = append(fields, entity.FieldPolicyID)
	}
	if m.created_by != nil {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.etag != nil {
		fields = append(fields, entity.FieldEtag)
	}
	if m.mime_type != nil {
		fields = append(fields, entity.FieldMimeType)
	}
	if m.dimension != nil {
		fields = append(fields, entity.FieldDimension)
	}
	if m.storage_metadata != nil {
		fields = append(fields, entity.FieldStorageMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldCreatedAt:
		return m.CreatedAt()
	case entity.FieldUpdatedAt:
		return m.UpdatedAt()
	case entity.FieldType:
		return m.GetType()
	case entity.FieldSource:
		return m.Source()
	case entity.FieldSize:
		return m.Size()
	case entity.FieldUploadSessionID:
		return m.UploadSessionID()
	case entity.FieldRecycleOptions:
		return m.RecycleOptions()
	case entity.FieldPolicyID:
		return m.PolicyID()
	case entity.FieldCreatedBy:
		return m.CreatedBy()
	case entity.FieldEtag:
		return m.Etag()
	case entity.FieldMimeType:
		return m.MimeType()
	case entity.FieldDimension:
		return m.Dimension()
	case entity.FieldStorageMetadata:
		return m.StorageMetadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entity.FieldType:
		return m.OldType(ctx)
	case entity.FieldSource:
		return m.OldSource(ctx)
	case entity.FieldSize:
		return m.OldSize(ctx)
	case entity.FieldUploadSessionID:
		return m.OldUploadSessionID(ctx)
	case entity.FieldRecycleOptions:
		return m.OldRecycleOptions(ctx)
	case entity.FieldPolicyID:
		return m.OldPolicyID(ctx)
	case entity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entity.FieldEtag:
		return m.OldEtag(ctx)
	case entity.FieldMimeType:
		return m.OldMimeType(ctx)
	case entity.FieldDimension:
		return m.OldDimension(ctx)
	case entity.FieldStorageMetadata:
		return m.OldStorageMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entity.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case entity.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case entity.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case entity.FieldUploadSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadSessionID(v)
		return nil
	case entity.FieldRecycleOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecycleOptions(v)
		return nil
	case entity.FieldPolicyID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyID(v)
		return nil
	case entity.FieldCreatedBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entity.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case entity.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case entity.FieldDimension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case entity.FieldStorageMetadata:
		v, ok := value.(model.JSONMap)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, entity.FieldSize)
	}
	if m.addpolicy_id != nil {
		fields = append(fields, entity.FieldPolicyID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, entity.FieldCreatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldSize:
		return m.AddedSize()
	case entity.FieldPolicyID:
		return m.AddedPolicyID()
	case entity.FieldCreatedBy:
		return m.AddedCreatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entity.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case entity.FieldPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPolicyID(v)
		return nil
	case entity.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entity.FieldSource) {
		fields = append(fields, entity.FieldSource)
	}
	if m.FieldCleared(entity.FieldUploadSessionID) {
		fields = append(fields, entity.FieldUploadSessionID)
	}
	if m.FieldCleared(entity.FieldRecycleOptions) {
		fields = append(fields, entity.FieldRecycleOptions)
	}
	if m.FieldCleared(entity.FieldCreatedBy) {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.FieldCleared(entity.FieldEtag) {
		fields = append(fields, entity.FieldEtag)
	}
	if m.FieldCleared(entity.FieldMimeType) {
		fields = append(fields, entity.FieldMimeType)
	}
	if m.FieldCleared(entity.FieldDimension) {
		fields = append(fields, entity.FieldDimension)
	}
	if m.FieldCleared(entity.FieldStorageMetadata) {
		fields = append(fields, entity.FieldStorageMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	switch name {
	case entity.FieldSource:
		m.ClearSource()
		return nil
	case entity.FieldUploadSessionID:
		m.ClearUploadSessionID()
		return nil
	case entity.FieldRecycleOptions:
		m.ClearRecycleOptions()
		return nil
	case entity.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entity.FieldEtag:
		m.ClearEtag()
		return nil
	case entity.FieldMimeType:
		m.ClearMimeType()
		return nil
	case entity.FieldDimension:
		m.ClearDimension()
		return nil
	case entity.FieldStorageMetadata:
		m.ClearStorageMetadata()
		return nil
	}
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entity.FieldType:
		m.ResetType()
		return nil
	case entity.FieldSource:
		m.ResetSource()
		return nil
	case entity.FieldSize:
		m.ResetSize()
		return nil
	case entity.FieldUploadSessionID:
		m.ResetUploadSessionID()
		return nil
	case entity.FieldRecycleOptions:
		m.ResetRecycleOptions()
		return nil
	case entity.FieldPolicyID:
		m.ResetPolicyID()
		return nil
	case entity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entity.FieldEtag:
		m.ResetEtag()
		return nil
	case entity.FieldMimeType:
		m.ResetMimeType()
		return nil
	case entity.FieldDimension:
		m.ResetDimension()
		return nil
	case entity.FieldStorageMetadata:
		m.ResetStorageMetadata()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file_versions != nil {
		edges = append(edges, entity.EdgeFileVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeFileVersions:
		ids := make([]ent.Value, 0, len(m.file_versions))
		for id := range m.file_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfile_versions != nil {
		edges = append(edges, entity.EdgeFileVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeFileVersions:
		ids := make([]ent.Value, 0, len(m.removedfile_versions))
		for id := range m.removedfile_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile_versions {
		edges = append(edges, entity.EdgeFileVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeFileVersions:
		return m.clearedfile_versions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeFileVersions:
		m.ResetFileVersions()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// EssayMutation represents an operation that mutates the Essay nodes in the graph.
type EssayMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	content       *string
	date          *time.Time
	images        *string
	link          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Essay, error)
	predicates    []predicate.Essay
}

var _ ent.Mutation = (*EssayMutation)(nil)

// essayOption allows management of the mutation configuration using functional options.
type essayOption func(*EssayMutation)

// newEssayMutation creates new mutation for the Essay entity.
func newEssayMutation(c config, op Op, opts ...essayOption) *EssayMutation {
	m := &EssayMutation{
		config:        c,
		op:            op,
		typ:           TypeEssay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEssayID sets the ID field of the mutation.
func withEssayID(id uint) essayOption {
	return func(m *EssayMutation) {
		var (
			err   error
			once  sync.Once
			value *Essay
		)
		m.oldValue = func(ctx context.Context) (*Essay, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Essay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEssay sets the old Essay of the mutation.
func withEssay(node *Essay) essayOption {
	return func(m *EssayMutation) {
		m.oldValue = func(context.Context) (*Essay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EssayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EssayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Essay entities.
func (m *EssayMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EssayMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EssayMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Essay.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EssayMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EssayMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EssayMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[essay.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EssayMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[essay.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EssayMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, essay.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *EssayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EssayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EssayMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EssayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EssayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EssayMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContent sets the "content" field.
func (m *EssayMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *EssayMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *EssayMutation) ResetContent() {
	m.content = nil
}

// SetDate sets the "date" field.
func (m *EssayMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EssayMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *EssayMutation) ResetDate() {
	m.date = nil
}

// SetImages sets the "images" field.
func (m *EssayMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *EssayMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *EssayMutation) ClearImages() {
	m.images = nil
	m.clearedFields[essay.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *EssayMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[essay.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *EssayMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, essay.FieldImages)
}

// SetLink sets the "link" field.
func (m *EssayMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *EssayMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *EssayMutation) ClearLink() {
	m.link = nil
	m.clearedFields[essay.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *EssayMutation) LinkCleared() bool {
	_, ok := m.clearedFields[essay.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *EssayMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, essay.FieldLink)
}

// Where appends a list predicates to the EssayMutation builder.
func (m *EssayMutation) Where(ps ...predicate.Essay) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EssayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EssayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Essay, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EssayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EssayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Essay).
func (m *EssayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EssayMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, essay.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, essay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, essay.FieldUpdatedAt)
	}
	if m.content != nil {
		fields = append(fields, essay.FieldContent)
	}
	if m.date != nil {
		fields = append(fields, essay.FieldDate)
	}
	if m.images != nil {
		fields = append(fields, essay.FieldImages)
	}
	if m.link != nil {
		fields = append(fields, essay.FieldLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EssayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case essay.FieldDeletedAt:
		return m.DeletedAt()
	case essay.FieldCreatedAt:
		return m.CreatedAt()
	case essay.FieldUpdatedAt:
		return m.UpdatedAt()
	case essay.FieldContent:
		return m.Content()
	case essay.FieldDate:
		return m.Date()
	case essay.FieldImages:
		return m.Images()
	case essay.FieldLink:
		return m.Link()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EssayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case essay.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case essay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case essay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case essay.FieldContent:
		return m.OldContent(ctx)
	case essay.FieldDate:
		return m.OldDate(ctx)
	case essay.FieldImages:
		return m.OldImages(ctx)
	case essay.FieldLink:
		return m.OldLink(ctx)
	}
	return nil, fmt.Errorf("unknown Essay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EssayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case essay.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case essay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case essay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case essay.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case essay.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case essay.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case essay.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	}
	return fmt.Errorf("unknown Essay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EssayMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EssayMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EssayMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Essay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EssayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(essay.FieldDeletedAt) {
		fields = append(fields, essay.FieldDeletedAt)
	}
	if m.FieldCleared(essay.FieldImages) {
		fields = append(fields, essay.FieldImages)
	}
	if m.FieldCleared(essay.FieldLink) {
		fields = append(fields, essay.FieldLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EssayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EssayMutation) ClearField(name string) error {
	switch name {
	case essay.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case essay.FieldImages:
		m.ClearImages()
		return nil
	case essay.FieldLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Essay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EssayMutation) ResetField(name string) error {
	switch name {
	case essay.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case essay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case essay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case essay.FieldContent:
		m.ResetContent()
		return nil
	case essay.FieldDate:
		m.ResetDate()
		return nil
	case essay.FieldImages:
		m.ResetImages()
		return nil
	case essay.FieldLink:
		m.ResetLink()
		return nil
	}
	return fmt.Errorf("unknown Essay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EssayMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EssayMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EssayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EssayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EssayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EssayMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EssayMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Essay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EssayMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Essay edge %s", name)
}

// FCirclePostMutation represents an operation that mutates the FCirclePost nodes in the graph.
type FCirclePostMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	link          *string
	created       *time.Time
	updated       *time.Time
	author        *string
	avatar        *string
	friend_link   *string
	crawled_at    *time.Time
	rules         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FCirclePost, error)
	predicates    []predicate.FCirclePost
}

var _ ent.Mutation = (*FCirclePostMutation)(nil)

// fcirclepostOption allows management of the mutation configuration using functional options.
type fcirclepostOption func(*FCirclePostMutation)

// newFCirclePostMutation creates new mutation for the FCirclePost entity.
func newFCirclePostMutation(c config, op Op, opts ...fcirclepostOption) *FCirclePostMutation {
	m := &FCirclePostMutation{
		config:        c,
		op:            op,
		typ:           TypeFCirclePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFCirclePostID sets the ID field of the mutation.
func withFCirclePostID(id int) fcirclepostOption {
	return func(m *FCirclePostMutation) {
		var (
			err   error
			once  sync.Once
			value *FCirclePost
		)
		m.oldValue = func(ctx context.Context) (*FCirclePost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FCirclePost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFCirclePost sets the old FCirclePost of the mutation.
func withFCirclePost(node *FCirclePost) fcirclepostOption {
	return func(m *FCirclePostMutation) {
		m.oldValue = func(context.Context) (*FCirclePost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FCirclePostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FCirclePostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FCirclePostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FCirclePostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FCirclePost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *FCirclePostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FCirclePostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *FCirclePostMutation) ResetTitle() {
	m.title = nil
}

// SetLink sets the "link" field.
func (m *FCirclePostMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FCirclePostMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *FCirclePostMutation) ResetLink() {
	m.link = nil
}

// SetCreated sets the "created" field.
func (m *FCirclePostMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *FCirclePostMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *FCirclePostMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[fcirclepost.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *FCirclePostMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[fcirclepost.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *FCirclePostMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, fcirclepost.FieldCreated)
}

// SetUpdated sets the "updated" field.
func (m *FCirclePostMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *FCirclePostMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *FCirclePostMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[fcirclepost.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *FCirclePostMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[fcirclepost.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *FCirclePostMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, fcirclepost.FieldUpdated)
}

// SetAuthor sets the "author" field.
func (m *FCirclePostMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *FCirclePostMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *FCirclePostMutation) ResetAuthor() {
	m.author = nil
}

// SetAvatar sets the "avatar" field.
func (m *FCirclePostMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *FCirclePostMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *FCirclePostMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[fcirclepost.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *FCirclePostMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[fcirclepost.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *FCirclePostMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, fcirclepost.FieldAvatar)
}

// SetFriendLink sets the "friend_link" field.
func (m *FCirclePostMutation) SetFriendLink(s string) {
	m.friend_link = &s
}

// FriendLink returns the value of the "friend_link" field in the mutation.
func (m *FCirclePostMutation) FriendLink() (r string, exists bool) {
	v := m.friend_link
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendLink returns the old "friend_link" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldFriendLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendLink: %w", err)
	}
	return oldValue.FriendLink, nil
}

// ResetFriendLink resets all changes to the "friend_link" field.
func (m *FCirclePostMutation) ResetFriendLink() {
	m.friend_link = nil
}

// SetCrawledAt sets the "crawled_at" field.
func (m *FCirclePostMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *FCirclePostMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldCrawledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *FCirclePostMutation) ResetCrawledAt() {
	m.crawled_at = nil
}

// SetRules sets the "rules" field.
func (m *FCirclePostMutation) SetRules(s string) {
	m.rules = &s
}

// Rules returns the value of the "rules" field in the mutation.
func (m *FCirclePostMutation) Rules() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the FCirclePost entity.
// If the FCirclePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCirclePostMutation) OldRules(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// ClearRules clears the value of the "rules" field.
func (m *FCirclePostMutation) ClearRules() {
	m.rules = nil
	m.clearedFields[fcirclepost.FieldRules] = struct{}{}
}

// RulesCleared returns if the "rules" field was cleared in this mutation.
func (m *FCirclePostMutation) RulesCleared() bool {
	_, ok := m.clearedFields[fcirclepost.FieldRules]
	return ok
}

// ResetRules resets all changes to the "rules" field.
func (m *FCirclePostMutation) ResetRules() {
	m.rules = nil
	delete(m.clearedFields, fcirclepost.FieldRules)
}

// Where appends a list predicates to the FCirclePostMutation builder.
func (m *FCirclePostMutation) Where(ps ...predicate.FCirclePost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FCirclePostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FCirclePostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FCirclePost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FCirclePostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FCirclePostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FCirclePost).
func (m *FCirclePostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FCirclePostMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, fcirclepost.FieldTitle)
	}
	if m.link != nil {
		fields = append(fields, fcirclepost.FieldLink)
	}
	if m.created != nil {
		fields = append(fields, fcirclepost.FieldCreated)
	}
	if m.updated != nil {
		fields = append(fields, fcirclepost.FieldUpdated)
	}
	if m.author != nil {
		fields = append(fields, fcirclepost.FieldAuthor)
	}
	if m.avatar != nil {
		fields = append(fields, fcirclepost.FieldAvatar)
	}
	if m.friend_link != nil {
		fields = append(fields, fcirclepost.FieldFriendLink)
	}
	if m.crawled_at != nil {
		fields = append(fields, fcirclepost.FieldCrawledAt)
	}
	if m.rules != nil {
		fields = append(fields, fcirclepost.FieldRules)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FCirclePostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fcirclepost.FieldTitle:
		return m.Title()
	case fcirclepost.FieldLink:
		return m.Link()
	case fcirclepost.FieldCreated:
		return m.Created()
	case fcirclepost.FieldUpdated:
		return m.Updated()
	case fcirclepost.FieldAuthor:
		return m.Author()
	case fcirclepost.FieldAvatar:
		return m.Avatar()
	case fcirclepost.FieldFriendLink:
		return m.FriendLink()
	case fcirclepost.FieldCrawledAt:
		return m.CrawledAt()
	case fcirclepost.FieldRules:
		return m.Rules()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FCirclePostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fcirclepost.FieldTitle:
		return m.OldTitle(ctx)
	case fcirclepost.FieldLink:
		return m.OldLink(ctx)
	case fcirclepost.FieldCreated:
		return m.OldCreated(ctx)
	case fcirclepost.FieldUpdated:
		return m.OldUpdated(ctx)
	case fcirclepost.FieldAuthor:
		return m.OldAuthor(ctx)
	case fcirclepost.FieldAvatar:
		return m.OldAvatar(ctx)
	case fcirclepost.FieldFriendLink:
		return m.OldFriendLink(ctx)
	case fcirclepost.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	case fcirclepost.FieldRules:
		return m.OldRules(ctx)
	}
	return nil, fmt.Errorf("unknown FCirclePost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FCirclePostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fcirclepost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case fcirclepost.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case fcirclepost.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case fcirclepost.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case fcirclepost.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case fcirclepost.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case fcirclepost.FieldFriendLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendLink(v)
		return nil
	case fcirclepost.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	case fcirclepost.FieldRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	}
	return fmt.Errorf("unknown FCirclePost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FCirclePostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FCirclePostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FCirclePostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FCirclePost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FCirclePostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fcirclepost.FieldCreated) {
		fields = append(fields, fcirclepost.FieldCreated)
	}
	if m.FieldCleared(fcirclepost.FieldUpdated) {
		fields = append(fields, fcirclepost.FieldUpdated)
	}
	if m.FieldCleared(fcirclepost.FieldAvatar) {
		fields = append(fields, fcirclepost.FieldAvatar)
	}
	if m.FieldCleared(fcirclepost.FieldRules) {
		fields = append(fields, fcirclepost.FieldRules)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FCirclePostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FCirclePostMutation) ClearField(name string) error {
	switch name {
	case fcirclepost.FieldCreated:
		m.ClearCreated()
		return nil
	case fcirclepost.FieldUpdated:
		m.ClearUpdated()
		return nil
	case fcirclepost.FieldAvatar:
		m.ClearAvatar()
		return nil
	case fcirclepost.FieldRules:
		m.ClearRules()
		return nil
	}
	return fmt.Errorf("unknown FCirclePost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FCirclePostMutation) ResetField(name string) error {
	switch name {
	case fcirclepost.FieldTitle:
		m.ResetTitle()
		return nil
	case fcirclepost.FieldLink:
		m.ResetLink()
		return nil
	case fcirclepost.FieldCreated:
		m.ResetCreated()
		return nil
	case fcirclepost.FieldUpdated:
		m.ResetUpdated()
		return nil
	case fcirclepost.FieldAuthor:
		m.ResetAuthor()
		return nil
	case fcirclepost.FieldAvatar:
		m.ResetAvatar()
		return nil
	case fcirclepost.FieldFriendLink:
		m.ResetFriendLink()
		return nil
	case fcirclepost.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	case fcirclepost.FieldRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown FCirclePost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FCirclePostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FCirclePostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FCirclePostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FCirclePostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FCirclePostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FCirclePostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FCirclePostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FCirclePost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FCirclePostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FCirclePost edge %s", name)
}

// FCircleStatisticMutation represents an operation that mutates the FCircleStatistic nodes in the graph.
type FCircleStatisticMutation struct {
	config
	op                Op
	typ               string
	id                *int
	friends_num       *int
	addfriends_num    *int
	active_num        *int
	addactive_num     *int
	error_num         *int
	adderror_num      *int
	article_num       *int
	addarticle_num    *int
	last_updated_time *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*FCircleStatistic, error)
	predicates        []predicate.FCircleStatistic
}

var _ ent.Mutation = (*FCircleStatisticMutation)(nil)

// fcirclestatisticOption allows management of the mutation configuration using functional options.
type fcirclestatisticOption func(*FCircleStatisticMutation)

// newFCircleStatisticMutation creates new mutation for the FCircleStatistic entity.
func newFCircleStatisticMutation(c config, op Op, opts ...fcirclestatisticOption) *FCircleStatisticMutation {
	m := &FCircleStatisticMutation{
		config:        c,
		op:            op,
		typ:           TypeFCircleStatistic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFCircleStatisticID sets the ID field of the mutation.
func withFCircleStatisticID(id int) fcirclestatisticOption {
	return func(m *FCircleStatisticMutation) {
		var (
			err   error
			once  sync.Once
			value *FCircleStatistic
		)
		m.oldValue = func(ctx context.Context) (*FCircleStatistic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FCircleStatistic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFCircleStatistic sets the old FCircleStatistic of the mutation.
func withFCircleStatistic(node *FCircleStatistic) fcirclestatisticOption {
	return func(m *FCircleStatisticMutation) {
		m.oldValue = func(context.Context) (*FCircleStatistic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FCircleStatisticMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FCircleStatisticMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FCircleStatisticMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FCircleStatisticMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FCircleStatistic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFriendsNum sets the "friends_num" field.
func (m *FCircleStatisticMutation) SetFriendsNum(i int) {
	m.friends_num = &i
	m.addfriends_num = nil
}

// FriendsNum returns the value of the "friends_num" field in the mutation.
func (m *FCircleStatisticMutation) FriendsNum() (r int, exists bool) {
	v := m.friends_num
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendsNum returns the old "friends_num" field's value of the FCircleStatistic entity.
// If the FCircleStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCircleStatisticMutation) OldFriendsNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendsNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendsNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendsNum: %w", err)
	}
	return oldValue.FriendsNum, nil
}

// AddFriendsNum adds i to the "friends_num" field.
func (m *FCircleStatisticMutation) AddFriendsNum(i int) {
	if m.addfriends_num != nil {
		*m.addfriends_num += i
	} else {
		m.addfriends_num = &i
	}
}

// AddedFriendsNum returns the value that was added to the "friends_num" field in this mutation.
func (m *FCircleStatisticMutation) AddedFriendsNum() (r int, exists bool) {
	v := m.addfriends_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetFriendsNum resets all changes to the "friends_num" field.
func (m *FCircleStatisticMutation) ResetFriendsNum() {
	m.friends_num = nil
	m.addfriends_num = nil
}

// SetActiveNum sets the "active_num" field.
func (m *FCircleStatisticMutation) SetActiveNum(i int) {
	m.active_num = &i
	m.addactive_num = nil
}

// ActiveNum returns the value of the "active_num" field in the mutation.
func (m *FCircleStatisticMutation) ActiveNum() (r int, exists bool) {
	v := m.active_num
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveNum returns the old "active_num" field's value of the FCircleStatistic entity.
// If the FCircleStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCircleStatisticMutation) OldActiveNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveNum: %w", err)
	}
	return oldValue.ActiveNum, nil
}

// AddActiveNum adds i to the "active_num" field.
func (m *FCircleStatisticMutation) AddActiveNum(i int) {
	if m.addactive_num != nil {
		*m.addactive_num += i
	} else {
		m.addactive_num = &i
	}
}

// AddedActiveNum returns the value that was added to the "active_num" field in this mutation.
func (m *FCircleStatisticMutation) AddedActiveNum() (r int, exists bool) {
	v := m.addactive_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetActiveNum resets all changes to the "active_num" field.
func (m *FCircleStatisticMutation) ResetActiveNum() {
	m.active_num = nil
	m.addactive_num = nil
}

// SetErrorNum sets the "error_num" field.
func (m *FCircleStatisticMutation) SetErrorNum(i int) {
	m.error_num = &i
	m.adderror_num = nil
}

// ErrorNum returns the value of the "error_num" field in the mutation.
func (m *FCircleStatisticMutation) ErrorNum() (r int, exists bool) {
	v := m.error_num
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorNum returns the old "error_num" field's value of the FCircleStatistic entity.
// If the FCircleStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCircleStatisticMutation) OldErrorNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorNum: %w", err)
	}
	return oldValue.ErrorNum, nil
}

// AddErrorNum adds i to the "error_num" field.
func (m *FCircleStatisticMutation) AddErrorNum(i int) {
	if m.adderror_num != nil {
		*m.adderror_num += i
	} else {
		m.adderror_num = &i
	}
}

// AddedErrorNum returns the value that was added to the "error_num" field in this mutation.
func (m *FCircleStatisticMutation) AddedErrorNum() (r int, exists bool) {
	v := m.adderror_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorNum resets all changes to the "error_num" field.
func (m *FCircleStatisticMutation) ResetErrorNum() {
	m.error_num = nil
	m.adderror_num = nil
}

// SetArticleNum sets the "article_num" field.
func (m *FCircleStatisticMutation) SetArticleNum(i int) {
	m.article_num = &i
	m.addarticle_num = nil
}

// ArticleNum returns the value of the "article_num" field in the mutation.
func (m *FCircleStatisticMutation) ArticleNum() (r int, exists bool) {
	v := m.article_num
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleNum returns the old "article_num" field's value of the FCircleStatistic entity.
// If the FCircleStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCircleStatisticMutation) OldArticleNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleNum: %w", err)
	}
	return oldValue.ArticleNum, nil
}

// AddArticleNum adds i to the "article_num" field.
func (m *FCircleStatisticMutation) AddArticleNum(i int) {
	if m.addarticle_num != nil {
		*m.addarticle_num += i
	} else {
		m.addarticle_num = &i
	}
}

// AddedArticleNum returns the value that was added to the "article_num" field in this mutation.
func (m *FCircleStatisticMutation) AddedArticleNum() (r int, exists bool) {
	v := m.addarticle_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetArticleNum resets all changes to the "article_num" field.
func (m *FCircleStatisticMutation) ResetArticleNum() {
	m.article_num = nil
	m.addarticle_num = nil
}

// SetLastUpdatedTime sets the "last_updated_time" field.
func (m *FCircleStatisticMutation) SetLastUpdatedTime(t time.Time) {
	m.last_updated_time = &t
}

// LastUpdatedTime returns the value of the "last_updated_time" field in the mutation.
func (m *FCircleStatisticMutation) LastUpdatedTime() (r time.Time, exists bool) {
	v := m.last_updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdatedTime returns the old "last_updated_time" field's value of the FCircleStatistic entity.
// If the FCircleStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCircleStatisticMutation) OldLastUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdatedTime: %w", err)
	}
	return oldValue.LastUpdatedTime, nil
}

// ResetLastUpdatedTime resets all changes to the "last_updated_time" field.
func (m *FCircleStatisticMutation) ResetLastUpdatedTime() {
	m.last_updated_time = nil
}

// Where appends a list predicates to the FCircleStatisticMutation builder.
func (m *FCircleStatisticMutation) Where(ps ...predicate.FCircleStatistic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FCircleStatisticMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FCircleStatisticMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FCircleStatistic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FCircleStatisticMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FCircleStatisticMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FCircleStatistic).
func (m *FCircleStatisticMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FCircleStatisticMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.friends_num != nil {
		fields = append(fields, fcirclestatistic.FieldFriendsNum)
	}
	if m.active_num != nil {
		fields = append(fields, fcirclestatistic.FieldActiveNum)
	}
	if m.error_num != nil {
		fields = append(fields, fcirclestatistic.FieldErrorNum)
	}
	if m.article_num != nil {
		fields = append(fields, fcirclestatistic.FieldArticleNum)
	}
	if m.last_updated_time != nil {
		fields = append(fields, fcirclestatistic.FieldLastUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FCircleStatisticMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fcirclestatistic.FieldFriendsNum:
		return m.FriendsNum()
	case fcirclestatistic.FieldActiveNum:
		return m.ActiveNum()
	case fcirclestatistic.FieldErrorNum:
		return m.ErrorNum()
	case fcirclestatistic.FieldArticleNum:
		return m.ArticleNum()
	case fcirclestatistic.FieldLastUpdatedTime:
		return m.LastUpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FCircleStatisticMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fcirclestatistic.FieldFriendsNum:
		return m.OldFriendsNum(ctx)
	case fcirclestatistic.FieldActiveNum:
		return m.OldActiveNum(ctx)
	case fcirclestatistic.FieldErrorNum:
		return m.OldErrorNum(ctx)
	case fcirclestatistic.FieldArticleNum:
		return m.OldArticleNum(ctx)
	case fcirclestatistic.FieldLastUpdatedTime:
		return m.OldLastUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FCircleStatistic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FCircleStatisticMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fcirclestatistic.FieldFriendsNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendsNum(v)
		return nil
	case fcirclestatistic.FieldActiveNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveNum(v)
		return nil
	case fcirclestatistic.FieldErrorNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorNum(v)
		return nil
	case fcirclestatistic.FieldArticleNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleNum(v)
		return nil
	case fcirclestatistic.FieldLastUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FCircleStatistic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FCircleStatisticMutation) AddedFields() []string {
	var fields []string
	if m.addfriends_num != nil {
		fields = append(fields, fcirclestatistic.FieldFriendsNum)
	}
	if m.addactive_num != nil {
		fields = append(fields, fcirclestatistic.FieldActiveNum)
	}
	if m.adderror_num != nil {
		fields = append(fields, fcirclestatistic.FieldErrorNum)
	}
	if m.addarticle_num != nil {
		fields = append(fields, fcirclestatistic.FieldArticleNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FCircleStatisticMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fcirclestatistic.FieldFriendsNum:
		return m.AddedFriendsNum()
	case fcirclestatistic.FieldActiveNum:
		return m.AddedActiveNum()
	case fcirclestatistic.FieldErrorNum:
		return m.AddedErrorNum()
	case fcirclestatistic.FieldArticleNum:
		return m.AddedArticleNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FCircleStatisticMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fcirclestatistic.FieldFriendsNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFriendsNum(v)
		return nil
	case fcirclestatistic.FieldActiveNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActiveNum(v)
		return nil
	case fcirclestatistic.FieldErrorNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorNum(v)
		return nil
	case fcirclestatistic.FieldArticleNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArticleNum(v)
		return nil
	}
	return fmt.Errorf("unknown FCircleStatistic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FCircleStatisticMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FCircleStatisticMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FCircleStatisticMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FCircleStatistic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FCircleStatisticMutation) ResetField(name string) error {
	switch name {
	case fcirclestatistic.FieldFriendsNum:
		m.ResetFriendsNum()
		return nil
	case fcirclestatistic.FieldActiveNum:
		m.ResetActiveNum()
		return nil
	case fcirclestatistic.FieldErrorNum:
		m.ResetErrorNum()
		return nil
	case fcirclestatistic.FieldArticleNum:
		m.ResetArticleNum()
		return nil
	case fcirclestatistic.FieldLastUpdatedTime:
		m.ResetLastUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FCircleStatistic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FCircleStatisticMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FCircleStatisticMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FCircleStatisticMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FCircleStatisticMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FCircleStatisticMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FCircleStatisticMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FCircleStatisticMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FCircleStatistic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FCircleStatisticMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FCircleStatistic edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint
	deleted_at            *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	_type                 *int
	add_type              *int
	name                  *string
	size                  *int64
	addsize               *int64
	children_count        *int64
	addchildren_count     *int64
	view_config           *string
	clearedFields         map[string]struct{}
	owner                 *uint
	clearedowner          bool
	parent                *uint
	clearedparent         bool
	children              map[uint]struct{}
	removedchildren       map[uint]struct{}
	clearedchildren       bool
	primary_entity        *uint
	clearedprimary_entity bool
	versions              map[uint]struct{}
	removedversions       map[uint]struct{}
	clearedversions       bool
	direct_link           *uint
	cleareddirect_link    bool
	metadata              map[uint]struct{}
	removedmetadata       map[uint]struct{}
	clearedmetadata       bool
	done                  bool
	oldValue              func(context.Context) (*File, error)
	predicates            []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uint) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *FileMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *FileMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *FileMutation) SetOwnerID(u uint) {
	m.owner = &u
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FileMutation) OwnerID() (r uint, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOwnerID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FileMutation) ResetOwnerID() {
	m.owner = nil
}

// SetParentID sets the "parent_id" field.
func (m *FileMutation) SetParentID(u uint) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *FileMutation) ParentID() (r uint, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldParentID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *FileMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[file.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *FileMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[file.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *FileMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, file.FieldParentID)
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPrimaryEntityID sets the "primary_entity_id" field.
func (m *FileMutation) SetPrimaryEntityID(u uint) {
	m.primary_entity = &u
}

// PrimaryEntityID returns the value of the "primary_entity_id" field in the mutation.
func (m *FileMutation) PrimaryEntityID() (r uint, exists bool) {
	v := m.primary_entity
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryEntityID returns the old "primary_entity_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPrimaryEntityID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryEntityID: %w", err)
	}
	return oldValue.PrimaryEntityID, nil
}

// ClearPrimaryEntityID clears the value of the "primary_entity_id" field.
func (m *FileMutation) ClearPrimaryEntityID() {
	m.primary_entity = nil
	m.clearedFields[file.FieldPrimaryEntityID] = struct{}{}
}

// PrimaryEntityIDCleared returns if the "primary_entity_id" field was cleared in this mutation.
func (m *FileMutation) PrimaryEntityIDCleared() bool {
	_, ok := m.clearedFields[file.FieldPrimaryEntityID]
	return ok
}

// ResetPrimaryEntityID resets all changes to the "primary_entity_id" field.
func (m *FileMutation) ResetPrimaryEntityID() {
	m.primary_entity = nil
	delete(m.clearedFields, file.FieldPrimaryEntityID)
}

// SetChildrenCount sets the "children_count" field.
func (m *FileMutation) SetChildrenCount(i int64) {
	m.children_count = &i
	m.addchildren_count = nil
}

// ChildrenCount returns the value of the "children_count" field in the mutation.
func (m *FileMutation) ChildrenCount() (r int64, exists bool) {
	v := m.children_count
	if v == nil {
		return
	}
	return *v, true
}

// OldChildrenCount returns the old "children_count" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldChildrenCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildrenCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildrenCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildrenCount: %w", err)
	}
	return oldValue.ChildrenCount, nil
}

// AddChildrenCount adds i to the "children_count" field.
func (m *FileMutation) AddChildrenCount(i int64) {
	if m.addchildren_count != nil {
		*m.addchildren_count += i
	} else {
		m.addchildren_count = &i
	}
}

// AddedChildrenCount returns the value that was added to the "children_count" field in this mutation.
func (m *FileMutation) AddedChildrenCount() (r int64, exists bool) {
	v := m.addchildren_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildrenCount resets all changes to the "children_count" field.
func (m *FileMutation) ResetChildrenCount() {
	m.children_count = nil
	m.addchildren_count = nil
}

// SetViewConfig sets the "view_config" field.
func (m *FileMutation) SetViewConfig(s string) {
	m.view_config = &s
}

// ViewConfig returns the value of the "view_config" field in the mutation.
func (m *FileMutation) ViewConfig() (r string, exists bool) {
	v := m.view_config
	if v == nil {
		return
	}
	return *v, true
}

// OldViewConfig returns the old "view_config" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldViewConfig(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewConfig: %w", err)
	}
	return oldValue.ViewConfig, nil
}

// ClearViewConfig clears the value of the "view_config" field.
func (m *FileMutation) ClearViewConfig() {
	m.view_config = nil
	m.clearedFields[file.FieldViewConfig] = struct{}{}
}

// ViewConfigCleared returns if the "view_config" field was cleared in this mutation.
func (m *FileMutation) ViewConfigCleared() bool {
	_, ok := m.clearedFields[file.FieldViewConfig]
	return ok
}

// ResetViewConfig resets all changes to the "view_config" field.
func (m *FileMutation) ResetViewConfig() {
	m.view_config = nil
	delete(m.clearedFields, file.FieldViewConfig)
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FileMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[file.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) OwnerIDs() (ids []uint) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearParent clears the "parent" edge to the File entity.
func (m *FileMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[file.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the File entity was cleared.
func (m *FileMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ParentIDs() (ids []uint) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FileMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the File entity by ids.
func (m *FileMutation) AddChildIDs(ids ...uint) {
	if m.children == nil {
		m.children = make(map[uint]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the File entity.
func (m *FileMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the File entity was cleared.
func (m *FileMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the File entity by IDs.
func (m *FileMutation) RemoveChildIDs(ids ...uint) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the File entity.
func (m *FileMutation) RemovedChildrenIDs() (ids []uint) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FileMutation) ChildrenIDs() (ids []uint) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FileMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearPrimaryEntity clears the "primary_entity" edge to the Entity entity.
func (m *FileMutation) ClearPrimaryEntity() {
	m.clearedprimary_entity = true
	m.clearedFields[file.FieldPrimaryEntityID] = struct{}{}
}

// PrimaryEntityCleared reports if the "primary_entity" edge to the Entity entity was cleared.
func (m *FileMutation) PrimaryEntityCleared() bool {
	return m.PrimaryEntityIDCleared() || m.clearedprimary_entity
}

// PrimaryEntityIDs returns the "primary_entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryEntityID instead. It exists only for internal usage by the builders.
func (m *FileMutation) PrimaryEntityIDs() (ids []uint) {
	if id := m.primary_entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryEntity resets all changes to the "primary_entity" edge.
func (m *FileMutation) ResetPrimaryEntity() {
	m.primary_entity = nil
	m.clearedprimary_entity = false
}

// AddVersionIDs adds the "versions" edge to the FileEntity entity by ids.
func (m *FileMutation) AddVersionIDs(ids ...uint) {
	if m.versions == nil {
		m.versions = make(map[uint]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the FileEntity entity.
func (m *FileMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the FileEntity entity was cleared.
func (m *FileMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the FileEntity entity by IDs.
func (m *FileMutation) RemoveVersionIDs(ids ...uint) {
	if m.removedversions == nil {
		m.removedversions = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the FileEntity entity.
func (m *FileMutation) RemovedVersionsIDs() (ids []uint) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *FileMutation) VersionsIDs() (ids []uint) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *FileMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// SetDirectLinkID sets the "direct_link" edge to the DirectLink entity by id.
func (m *FileMutation) SetDirectLinkID(id uint) {
	m.direct_link = &id
}

// ClearDirectLink clears the "direct_link" edge to the DirectLink entity.
func (m *FileMutation) ClearDirectLink() {
	m.cleareddirect_link = true
}

// DirectLinkCleared reports if the "direct_link" edge to the DirectLink entity was cleared.
func (m *FileMutation) DirectLinkCleared() bool {
	return m.cleareddirect_link
}

// DirectLinkID returns the "direct_link" edge ID in the mutation.
func (m *FileMutation) DirectLinkID() (id uint, exists bool) {
	if m.direct_link != nil {
		return *m.direct_link, true
	}
	return
}

// DirectLinkIDs returns the "direct_link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DirectLinkID instead. It exists only for internal usage by the builders.
func (m *FileMutation) DirectLinkIDs() (ids []uint) {
	if id := m.direct_link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDirectLink resets all changes to the "direct_link" edge.
func (m *FileMutation) ResetDirectLink() {
	m.direct_link = nil
	m.cleareddirect_link = false
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *FileMutation) AddMetadatumIDs(ids ...uint) {
	if m.metadata == nil {
		m.metadata = make(map[uint]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *FileMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *FileMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *FileMutation) RemoveMetadatumIDs(ids ...uint) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *FileMutation) RemovedMetadataIDs() (ids []uint) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *FileMutation) MetadataIDs() (ids []uint) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *FileMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.owner != nil {
		fields = append(fields, file.FieldOwnerID)
	}
	if m.parent != nil {
		fields = append(fields, file.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.primary_entity != nil {
		fields = append(fields, file.FieldPrimaryEntityID)
	}
	if m.children_count != nil {
		fields = append(fields, file.FieldChildrenCount)
	}
	if m.view_config != nil {
		fields = append(fields, file.FieldViewConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldType:
		return m.GetType()
	case file.FieldOwnerID:
		return m.OwnerID()
	case file.FieldParentID:
		return m.ParentID()
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldPrimaryEntityID:
		return m.PrimaryEntityID()
	case file.FieldChildrenCount:
		return m.ChildrenCount()
	case file.FieldViewConfig:
		return m.ViewConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case file.FieldParentID:
		return m.OldParentID(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPrimaryEntityID:
		return m.OldPrimaryEntityID(ctx)
	case file.FieldChildrenCount:
		return m.OldChildrenCount(ctx)
	case file.FieldViewConfig:
		return m.OldViewConfig(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldOwnerID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case file.FieldParentID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPrimaryEntityID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryEntityID(v)
		return nil
	case file.FieldChildrenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildrenCount(v)
		return nil
	case file.FieldViewConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewConfig(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.addchildren_count != nil {
		fields = append(fields, file.FieldChildrenCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldType:
		return m.AddedType()
	case file.FieldSize:
		return m.AddedSize()
	case file.FieldChildrenCount:
		return m.AddedChildrenCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case file.FieldChildrenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildrenCount(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.FieldCleared(file.FieldParentID) {
		fields = append(fields, file.FieldParentID)
	}
	if m.FieldCleared(file.FieldPrimaryEntityID) {
		fields = append(fields, file.FieldPrimaryEntityID)
	}
	if m.FieldCleared(file.FieldViewConfig) {
		fields = append(fields, file.FieldViewConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case file.FieldParentID:
		m.ClearParentID()
		return nil
	case file.FieldPrimaryEntityID:
		m.ClearPrimaryEntityID()
		return nil
	case file.FieldViewConfig:
		m.ClearViewConfig()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case file.FieldParentID:
		m.ResetParentID()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPrimaryEntityID:
		m.ResetPrimaryEntityID()
		return nil
	case file.FieldChildrenCount:
		m.ResetChildrenCount()
		return nil
	case file.FieldViewConfig:
		m.ResetViewConfig()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.owner != nil {
		edges = append(edges, file.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, file.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.primary_entity != nil {
		edges = append(edges, file.EdgePrimaryEntity)
	}
	if m.versions != nil {
		edges = append(edges, file.EdgeVersions)
	}
	if m.direct_link != nil {
		edges = append(edges, file.EdgeDirectLink)
	}
	if m.metadata != nil {
		edges = append(edges, file.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case file.EdgePrimaryEntity:
		if id := m.primary_entity; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeDirectLink:
		if id := m.direct_link; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.removedversions != nil {
		edges = append(edges, file.EdgeVersions)
	}
	if m.removedmetadata != nil {
		edges = append(edges, file.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedowner {
		edges = append(edges, file.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, file.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, file.EdgeChildren)
	}
	if m.clearedprimary_entity {
		edges = append(edges, file.EdgePrimaryEntity)
	}
	if m.clearedversions {
		edges = append(edges, file.EdgeVersions)
	}
	if m.cleareddirect_link {
		edges = append(edges, file.EdgeDirectLink)
	}
	if m.clearedmetadata {
		edges = append(edges, file.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOwner:
		return m.clearedowner
	case file.EdgeParent:
		return m.clearedparent
	case file.EdgeChildren:
		return m.clearedchildren
	case file.EdgePrimaryEntity:
		return m.clearedprimary_entity
	case file.EdgeVersions:
		return m.clearedversions
	case file.EdgeDirectLink:
		return m.cleareddirect_link
	case file.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ClearOwner()
		return nil
	case file.EdgeParent:
		m.ClearParent()
		return nil
	case file.EdgePrimaryEntity:
		m.ClearPrimaryEntity()
		return nil
	case file.EdgeDirectLink:
		m.ClearDirectLink()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ResetOwner()
		return nil
	case file.EdgeParent:
		m.ResetParent()
		return nil
	case file.EdgeChildren:
		m.ResetChildren()
		return nil
	case file.EdgePrimaryEntity:
		m.ResetPrimaryEntity()
		return nil
	case file.EdgeVersions:
		m.ResetVersions()
		return nil
	case file.EdgeDirectLink:
		m.ResetDirectLink()
		return nil
	case file.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FileEntityMutation represents an operation that mutates the FileEntity nodes in the graph.
type FileEntityMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint
	deleted_at             *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	version                *string
	is_current             *bool
	uploaded_by_user_id    *uint64
	adduploaded_by_user_id *int64
	clearedFields          map[string]struct{}
	file                   *uint
	clearedfile            bool
	entity                 *uint
	clearedentity          bool
	done                   bool
	oldValue               func(context.Context) (*FileEntity, error)
	predicates             []predicate.FileEntity
}

var _ ent.Mutation = (*FileEntityMutation)(nil)

// fileentityOption allows management of the mutation configuration using functional options.
type fileentityOption func(*FileEntityMutation)

// newFileEntityMutation creates new mutation for the FileEntity entity.
func newFileEntityMutation(c config, op Op, opts ...fileentityOption) *FileEntityMutation {
	m := &FileEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeFileEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileEntityID sets the ID field of the mutation.
func withFileEntityID(id uint) fileentityOption {
	return func(m *FileEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *FileEntity
		)
		m.oldValue = func(ctx context.Context) (*FileEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileEntity sets the old FileEntity of the mutation.
func withFileEntity(node *FileEntity) fileentityOption {
	return func(m *FileEntityMutation) {
		m.oldValue = func(context.Context) (*FileEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileEntity entities.
func (m *FileEntityMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileEntityMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileEntityMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileEntityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileEntityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileEntityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[fileentity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileEntityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[fileentity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileEntityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, fileentity.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *FileEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFileID sets the "file_id" field.
func (m *FileEntityMutation) SetFileID(u uint) {
	m.file = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *FileEntityMutation) FileID() (r uint, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldFileID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *FileEntityMutation) ResetFileID() {
	m.file = nil
}

// SetEntityID sets the "entity_id" field.
func (m *FileEntityMutation) SetEntityID(u uint) {
	m.entity = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *FileEntityMutation) EntityID() (r uint, exists bool) {
	v := m.entity
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldEntityID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *FileEntityMutation) ResetEntityID() {
	m.entity = nil
}

// SetVersion sets the "version" field.
func (m *FileEntityMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *FileEntityMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *FileEntityMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[fileentity.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *FileEntityMutation) VersionCleared() bool {
	_, ok := m.clearedFields[fileentity.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *FileEntityMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, fileentity.FieldVersion)
}

// SetIsCurrent sets the "is_current" field.
func (m *FileEntityMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *FileEntityMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *FileEntityMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetUploadedByUserID sets the "uploaded_by_user_id" field.
func (m *FileEntityMutation) SetUploadedByUserID(u uint64) {
	m.uploaded_by_user_id = &u
	m.adduploaded_by_user_id = nil
}

// UploadedByUserID returns the value of the "uploaded_by_user_id" field in the mutation.
func (m *FileEntityMutation) UploadedByUserID() (r uint64, exists bool) {
	v := m.uploaded_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedByUserID returns the old "uploaded_by_user_id" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldUploadedByUserID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedByUserID: %w", err)
	}
	return oldValue.UploadedByUserID, nil
}

// AddUploadedByUserID adds u to the "uploaded_by_user_id" field.
func (m *FileEntityMutation) AddUploadedByUserID(u int64) {
	if m.adduploaded_by_user_id != nil {
		*m.adduploaded_by_user_id += u
	} else {
		m.adduploaded_by_user_id = &u
	}
}

// AddedUploadedByUserID returns the value that was added to the "uploaded_by_user_id" field in this mutation.
func (m *FileEntityMutation) AddedUploadedByUserID() (r int64, exists bool) {
	v := m.adduploaded_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUploadedByUserID clears the value of the "uploaded_by_user_id" field.
func (m *FileEntityMutation) ClearUploadedByUserID() {
	m.uploaded_by_user_id = nil
	m.adduploaded_by_user_id = nil
	m.clearedFields[fileentity.FieldUploadedByUserID] = struct{}{}
}

// UploadedByUserIDCleared returns if the "uploaded_by_user_id" field was cleared in this mutation.
func (m *FileEntityMutation) UploadedByUserIDCleared() bool {
	_, ok := m.clearedFields[fileentity.FieldUploadedByUserID]
	return ok
}

// ResetUploadedByUserID resets all changes to the "uploaded_by_user_id" field.
func (m *FileEntityMutation) ResetUploadedByUserID() {
	m.uploaded_by_user_id = nil
	m.adduploaded_by_user_id = nil
	delete(m.clearedFields, fileentity.FieldUploadedByUserID)
}

// ClearFile clears the "file" edge to the File entity.
func (m *FileEntityMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[fileentity.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *FileEntityMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *FileEntityMutation) FileIDs() (ids []uint) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *FileEntityMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *FileEntityMutation) ClearEntity() {
	m.clearedentity = true
	m.clearedFields[fileentity.FieldEntityID] = struct{}{}
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *FileEntityMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *FileEntityMutation) EntityIDs() (ids []uint) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *FileEntityMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the FileEntityMutation builder.
func (m *FileEntityMutation) Where(ps ...predicate.FileEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileEntity).
func (m *FileEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileEntityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.deleted_at != nil {
		fields = append(fields, fileentity.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, fileentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fileentity.FieldUpdatedAt)
	}
	if m.file != nil {
		fields = append(fields, fileentity.FieldFileID)
	}
	if m.entity != nil {
		fields = append(fields, fileentity.FieldEntityID)
	}
	if m.version != nil {
		fields = append(fields, fileentity.FieldVersion)
	}
	if m.is_current != nil {
		fields = append(fields, fileentity.FieldIsCurrent)
	}
	if m.uploaded_by_user_id != nil {
		fields = append(fields, fileentity.FieldUploadedByUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileentity.FieldDeletedAt:
		return m.DeletedAt()
	case fileentity.FieldCreatedAt:
		return m.CreatedAt()
	case fileentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case fileentity.FieldFileID:
		return m.FileID()
	case fileentity.FieldEntityID:
		return m.EntityID()
	case fileentity.FieldVersion:
		return m.Version()
	case fileentity.FieldIsCurrent:
		return m.IsCurrent()
	case fileentity.FieldUploadedByUserID:
		return m.UploadedByUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileentity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case fileentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fileentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fileentity.FieldFileID:
		return m.OldFileID(ctx)
	case fileentity.FieldEntityID:
		return m.OldEntityID(ctx)
	case fileentity.FieldVersion:
		return m.OldVersion(ctx)
	case fileentity.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case fileentity.FieldUploadedByUserID:
		return m.OldUploadedByUserID(ctx)
	}
	return nil, fmt.Errorf("unknown FileEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileentity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case fileentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fileentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fileentity.FieldFileID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case fileentity.FieldEntityID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case fileentity.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case fileentity.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case fileentity.FieldUploadedByUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedByUserID(v)
		return nil
	}
	return fmt.Errorf("unknown FileEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileEntityMutation) AddedFields() []string {
	var fields []string
	if m.adduploaded_by_user_id != nil {
		fields = append(fields, fileentity.FieldUploadedByUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fileentity.FieldUploadedByUserID:
		return m.AddedUploadedByUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fileentity.FieldUploadedByUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadedByUserID(v)
		return nil
	}
	return fmt.Errorf("unknown FileEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileEntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fileentity.FieldDeletedAt) {
		fields = append(fields, fileentity.FieldDeletedAt)
	}
	if m.FieldCleared(fileentity.FieldVersion) {
		fields = append(fields, fileentity.FieldVersion)
	}
	if m.FieldCleared(fileentity.FieldUploadedByUserID) {
		fields = append(fields, fileentity.FieldUploadedByUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileEntityMutation) ClearField(name string) error {
	switch name {
	case fileentity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case fileentity.FieldVersion:
		m.ClearVersion()
		return nil
	case fileentity.FieldUploadedByUserID:
		m.ClearUploadedByUserID()
		return nil
	}
	return fmt.Errorf("unknown FileEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileEntityMutation) ResetField(name string) error {
	switch name {
	case fileentity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case fileentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fileentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fileentity.FieldFileID:
		m.ResetFileID()
		return nil
	case fileentity.FieldEntityID:
		m.ResetEntityID()
		return nil
	case fileentity.FieldVersion:
		m.ResetVersion()
		return nil
	case fileentity.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case fileentity.FieldUploadedByUserID:
		m.ResetUploadedByUserID()
		return nil
	}
	return fmt.Errorf("unknown FileEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.file != nil {
		edges = append(edges, fileentity.EdgeFile)
	}
	if m.entity != nil {
		edges = append(edges, fileentity.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileentity.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case fileentity.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfile {
		edges = append(edges, fileentity.EdgeFile)
	}
	if m.clearedentity {
		edges = append(edges, fileentity.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case fileentity.EdgeFile:
		return m.clearedfile
	case fileentity.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileEntityMutation) ClearEdge(name string) error {
	switch name {
	case fileentity.EdgeFile:
		m.ClearFile()
		return nil
	case fileentity.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown FileEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileEntityMutation) ResetEdge(name string) error {
	switch name {
	case fileentity.EdgeFile:
		m.ResetFile()
		return nil
	case fileentity.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown FileEntity edge %s", name)
}

// GiveMoneyMutation represents an operation that mutates the GiveMoney nodes in the graph.
type GiveMoneyMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	nickname      *string
	figure        *int
	addfigure     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GiveMoney, error)
	predicates    []predicate.GiveMoney
}

var _ ent.Mutation = (*GiveMoneyMutation)(nil)

// givemoneyOption allows management of the mutation configuration using functional options.
type givemoneyOption func(*GiveMoneyMutation)

// newGiveMoneyMutation creates new mutation for the GiveMoney entity.
func newGiveMoneyMutation(c config, op Op, opts ...givemoneyOption) *GiveMoneyMutation {
	m := &GiveMoneyMutation{
		config:        c,
		op:            op,
		typ:           TypeGiveMoney,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGiveMoneyID sets the ID field of the mutation.
func withGiveMoneyID(id uint) givemoneyOption {
	return func(m *GiveMoneyMutation) {
		var (
			err   error
			once  sync.Once
			value *GiveMoney
		)
		m.oldValue = func(ctx context.Context) (*GiveMoney, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GiveMoney.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGiveMoney sets the old GiveMoney of the mutation.
func withGiveMoney(node *GiveMoney) givemoneyOption {
	return func(m *GiveMoneyMutation) {
		m.oldValue = func(context.Context) (*GiveMoney, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GiveMoneyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GiveMoneyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GiveMoney entities.
func (m *GiveMoneyMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GiveMoneyMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GiveMoneyMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GiveMoney.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GiveMoneyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GiveMoneyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GiveMoney entity.
// If the GiveMoney object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiveMoneyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GiveMoneyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[givemoney.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GiveMoneyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[givemoney.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GiveMoneyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, givemoney.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GiveMoneyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GiveMoneyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GiveMoney entity.
// If the GiveMoney object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiveMoneyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GiveMoneyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GiveMoneyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GiveMoneyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GiveMoney entity.
// If the GiveMoney object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiveMoneyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GiveMoneyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNickname sets the "nickname" field.
func (m *GiveMoneyMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *GiveMoneyMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the GiveMoney entity.
// If the GiveMoney object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiveMoneyMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *GiveMoneyMutation) ResetNickname() {
	m.nickname = nil
}

// SetFigure sets the "figure" field.
func (m *GiveMoneyMutation) SetFigure(i int) {
	m.figure = &i
	m.addfigure = nil
}

// Figure returns the value of the "figure" field in the mutation.
func (m *GiveMoneyMutation) Figure() (r int, exists bool) {
	v := m.figure
	if v == nil {
		return
	}
	return *v, true
}

// OldFigure returns the old "figure" field's value of the GiveMoney entity.
// If the GiveMoney object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiveMoneyMutation) OldFigure(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFigure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFigure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFigure: %w", err)
	}
	return oldValue.Figure, nil
}

// AddFigure adds i to the "figure" field.
func (m *GiveMoneyMutation) AddFigure(i int) {
	if m.addfigure != nil {
		*m.addfigure += i
	} else {
		m.addfigure = &i
	}
}

// AddedFigure returns the value that was added to the "figure" field in this mutation.
func (m *GiveMoneyMutation) AddedFigure() (r int, exists bool) {
	v := m.addfigure
	if v == nil {
		return
	}
	return *v, true
}

// ResetFigure resets all changes to the "figure" field.
func (m *GiveMoneyMutation) ResetFigure() {
	m.figure = nil
	m.addfigure = nil
}

// Where appends a list predicates to the GiveMoneyMutation builder.
func (m *GiveMoneyMutation) Where(ps ...predicate.GiveMoney) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GiveMoneyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GiveMoneyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GiveMoney, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GiveMoneyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GiveMoneyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GiveMoney).
func (m *GiveMoneyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GiveMoneyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, givemoney.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, givemoney.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, givemoney.FieldUpdatedAt)
	}
	if m.nickname != nil {
		fields = append(fields, givemoney.FieldNickname)
	}
	if m.figure != nil {
		fields = append(fields, givemoney.FieldFigure)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GiveMoneyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case givemoney.FieldDeletedAt:
		return m.DeletedAt()
	case givemoney.FieldCreatedAt:
		return m.CreatedAt()
	case givemoney.FieldUpdatedAt:
		return m.UpdatedAt()
	case givemoney.FieldNickname:
		return m.Nickname()
	case givemoney.FieldFigure:
		return m.Figure()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GiveMoneyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case givemoney.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case givemoney.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case givemoney.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case givemoney.FieldNickname:
		return m.OldNickname(ctx)
	case givemoney.FieldFigure:
		return m.OldFigure(ctx)
	}
	return nil, fmt.Errorf("unknown GiveMoney field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GiveMoneyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case givemoney.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case givemoney.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case givemoney.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case givemoney.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case givemoney.FieldFigure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFigure(v)
		return nil
	}
	return fmt.Errorf("unknown GiveMoney field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GiveMoneyMutation) AddedFields() []string {
	var fields []string
	if m.addfigure != nil {
		fields = append(fields, givemoney.FieldFigure)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GiveMoneyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case givemoney.FieldFigure:
		return m.AddedFigure()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GiveMoneyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case givemoney.FieldFigure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFigure(v)
		return nil
	}
	return fmt.Errorf("unknown GiveMoney numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GiveMoneyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(givemoney.FieldDeletedAt) {
		fields = append(fields, givemoney.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GiveMoneyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GiveMoneyMutation) ClearField(name string) error {
	switch name {
	case givemoney.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GiveMoney nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GiveMoneyMutation) ResetField(name string) error {
	switch name {
	case givemoney.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case givemoney.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case givemoney.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case givemoney.FieldNickname:
		m.ResetNickname()
		return nil
	case givemoney.FieldFigure:
		m.ResetFigure()
		return nil
	}
	return fmt.Errorf("unknown GiveMoney field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GiveMoneyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GiveMoneyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GiveMoneyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GiveMoneyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GiveMoneyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GiveMoneyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GiveMoneyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GiveMoney unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GiveMoneyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GiveMoney edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	url               *string
	logo              *string
	description       *string
	status            *link.Status
	siteshot          *string
	email             *string
	_type             *link.Type
	original_url      *string
	update_reason     *string
	sort_order        *int
	addsort_order     *int
	skip_health_check *bool
	clearedFields     map[string]struct{}
	category          *int
	clearedcategory   bool
	tags              map[int]struct{}
	removedtags       map[int]struct{}
	clearedtags       bool
	done              bool
	oldValue          func(context.Context) (*Link, error)
	predicates        []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id int) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *LinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *LinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *LinkMutation) ResetURL() {
	m.url = nil
}

// SetLogo sets the "logo" field.
func (m *LinkMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *LinkMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *LinkMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[link.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *LinkMutation) LogoCleared() bool {
	_, ok := m.clearedFields[link.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *LinkMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, link.FieldLogo)
}

// SetDescription sets the "description" field.
func (m *LinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[link.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[link.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, link.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *LinkMutation) SetStatus(l link.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LinkMutation) Status() (r link.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldStatus(ctx context.Context) (v link.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LinkMutation) ResetStatus() {
	m.status = nil
}

// SetSiteshot sets the "siteshot" field.
func (m *LinkMutation) SetSiteshot(s string) {
	m.siteshot = &s
}

// Siteshot returns the value of the "siteshot" field in the mutation.
func (m *LinkMutation) Siteshot() (r string, exists bool) {
	v := m.siteshot
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteshot returns the old "siteshot" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSiteshot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteshot: %w", err)
	}
	return oldValue.Siteshot, nil
}

// ClearSiteshot clears the value of the "siteshot" field.
func (m *LinkMutation) ClearSiteshot() {
	m.siteshot = nil
	m.clearedFields[link.FieldSiteshot] = struct{}{}
}

// SiteshotCleared returns if the "siteshot" field was cleared in this mutation.
func (m *LinkMutation) SiteshotCleared() bool {
	_, ok := m.clearedFields[link.FieldSiteshot]
	return ok
}

// ResetSiteshot resets all changes to the "siteshot" field.
func (m *LinkMutation) ResetSiteshot() {
	m.siteshot = nil
	delete(m.clearedFields, link.FieldSiteshot)
}

// SetEmail sets the "email" field.
func (m *LinkMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LinkMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *LinkMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[link.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *LinkMutation) EmailCleared() bool {
	_, ok := m.clearedFields[link.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *LinkMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, link.FieldEmail)
}

// SetType sets the "type" field.
func (m *LinkMutation) SetType(l link.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LinkMutation) GetType() (r link.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldType(ctx context.Context) (v link.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *LinkMutation) ClearType() {
	m._type = nil
	m.clearedFields[link.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *LinkMutation) TypeCleared() bool {
	_, ok := m.clearedFields[link.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *LinkMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, link.FieldType)
}

// SetOriginalURL sets the "original_url" field.
func (m *LinkMutation) SetOriginalURL(s string) {
	m.original_url = &s
}

// OriginalURL returns the value of the "original_url" field in the mutation.
func (m *LinkMutation) OriginalURL() (r string, exists bool) {
	v := m.original_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalURL returns the old "original_url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldOriginalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalURL: %w", err)
	}
	return oldValue.OriginalURL, nil
}

// ClearOriginalURL clears the value of the "original_url" field.
func (m *LinkMutation) ClearOriginalURL() {
	m.original_url = nil
	m.clearedFields[link.FieldOriginalURL] = struct{}{}
}

// OriginalURLCleared returns if the "original_url" field was cleared in this mutation.
func (m *LinkMutation) OriginalURLCleared() bool {
	_, ok := m.clearedFields[link.FieldOriginalURL]
	return ok
}

// ResetOriginalURL resets all changes to the "original_url" field.
func (m *LinkMutation) ResetOriginalURL() {
	m.original_url = nil
	delete(m.clearedFields, link.FieldOriginalURL)
}

// SetUpdateReason sets the "update_reason" field.
func (m *LinkMutation) SetUpdateReason(s string) {
	m.update_reason = &s
}

// UpdateReason returns the value of the "update_reason" field in the mutation.
func (m *LinkMutation) UpdateReason() (r string, exists bool) {
	v := m.update_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateReason returns the old "update_reason" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldUpdateReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateReason: %w", err)
	}
	return oldValue.UpdateReason, nil
}

// ClearUpdateReason clears the value of the "update_reason" field.
func (m *LinkMutation) ClearUpdateReason() {
	m.update_reason = nil
	m.clearedFields[link.FieldUpdateReason] = struct{}{}
}

// UpdateReasonCleared returns if the "update_reason" field was cleared in this mutation.
func (m *LinkMutation) UpdateReasonCleared() bool {
	_, ok := m.clearedFields[link.FieldUpdateReason]
	return ok
}

// ResetUpdateReason resets all changes to the "update_reason" field.
func (m *LinkMutation) ResetUpdateReason() {
	m.update_reason = nil
	delete(m.clearedFields, link.FieldUpdateReason)
}

// SetSortOrder sets the "sort_order" field.
func (m *LinkMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *LinkMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *LinkMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *LinkMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *LinkMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetSkipHealthCheck sets the "skip_health_check" field.
func (m *LinkMutation) SetSkipHealthCheck(b bool) {
	m.skip_health_check = &b
}

// SkipHealthCheck returns the value of the "skip_health_check" field in the mutation.
func (m *LinkMutation) SkipHealthCheck() (r bool, exists bool) {
	v := m.skip_health_check
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipHealthCheck returns the old "skip_health_check" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSkipHealthCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipHealthCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipHealthCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipHealthCheck: %w", err)
	}
	return oldValue.SkipHealthCheck, nil
}

// ResetSkipHealthCheck resets all changes to the "skip_health_check" field.
func (m *LinkMutation) ResetSkipHealthCheck() {
	m.skip_health_check = nil
}

// SetCategoryID sets the "category" edge to the LinkCategory entity by id.
func (m *LinkMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the LinkCategory entity.
func (m *LinkMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the LinkCategory entity was cleared.
func (m *LinkMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *LinkMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *LinkMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the LinkTag entity by ids.
func (m *LinkMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the LinkTag entity.
func (m *LinkMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the LinkTag entity was cleared.
func (m *LinkMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the LinkTag entity by IDs.
func (m *LinkMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the LinkTag entity.
func (m *LinkMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *LinkMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *LinkMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, link.FieldName)
	}
	if m.url != nil {
		fields = append(fields, link.FieldURL)
	}
	if m.logo != nil {
		fields = append(fields, link.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, link.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, link.FieldStatus)
	}
	if m.siteshot != nil {
		fields = append(fields, link.FieldSiteshot)
	}
	if m.email != nil {
		fields = append(fields, link.FieldEmail)
	}
	if m._type != nil {
		fields = append(fields, link.FieldType)
	}
	if m.original_url != nil {
		fields = append(fields, link.FieldOriginalURL)
	}
	if m.update_reason != nil {
		fields = append(fields, link.FieldUpdateReason)
	}
	if m.sort_order != nil {
		fields = append(fields, link.FieldSortOrder)
	}
	if m.skip_health_check != nil {
		fields = append(fields, link.FieldSkipHealthCheck)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldName:
		return m.Name()
	case link.FieldURL:
		return m.URL()
	case link.FieldLogo:
		return m.Logo()
	case link.FieldDescription:
		return m.Description()
	case link.FieldStatus:
		return m.Status()
	case link.FieldSiteshot:
		return m.Siteshot()
	case link.FieldEmail:
		return m.Email()
	case link.FieldType:
		return m.GetType()
	case link.FieldOriginalURL:
		return m.OriginalURL()
	case link.FieldUpdateReason:
		return m.UpdateReason()
	case link.FieldSortOrder:
		return m.SortOrder()
	case link.FieldSkipHealthCheck:
		return m.SkipHealthCheck()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldName:
		return m.OldName(ctx)
	case link.FieldURL:
		return m.OldURL(ctx)
	case link.FieldLogo:
		return m.OldLogo(ctx)
	case link.FieldDescription:
		return m.OldDescription(ctx)
	case link.FieldStatus:
		return m.OldStatus(ctx)
	case link.FieldSiteshot:
		return m.OldSiteshot(ctx)
	case link.FieldEmail:
		return m.OldEmail(ctx)
	case link.FieldType:
		return m.OldType(ctx)
	case link.FieldOriginalURL:
		return m.OldOriginalURL(ctx)
	case link.FieldUpdateReason:
		return m.OldUpdateReason(ctx)
	case link.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case link.FieldSkipHealthCheck:
		return m.OldSkipHealthCheck(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case link.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case link.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case link.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case link.FieldStatus:
		v, ok := value.(link.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case link.FieldSiteshot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteshot(v)
		return nil
	case link.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case link.FieldType:
		v, ok := value.(link.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case link.FieldOriginalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalURL(v)
		return nil
	case link.FieldUpdateReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateReason(v)
		return nil
	case link.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case link.FieldSkipHealthCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipHealthCheck(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, link.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case link.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case link.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldLogo) {
		fields = append(fields, link.FieldLogo)
	}
	if m.FieldCleared(link.FieldDescription) {
		fields = append(fields, link.FieldDescription)
	}
	if m.FieldCleared(link.FieldSiteshot) {
		fields = append(fields, link.FieldSiteshot)
	}
	if m.FieldCleared(link.FieldEmail) {
		fields = append(fields, link.FieldEmail)
	}
	if m.FieldCleared(link.FieldType) {
		fields = append(fields, link.FieldType)
	}
	if m.FieldCleared(link.FieldOriginalURL) {
		fields = append(fields, link.FieldOriginalURL)
	}
	if m.FieldCleared(link.FieldUpdateReason) {
		fields = append(fields, link.FieldUpdateReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldLogo:
		m.ClearLogo()
		return nil
	case link.FieldDescription:
		m.ClearDescription()
		return nil
	case link.FieldSiteshot:
		m.ClearSiteshot()
		return nil
	case link.FieldEmail:
		m.ClearEmail()
		return nil
	case link.FieldType:
		m.ClearType()
		return nil
	case link.FieldOriginalURL:
		m.ClearOriginalURL()
		return nil
	case link.FieldUpdateReason:
		m.ClearUpdateReason()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldName:
		m.ResetName()
		return nil
	case link.FieldURL:
		m.ResetURL()
		return nil
	case link.FieldLogo:
		m.ResetLogo()
		return nil
	case link.FieldDescription:
		m.ResetDescription()
		return nil
	case link.FieldStatus:
		m.ResetStatus()
		return nil
	case link.FieldSiteshot:
		m.ResetSiteshot()
		return nil
	case link.FieldEmail:
		m.ResetEmail()
		return nil
	case link.FieldType:
		m.ResetType()
		return nil
	case link.FieldOriginalURL:
		m.ResetOriginalURL()
		return nil
	case link.FieldUpdateReason:
		m.ResetUpdateReason()
		return nil
	case link.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case link.FieldSkipHealthCheck:
		m.ResetSkipHealthCheck()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.category != nil {
		edges = append(edges, link.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, link.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case link.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, link.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case link.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategory {
		edges = append(edges, link.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, link.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	switch name {
	case link.EdgeCategory:
		return m.clearedcategory
	case link.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	switch name {
	case link.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	switch name {
	case link.EdgeCategory:
		m.ResetCategory()
		return nil
	case link.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Link edge %s", name)
}

// LinkCategoryMutation represents an operation that mutates the LinkCategory nodes in the graph.
type LinkCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	style         *linkcategory.Style
	clearedFields map[string]struct{}
	links         map[int]struct{}
	removedlinks  map[int]struct{}
	clearedlinks  bool
	done          bool
	oldValue      func(context.Context) (*LinkCategory, error)
	predicates    []predicate.LinkCategory
}

var _ ent.Mutation = (*LinkCategoryMutation)(nil)

// linkcategoryOption allows management of the mutation configuration using functional options.
type linkcategoryOption func(*LinkCategoryMutation)

// newLinkCategoryMutation creates new mutation for the LinkCategory entity.
func newLinkCategoryMutation(c config, op Op, opts ...linkcategoryOption) *LinkCategoryMutation {
	m := &LinkCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLinkCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkCategoryID sets the ID field of the mutation.
func withLinkCategoryID(id int) linkcategoryOption {
	return func(m *LinkCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LinkCategory
		)
		m.oldValue = func(ctx context.Context) (*LinkCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LinkCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLinkCategory sets the old LinkCategory of the mutation.
func withLinkCategory(node *LinkCategory) linkcategoryOption {
	return func(m *LinkCategoryMutation) {
		m.oldValue = func(context.Context) (*LinkCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LinkCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LinkCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LinkCategory entity.
// If the LinkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LinkCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LinkCategory entity.
// If the LinkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LinkCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[linkcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LinkCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[linkcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, linkcategory.FieldDescription)
}

// SetStyle sets the "style" field.
func (m *LinkCategoryMutation) SetStyle(l linkcategory.Style) {
	m.style = &l
}

// Style returns the value of the "style" field in the mutation.
func (m *LinkCategoryMutation) Style() (r linkcategory.Style, exists bool) {
	v := m.style
	if v == nil {
		return
	}
	return *v, true
}

// OldStyle returns the old "style" field's value of the LinkCategory entity.
// If the LinkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkCategoryMutation) OldStyle(ctx context.Context) (v linkcategory.Style, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStyle: %w", err)
	}
	return oldValue.Style, nil
}

// ResetStyle resets all changes to the "style" field.
func (m *LinkCategoryMutation) ResetStyle() {
	m.style = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *LinkCategoryMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *LinkCategoryMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *LinkCategoryMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *LinkCategoryMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *LinkCategoryMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *LinkCategoryMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *LinkCategoryMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// Where appends a list predicates to the LinkCategoryMutation builder.
func (m *LinkCategoryMutation) Where(ps ...predicate.LinkCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LinkCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LinkCategory).
func (m *LinkCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, linkcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, linkcategory.FieldDescription)
	}
	if m.style != nil {
		fields = append(fields, linkcategory.FieldStyle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case linkcategory.FieldName:
		return m.Name()
	case linkcategory.FieldDescription:
		return m.Description()
	case linkcategory.FieldStyle:
		return m.Style()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case linkcategory.FieldName:
		return m.OldName(ctx)
	case linkcategory.FieldDescription:
		return m.OldDescription(ctx)
	case linkcategory.FieldStyle:
		return m.OldStyle(ctx)
	}
	return nil, fmt.Errorf("unknown LinkCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case linkcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case linkcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case linkcategory.FieldStyle:
		v, ok := value.(linkcategory.Style)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStyle(v)
		return nil
	}
	return fmt.Errorf("unknown LinkCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(linkcategory.FieldDescription) {
		fields = append(fields, linkcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkCategoryMutation) ClearField(name string) error {
	switch name {
	case linkcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown LinkCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkCategoryMutation) ResetField(name string) error {
	switch name {
	case linkcategory.FieldName:
		m.ResetName()
		return nil
	case linkcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case linkcategory.FieldStyle:
		m.ResetStyle()
		return nil
	}
	return fmt.Errorf("unknown LinkCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.links != nil {
		edges = append(edges, linkcategory.EdgeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case linkcategory.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlinks != nil {
		edges = append(edges, linkcategory.EdgeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case linkcategory.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinks {
		edges = append(edges, linkcategory.EdgeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case linkcategory.EdgeLinks:
		return m.clearedlinks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkCategoryMutation) ResetEdge(name string) error {
	switch name {
	case linkcategory.EdgeLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown LinkCategory edge %s", name)
}

// LinkTagMutation represents an operation that mutates the LinkTag nodes in the graph.
type LinkTagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	color         *string
	clearedFields map[string]struct{}
	links         map[int]struct{}
	removedlinks  map[int]struct{}
	clearedlinks  bool
	done          bool
	oldValue      func(context.Context) (*LinkTag, error)
	predicates    []predicate.LinkTag
}

var _ ent.Mutation = (*LinkTagMutation)(nil)

// linktagOption allows management of the mutation configuration using functional options.
type linktagOption func(*LinkTagMutation)

// newLinkTagMutation creates new mutation for the LinkTag entity.
func newLinkTagMutation(c config, op Op, opts ...linktagOption) *LinkTagMutation {
	m := &LinkTagMutation{
		config:        c,
		op:            op,
		typ:           TypeLinkTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkTagID sets the ID field of the mutation.
func withLinkTagID(id int) linktagOption {
	return func(m *LinkTagMutation) {
		var (
			err   error
			once  sync.Once
			value *LinkTag
		)
		m.oldValue = func(ctx context.Context) (*LinkTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LinkTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLinkTag sets the old LinkTag of the mutation.
func withLinkTag(node *LinkTag) linktagOption {
	return func(m *LinkTagMutation) {
		m.oldValue = func(context.Context) (*LinkTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LinkTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LinkTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LinkTag entity.
// If the LinkTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkTagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *LinkTagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *LinkTagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the LinkTag entity.
// If the LinkTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkTagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *LinkTagMutation) ResetColor() {
	m.color = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *LinkTagMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *LinkTagMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *LinkTagMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *LinkTagMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *LinkTagMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *LinkTagMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *LinkTagMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// Where appends a list predicates to the LinkTagMutation builder.
func (m *LinkTagMutation) Where(ps ...predicate.LinkTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LinkTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LinkTag).
func (m *LinkTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, linktag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, linktag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case linktag.FieldName:
		return m.Name()
	case linktag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case linktag.FieldName:
		return m.OldName(ctx)
	case linktag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown LinkTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case linktag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case linktag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown LinkTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LinkTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkTagMutation) ResetField(name string) error {
	switch name {
	case linktag.FieldName:
		m.ResetName()
		return nil
	case linktag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown LinkTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.links != nil {
		edges = append(edges, linktag.EdgeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case linktag.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlinks != nil {
		edges = append(edges, linktag.EdgeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case linktag.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinks {
		edges = append(edges, linktag.EdgeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkTagMutation) EdgeCleared(name string) bool {
	switch name {
	case linktag.EdgeLinks:
		return m.clearedlinks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkTagMutation) ResetEdge(name string) error {
	switch name {
	case linktag.EdgeLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown LinkTag edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	value         *string
	clearedFields map[string]struct{}
	file          *uint
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Metadata, error)
	predicates    []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id uint) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metadata entities.
func (m *MetadataMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetadataMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetadataMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MetadataMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[metadata.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MetadataMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[metadata.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetadataMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, metadata.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *MetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MetadataMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *MetadataMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MetadataMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *MetadataMutation) ClearValue() {
	m.value = nil
	m.clearedFields[metadata.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *MetadataMutation) ValueCleared() bool {
	_, ok := m.clearedFields[metadata.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *MetadataMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, metadata.FieldValue)
}

// SetFileID sets the "file_id" field.
func (m *MetadataMutation) SetFileID(u uint) {
	m.file = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *MetadataMutation) FileID() (r uint, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldFileID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *MetadataMutation) ResetFileID() {
	m.file = nil
}

// ClearFile clears the "file" edge to the File entity.
func (m *MetadataMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[metadata.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *MetadataMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) FileIDs() (ids []uint) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *MetadataMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, metadata.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, metadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metadata.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, metadata.FieldName)
	}
	if m.value != nil {
		fields = append(fields, metadata.FieldValue)
	}
	if m.file != nil {
		fields = append(fields, metadata.FieldFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldDeletedAt:
		return m.DeletedAt()
	case metadata.FieldCreatedAt:
		return m.CreatedAt()
	case metadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case metadata.FieldName:
		return m.Name()
	case metadata.FieldValue:
		return m.Value()
	case metadata.FieldFileID:
		return m.FileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metadata.FieldName:
		return m.OldName(ctx)
	case metadata.FieldValue:
		return m.OldValue(ctx)
	case metadata.FieldFileID:
		return m.OldFileID(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case metadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case metadata.FieldFileID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metadata.FieldDeletedAt) {
		fields = append(fields, metadata.FieldDeletedAt)
	}
	if m.FieldCleared(metadata.FieldValue) {
		fields = append(fields, metadata.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	switch name {
	case metadata.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case metadata.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metadata.FieldName:
		m.ResetName()
		return nil
	case metadata.FieldValue:
		m.ResetValue()
		return nil
	case metadata.FieldFileID:
		m.ResetFileID()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, metadata.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, metadata.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// NotificationTypeMutation represents an operation that mutates the NotificationType nodes in the graph.
type NotificationTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint
	created_at               *time.Time
	updated_at               *time.Time
	code                     *string
	name                     *string
	description              *string
	category                 *string
	is_active                *bool
	default_enabled          *bool
	supported_channels       *[]string
	appendsupported_channels []string
	clearedFields            map[string]struct{}
	user_configs             map[uint]struct{}
	removeduser_configs      map[uint]struct{}
	cleareduser_configs      bool
	done                     bool
	oldValue                 func(context.Context) (*NotificationType, error)
	predicates               []predicate.NotificationType
}

var _ ent.Mutation = (*NotificationTypeMutation)(nil)

// notificationtypeOption allows management of the mutation configuration using functional options.
type notificationtypeOption func(*NotificationTypeMutation)

// newNotificationTypeMutation creates new mutation for the NotificationType entity.
func newNotificationTypeMutation(c config, op Op, opts ...notificationtypeOption) *NotificationTypeMutation {
	m := &NotificationTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationTypeID sets the ID field of the mutation.
func withNotificationTypeID(id uint) notificationtypeOption {
	return func(m *NotificationTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationType
		)
		m.oldValue = func(ctx context.Context) (*NotificationType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationType sets the old NotificationType of the mutation.
func withNotificationType(node *NotificationType) notificationtypeOption {
	return func(m *NotificationTypeMutation) {
		m.oldValue = func(context.Context) (*NotificationType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationType entities.
func (m *NotificationTypeMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationTypeMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationTypeMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *NotificationTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *NotificationTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *NotificationTypeMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *NotificationTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotificationTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NotificationTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[notificationtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NotificationTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[notificationtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, notificationtype.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *NotificationTypeMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *NotificationTypeMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *NotificationTypeMutation) ResetCategory() {
	m.category = nil
}

// SetIsActive sets the "is_active" field.
func (m *NotificationTypeMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *NotificationTypeMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *NotificationTypeMutation) ResetIsActive() {
	m.is_active = nil
}

// SetDefaultEnabled sets the "default_enabled" field.
func (m *NotificationTypeMutation) SetDefaultEnabled(b bool) {
	m.default_enabled = &b
}

// DefaultEnabled returns the value of the "default_enabled" field in the mutation.
func (m *NotificationTypeMutation) DefaultEnabled() (r bool, exists bool) {
	v := m.default_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultEnabled returns the old "default_enabled" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldDefaultEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultEnabled: %w", err)
	}
	return oldValue.DefaultEnabled, nil
}

// ResetDefaultEnabled resets all changes to the "default_enabled" field.
func (m *NotificationTypeMutation) ResetDefaultEnabled() {
	m.default_enabled = nil
}

// SetSupportedChannels sets the "supported_channels" field.
func (m *NotificationTypeMutation) SetSupportedChannels(s []string) {
	m.supported_channels = &s
	m.appendsupported_channels = nil
}

// SupportedChannels returns the value of the "supported_channels" field in the mutation.
func (m *NotificationTypeMutation) SupportedChannels() (r []string, exists bool) {
	v := m.supported_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedChannels returns the old "supported_channels" field's value of the NotificationType entity.
// If the NotificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTypeMutation) OldSupportedChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedChannels: %w", err)
	}
	return oldValue.SupportedChannels, nil
}

// AppendSupportedChannels adds s to the "supported_channels" field.
func (m *NotificationTypeMutation) AppendSupportedChannels(s []string) {
	m.appendsupported_channels = append(m.appendsupported_channels, s...)
}

// AppendedSupportedChannels returns the list of values that were appended to the "supported_channels" field in this mutation.
func (m *NotificationTypeMutation) AppendedSupportedChannels() ([]string, bool) {
	if len(m.appendsupported_channels) == 0 {
		return nil, false
	}
	return m.appendsupported_channels, true
}

// ClearSupportedChannels clears the value of the "supported_channels" field.
func (m *NotificationTypeMutation) ClearSupportedChannels() {
	m.supported_channels = nil
	m.appendsupported_channels = nil
	m.clearedFields[notificationtype.FieldSupportedChannels] = struct{}{}
}

// SupportedChannelsCleared returns if the "supported_channels" field was cleared in this mutation.
func (m *NotificationTypeMutation) SupportedChannelsCleared() bool {
	_, ok := m.clearedFields[notificationtype.FieldSupportedChannels]
	return ok
}

// ResetSupportedChannels resets all changes to the "supported_channels" field.
func (m *NotificationTypeMutation) ResetSupportedChannels() {
	m.supported_channels = nil
	m.appendsupported_channels = nil
	delete(m.clearedFields, notificationtype.FieldSupportedChannels)
}

// AddUserConfigIDs adds the "user_configs" edge to the UserNotificationConfig entity by ids.
func (m *NotificationTypeMutation) AddUserConfigIDs(ids ...uint) {
	if m.user_configs == nil {
		m.user_configs = make(map[uint]struct{})
	}
	for i := range ids {
		m.user_configs[ids[i]] = struct{}{}
	}
}

// ClearUserConfigs clears the "user_configs" edge to the UserNotificationConfig entity.
func (m *NotificationTypeMutation) ClearUserConfigs() {
	m.cleareduser_configs = true
}

// UserConfigsCleared reports if the "user_configs" edge to the UserNotificationConfig entity was cleared.
func (m *NotificationTypeMutation) UserConfigsCleared() bool {
	return m.cleareduser_configs
}

// RemoveUserConfigIDs removes the "user_configs" edge to the UserNotificationConfig entity by IDs.
func (m *NotificationTypeMutation) RemoveUserConfigIDs(ids ...uint) {
	if m.removeduser_configs == nil {
		m.removeduser_configs = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.user_configs, ids[i])
		m.removeduser_configs[ids[i]] = struct{}{}
	}
}

// RemovedUserConfigs returns the removed IDs of the "user_configs" edge to the UserNotificationConfig entity.
func (m *NotificationTypeMutation) RemovedUserConfigsIDs() (ids []uint) {
	for id := range m.removeduser_configs {
		ids = append(ids, id)
	}
	return
}

// UserConfigsIDs returns the "user_configs" edge IDs in the mutation.
func (m *NotificationTypeMutation) UserConfigsIDs() (ids []uint) {
	for id := range m.user_configs {
		ids = append(ids, id)
	}
	return
}

// ResetUserConfigs resets all changes to the "user_configs" edge.
func (m *NotificationTypeMutation) ResetUserConfigs() {
	m.user_configs = nil
	m.cleareduser_configs = false
	m.removeduser_configs = nil
}

// Where appends a list predicates to the NotificationTypeMutation builder.
func (m *NotificationTypeMutation) Where(ps ...predicate.NotificationType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationType).
func (m *NotificationTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, notificationtype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationtype.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, notificationtype.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, notificationtype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notificationtype.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, notificationtype.FieldCategory)
	}
	if m.is_active != nil {
		fields = append(fields, notificationtype.FieldIsActive)
	}
	if m.default_enabled != nil {
		fields = append(fields, notificationtype.FieldDefaultEnabled)
	}
	if m.supported_channels != nil {
		fields = append(fields, notificationtype.FieldSupportedChannels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationtype.FieldCreatedAt:
		return m.CreatedAt()
	case notificationtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationtype.FieldCode:
		return m.Code()
	case notificationtype.FieldName:
		return m.Name()
	case notificationtype.FieldDescription:
		return m.Description()
	case notificationtype.FieldCategory:
		return m.Category()
	case notificationtype.FieldIsActive:
		return m.IsActive()
	case notificationtype.FieldDefaultEnabled:
		return m.DefaultEnabled()
	case notificationtype.FieldSupportedChannels:
		return m.SupportedChannels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationtype.FieldCode:
		return m.OldCode(ctx)
	case notificationtype.FieldName:
		return m.OldName(ctx)
	case notificationtype.FieldDescription:
		return m.OldDescription(ctx)
	case notificationtype.FieldCategory:
		return m.OldCategory(ctx)
	case notificationtype.FieldIsActive:
		return m.OldIsActive(ctx)
	case notificationtype.FieldDefaultEnabled:
		return m.OldDefaultEnabled(ctx)
	case notificationtype.FieldSupportedChannels:
		return m.OldSupportedChannels(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationtype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case notificationtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notificationtype.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case notificationtype.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case notificationtype.FieldDefaultEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultEnabled(v)
		return nil
	case notificationtype.FieldSupportedChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedChannels(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationtype.FieldDescription) {
		fields = append(fields, notificationtype.FieldDescription)
	}
	if m.FieldCleared(notificationtype.FieldSupportedChannels) {
		fields = append(fields, notificationtype.FieldSupportedChannels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationTypeMutation) ClearField(name string) error {
	switch name {
	case notificationtype.FieldDescription:
		m.ClearDescription()
		return nil
	case notificationtype.FieldSupportedChannels:
		m.ClearSupportedChannels()
		return nil
	}
	return fmt.Errorf("unknown NotificationType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationTypeMutation) ResetField(name string) error {
	switch name {
	case notificationtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationtype.FieldCode:
		m.ResetCode()
		return nil
	case notificationtype.FieldName:
		m.ResetName()
		return nil
	case notificationtype.FieldDescription:
		m.ResetDescription()
		return nil
	case notificationtype.FieldCategory:
		m.ResetCategory()
		return nil
	case notificationtype.FieldIsActive:
		m.ResetIsActive()
		return nil
	case notificationtype.FieldDefaultEnabled:
		m.ResetDefaultEnabled()
		return nil
	case notificationtype.FieldSupportedChannels:
		m.ResetSupportedChannels()
		return nil
	}
	return fmt.Errorf("unknown NotificationType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_configs != nil {
		edges = append(edges, notificationtype.EdgeUserConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationtype.EdgeUserConfigs:
		ids := make([]ent.Value, 0, len(m.user_configs))
		for id := range m.user_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_configs != nil {
		edges = append(edges, notificationtype.EdgeUserConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationtype.EdgeUserConfigs:
		ids := make([]ent.Value, 0, len(m.removeduser_configs))
		for id := range m.removeduser_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_configs {
		edges = append(edges, notificationtype.EdgeUserConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationtype.EdgeUserConfigs:
		return m.cleareduser_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationTypeMutation) ResetEdge(name string) error {
	switch name {
	case notificationtype.EdgeUserConfigs:
		m.ResetUserConfigs()
		return nil
	}
	return fmt.Errorf("unknown NotificationType edge %s", name)
}

// PageMutation represents an operation that mutates the Page nodes in the graph.
type PageMutation struct {
	config
	op               Op
	typ              string
	id               *uint
	deleted_at       *time.Time
	title            *string
	_path            *string
	content          *string
	markdown_content *string
	description      *string
	is_published     *bool
	show_comment     *bool
	sort             *int
	addsort          *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Page, error)
	predicates       []predicate.Page
}

var _ ent.Mutation = (*PageMutation)(nil)

// pageOption allows management of the mutation configuration using functional options.
type pageOption func(*PageMutation)

// newPageMutation creates new mutation for the Page entity.
func newPageMutation(c config, op Op, opts ...pageOption) *PageMutation {
	m := &PageMutation{
		config:        c,
		op:            op,
		typ:           TypePage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageID sets the ID field of the mutation.
func withPageID(id uint) pageOption {
	return func(m *PageMutation) {
		var (
			err   error
			once  sync.Once
			value *Page
		)
		m.oldValue = func(ctx context.Context) (*Page, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Page.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPage sets the old Page of the mutation.
func withPage(node *Page) pageOption {
	return func(m *PageMutation) {
		m.oldValue = func(context.Context) (*Page, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Page entities.
func (m *PageMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Page.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[page.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[page.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, page.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *PageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PageMutation) ResetTitle() {
	m.title = nil
}

// SetPath sets the "path" field.
func (m *PageMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *PageMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *PageMutation) ResetPath() {
	m._path = nil
}

// SetContent sets the "content" field.
func (m *PageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PageMutation) ResetContent() {
	m.content = nil
}

// SetMarkdownContent sets the "markdown_content" field.
func (m *PageMutation) SetMarkdownContent(s string) {
	m.markdown_content = &s
}

// MarkdownContent returns the value of the "markdown_content" field in the mutation.
func (m *PageMutation) MarkdownContent() (r string, exists bool) {
	v := m.markdown_content
	if v == nil {
		return
	}
	return *v, true
}

// OldMarkdownContent returns the old "markdown_content" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldMarkdownContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarkdownContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarkdownContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarkdownContent: %w", err)
	}
	return oldValue.MarkdownContent, nil
}

// ResetMarkdownContent resets all changes to the "markdown_content" field.
func (m *PageMutation) ResetMarkdownContent() {
	m.markdown_content = nil
}

// SetDescription sets the "description" field.
func (m *PageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PageMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[page.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PageMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[page.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PageMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, page.FieldDescription)
}

// SetIsPublished sets the "is_published" field.
func (m *PageMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *PageMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *PageMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetShowComment sets the "show_comment" field.
func (m *PageMutation) SetShowComment(b bool) {
	m.show_comment = &b
}

// ShowComment returns the value of the "show_comment" field in the mutation.
func (m *PageMutation) ShowComment() (r bool, exists bool) {
	v := m.show_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldShowComment returns the old "show_comment" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldShowComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowComment: %w", err)
	}
	return oldValue.ShowComment, nil
}

// ResetShowComment resets all changes to the "show_comment" field.
func (m *PageMutation) ResetShowComment() {
	m.show_comment = nil
}

// SetSort sets the "sort" field.
func (m *PageMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PageMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PageMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PageMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PageMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the PageMutation builder.
func (m *PageMutation) Where(ps ...predicate.Page) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Page, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Page).
func (m *PageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.deleted_at != nil {
		fields = append(fields, page.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, page.FieldTitle)
	}
	if m._path != nil {
		fields = append(fields, page.FieldPath)
	}
	if m.content != nil {
		fields = append(fields, page.FieldContent)
	}
	if m.markdown_content != nil {
		fields = append(fields, page.FieldMarkdownContent)
	}
	if m.description != nil {
		fields = append(fields, page.FieldDescription)
	}
	if m.is_published != nil {
		fields = append(fields, page.FieldIsPublished)
	}
	if m.show_comment != nil {
		fields = append(fields, page.FieldShowComment)
	}
	if m.sort != nil {
		fields = append(fields, page.FieldSort)
	}
	if m.created_at != nil {
		fields = append(fields, page.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, page.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case page.FieldDeletedAt:
		return m.DeletedAt()
	case page.FieldTitle:
		return m.Title()
	case page.FieldPath:
		return m.Path()
	case page.FieldContent:
		return m.Content()
	case page.FieldMarkdownContent:
		return m.MarkdownContent()
	case page.FieldDescription:
		return m.Description()
	case page.FieldIsPublished:
		return m.IsPublished()
	case page.FieldShowComment:
		return m.ShowComment()
	case page.FieldSort:
		return m.Sort()
	case page.FieldCreatedAt:
		return m.CreatedAt()
	case page.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case page.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case page.FieldTitle:
		return m.OldTitle(ctx)
	case page.FieldPath:
		return m.OldPath(ctx)
	case page.FieldContent:
		return m.OldContent(ctx)
	case page.FieldMarkdownContent:
		return m.OldMarkdownContent(ctx)
	case page.FieldDescription:
		return m.OldDescription(ctx)
	case page.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case page.FieldShowComment:
		return m.OldShowComment(ctx)
	case page.FieldSort:
		return m.OldSort(ctx)
	case page.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case page.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Page field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case page.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case page.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case page.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case page.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case page.FieldMarkdownContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarkdownContent(v)
		return nil
	case page.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case page.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case page.FieldShowComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowComment(v)
		return nil
	case page.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case page.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case page.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, page.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case page.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case page.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Page numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(page.FieldDeletedAt) {
		fields = append(fields, page.FieldDeletedAt)
	}
	if m.FieldCleared(page.FieldDescription) {
		fields = append(fields, page.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageMutation) ClearField(name string) error {
	switch name {
	case page.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case page.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Page nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageMutation) ResetField(name string) error {
	switch name {
	case page.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case page.FieldTitle:
		m.ResetTitle()
		return nil
	case page.FieldPath:
		m.ResetPath()
		return nil
	case page.FieldContent:
		m.ResetContent()
		return nil
	case page.FieldMarkdownContent:
		m.ResetMarkdownContent()
		return nil
	case page.FieldDescription:
		m.ResetDescription()
		return nil
	case page.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case page.FieldShowComment:
		m.ResetShowComment()
		return nil
	case page.FieldSort:
		m.ResetSort()
		return nil
	case page.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case page.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Page unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Page edge %s", name)
}

// PostCategoryMutation represents an operation that mutates the PostCategory nodes in the graph.
type PostCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	deleted_at      *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	count           *int
	addcount        *int
	is_series       *bool
	sort_order      *int
	addsort_order   *int
	clearedFields   map[string]struct{}
	articles        map[uint]struct{}
	removedarticles map[uint]struct{}
	clearedarticles bool
	done            bool
	oldValue        func(context.Context) (*PostCategory, error)
	predicates      []predicate.PostCategory
}

var _ ent.Mutation = (*PostCategoryMutation)(nil)

// postcategoryOption allows management of the mutation configuration using functional options.
type postcategoryOption func(*PostCategoryMutation)

// newPostCategoryMutation creates new mutation for the PostCategory entity.
func newPostCategoryMutation(c config, op Op, opts ...postcategoryOption) *PostCategoryMutation {
	m := &PostCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypePostCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostCategoryID sets the ID field of the mutation.
func withPostCategoryID(id uint) postcategoryOption {
	return func(m *PostCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PostCategory
		)
		m.oldValue = func(ctx context.Context) (*PostCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostCategory sets the old PostCategory of the mutation.
func withPostCategory(node *PostCategory) postcategoryOption {
	return func(m *PostCategoryMutation) {
		m.oldValue = func(context.Context) (*PostCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostCategory entities.
func (m *PostCategoryMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostCategoryMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostCategoryMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[postcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, postcategory.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PostCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PostCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PostCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PostCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PostCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[postcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PostCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PostCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, postcategory.FieldDescription)
}

// SetCount sets the "count" field.
func (m *PostCategoryMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *PostCategoryMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *PostCategoryMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *PostCategoryMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *PostCategoryMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetIsSeries sets the "is_series" field.
func (m *PostCategoryMutation) SetIsSeries(b bool) {
	m.is_series = &b
}

// IsSeries returns the value of the "is_series" field in the mutation.
func (m *PostCategoryMutation) IsSeries() (r bool, exists bool) {
	v := m.is_series
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSeries returns the old "is_series" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldIsSeries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSeries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSeries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSeries: %w", err)
	}
	return oldValue.IsSeries, nil
}

// ResetIsSeries resets all changes to the "is_series" field.
func (m *PostCategoryMutation) ResetIsSeries() {
	m.is_series = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *PostCategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *PostCategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *PostCategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *PostCategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *PostCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddArticleIDs adds the "articles" edge to the Article entity by ids.
func (m *PostCategoryMutation) AddArticleIDs(ids ...uint) {
	if m.articles == nil {
		m.articles = make(map[uint]struct{})
	}
	for i := range ids {
		m.articles[ids[i]] = struct{}{}
	}
}

// ClearArticles clears the "articles" edge to the Article entity.
func (m *PostCategoryMutation) ClearArticles() {
	m.clearedarticles = true
}

// ArticlesCleared reports if the "articles" edge to the Article entity was cleared.
func (m *PostCategoryMutation) ArticlesCleared() bool {
	return m.clearedarticles
}

// RemoveArticleIDs removes the "articles" edge to the Article entity by IDs.
func (m *PostCategoryMutation) RemoveArticleIDs(ids ...uint) {
	if m.removedarticles == nil {
		m.removedarticles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.articles, ids[i])
		m.removedarticles[ids[i]] = struct{}{}
	}
}

// RemovedArticles returns the removed IDs of the "articles" edge to the Article entity.
func (m *PostCategoryMutation) RemovedArticlesIDs() (ids []uint) {
	for id := range m.removedarticles {
		ids = append(ids, id)
	}
	return
}

// ArticlesIDs returns the "articles" edge IDs in the mutation.
func (m *PostCategoryMutation) ArticlesIDs() (ids []uint) {
	for id := range m.articles {
		ids = append(ids, id)
	}
	return
}

// ResetArticles resets all changes to the "articles" edge.
func (m *PostCategoryMutation) ResetArticles() {
	m.articles = nil
	m.clearedarticles = false
	m.removedarticles = nil
}

// Where appends a list predicates to the PostCategoryMutation builder.
func (m *PostCategoryMutation) Where(ps ...predicate.PostCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostCategory).
func (m *PostCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.deleted_at != nil {
		fields = append(fields, postcategory.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, postcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postcategory.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, postcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, postcategory.FieldDescription)
	}
	if m.count != nil {
		fields = append(fields, postcategory.FieldCount)
	}
	if m.is_series != nil {
		fields = append(fields, postcategory.FieldIsSeries)
	}
	if m.sort_order != nil {
		fields = append(fields, postcategory.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postcategory.FieldDeletedAt:
		return m.DeletedAt()
	case postcategory.FieldCreatedAt:
		return m.CreatedAt()
	case postcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case postcategory.FieldName:
		return m.Name()
	case postcategory.FieldDescription:
		return m.Description()
	case postcategory.FieldCount:
		return m.Count()
	case postcategory.FieldIsSeries:
		return m.IsSeries()
	case postcategory.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case postcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postcategory.FieldName:
		return m.OldName(ctx)
	case postcategory.FieldDescription:
		return m.OldDescription(ctx)
	case postcategory.FieldCount:
		return m.OldCount(ctx)
	case postcategory.FieldIsSeries:
		return m.OldIsSeries(ctx)
	case postcategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown PostCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case postcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case postcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case postcategory.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case postcategory.FieldIsSeries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSeries(v)
		return nil
	case postcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, postcategory.FieldCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, postcategory.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postcategory.FieldCount:
		return m.AddedCount()
	case postcategory.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postcategory.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case postcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown PostCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(postcategory.FieldDeletedAt) {
		fields = append(fields, postcategory.FieldDeletedAt)
	}
	if m.FieldCleared(postcategory.FieldDescription) {
		fields = append(fields, postcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostCategoryMutation) ClearField(name string) error {
	switch name {
	case postcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case postcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PostCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostCategoryMutation) ResetField(name string) error {
	switch name {
	case postcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case postcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postcategory.FieldName:
		m.ResetName()
		return nil
	case postcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case postcategory.FieldCount:
		m.ResetCount()
		return nil
	case postcategory.FieldIsSeries:
		m.ResetIsSeries()
		return nil
	case postcategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.articles != nil {
		edges = append(edges, postcategory.EdgeArticles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.articles))
		for id := range m.articles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedarticles != nil {
		edges = append(edges, postcategory.EdgeArticles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.removedarticles))
		for id := range m.removedarticles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticles {
		edges = append(edges, postcategory.EdgeArticles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case postcategory.EdgeArticles:
		return m.clearedarticles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostCategoryMutation) ResetEdge(name string) error {
	switch name {
	case postcategory.EdgeArticles:
		m.ResetArticles()
		return nil
	}
	return fmt.Errorf("unknown PostCategory edge %s", name)
}

// PostTagMutation represents an operation that mutates the PostTag nodes in the graph.
type PostTagMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	deleted_at      *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	count           *int
	addcount        *int
	clearedFields   map[string]struct{}
	articles        map[uint]struct{}
	removedarticles map[uint]struct{}
	clearedarticles bool
	done            bool
	oldValue        func(context.Context) (*PostTag, error)
	predicates      []predicate.PostTag
}

var _ ent.Mutation = (*PostTagMutation)(nil)

// posttagOption allows management of the mutation configuration using functional options.
type posttagOption func(*PostTagMutation)

// newPostTagMutation creates new mutation for the PostTag entity.
func newPostTagMutation(c config, op Op, opts ...posttagOption) *PostTagMutation {
	m := &PostTagMutation{
		config:        c,
		op:            op,
		typ:           TypePostTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostTagID sets the ID field of the mutation.
func withPostTagID(id uint) posttagOption {
	return func(m *PostTagMutation) {
		var (
			err   error
			once  sync.Once
			value *PostTag
		)
		m.oldValue = func(ctx context.Context) (*PostTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostTag sets the old PostTag of the mutation.
func withPostTag(node *PostTag) posttagOption {
	return func(m *PostTagMutation) {
		m.oldValue = func(context.Context) (*PostTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostTag entities.
func (m *PostTagMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostTagMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostTagMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostTagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostTagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[posttag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostTagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[posttag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostTagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, posttag.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PostTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PostTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostTagMutation) ResetName() {
	m.name = nil
}

// SetCount sets the "count" field.
func (m *PostTagMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *PostTagMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *PostTagMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *PostTagMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *PostTagMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// AddArticleIDs adds the "articles" edge to the Article entity by ids.
func (m *PostTagMutation) AddArticleIDs(ids ...uint) {
	if m.articles == nil {
		m.articles = make(map[uint]struct{})
	}
	for i := range ids {
		m.articles[ids[i]] = struct{}{}
	}
}

// ClearArticles clears the "articles" edge to the Article entity.
func (m *PostTagMutation) ClearArticles() {
	m.clearedarticles = true
}

// ArticlesCleared reports if the "articles" edge to the Article entity was cleared.
func (m *PostTagMutation) ArticlesCleared() bool {
	return m.clearedarticles
}

// RemoveArticleIDs removes the "articles" edge to the Article entity by IDs.
func (m *PostTagMutation) RemoveArticleIDs(ids ...uint) {
	if m.removedarticles == nil {
		m.removedarticles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.articles, ids[i])
		m.removedarticles[ids[i]] = struct{}{}
	}
}

// RemovedArticles returns the removed IDs of the "articles" edge to the Article entity.
func (m *PostTagMutation) RemovedArticlesIDs() (ids []uint) {
	for id := range m.removedarticles {
		ids = append(ids, id)
	}
	return
}

// ArticlesIDs returns the "articles" edge IDs in the mutation.
func (m *PostTagMutation) ArticlesIDs() (ids []uint) {
	for id := range m.articles {
		ids = append(ids, id)
	}
	return
}

// ResetArticles resets all changes to the "articles" edge.
func (m *PostTagMutation) ResetArticles() {
	m.articles = nil
	m.clearedarticles = false
	m.removedarticles = nil
}

// Where appends a list predicates to the PostTagMutation builder.
func (m *PostTagMutation) Where(ps ...predicate.PostTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostTag).
func (m *PostTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, posttag.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, posttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, posttag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, posttag.FieldName)
	}
	if m.count != nil {
		fields = append(fields, posttag.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldDeletedAt:
		return m.DeletedAt()
	case posttag.FieldCreatedAt:
		return m.CreatedAt()
	case posttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case posttag.FieldName:
		return m.Name()
	case posttag.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case posttag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case posttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case posttag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case posttag.FieldName:
		return m.OldName(ctx)
	case posttag.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown PostTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case posttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case posttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case posttag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case posttag.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostTagMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, posttag.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(posttag.FieldDeletedAt) {
		fields = append(fields, posttag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostTagMutation) ClearField(name string) error {
	switch name {
	case posttag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PostTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostTagMutation) ResetField(name string) error {
	switch name {
	case posttag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case posttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case posttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case posttag.FieldName:
		m.ResetName()
		return nil
	case posttag.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.articles != nil {
		edges = append(edges, posttag.EdgeArticles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.articles))
		for id := range m.articles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedarticles != nil {
		edges = append(edges, posttag.EdgeArticles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.removedarticles))
		for id := range m.removedarticles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticles {
		edges = append(edges, posttag.EdgeArticles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostTagMutation) EdgeCleared(name string) bool {
	switch name {
	case posttag.EdgeArticles:
		return m.clearedarticles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostTagMutation) ResetEdge(name string) error {
	switch name {
	case posttag.EdgeArticles:
		m.ResetArticles()
		return nil
	}
	return fmt.Errorf("unknown PostTag edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	deleted_at    *time.Time
	config_key    *string
	value         *string
	comment       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[setting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[setting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, setting.FieldDeletedAt)
}

// SetConfigKey sets the "config_key" field.
func (m *SettingMutation) SetConfigKey(s string) {
	m.config_key = &s
}

// ConfigKey returns the value of the "config_key" field in the mutation.
func (m *SettingMutation) ConfigKey() (r string, exists bool) {
	v := m.config_key
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigKey returns the old "config_key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldConfigKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigKey: %w", err)
	}
	return oldValue.ConfigKey, nil
}

// ResetConfigKey resets all changes to the "config_key" field.
func (m *SettingMutation) ResetConfigKey() {
	m.config_key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetComment sets the "comment" field.
func (m *SettingMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *SettingMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *SettingMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[setting.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *SettingMutation) CommentCleared() bool {
	_, ok := m.clearedFields[setting.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *SettingMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, setting.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.config_key != nil {
		fields = append(fields, setting.FieldConfigKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.comment != nil {
		fields = append(fields, setting.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldDeletedAt:
		return m.DeletedAt()
	case setting.FieldConfigKey:
		return m.ConfigKey()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldComment:
		return m.Comment()
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setting.FieldConfigKey:
		return m.OldConfigKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldComment:
		return m.OldComment(ctx)
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setting.FieldConfigKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldDeletedAt) {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.FieldCleared(setting.FieldComment) {
		fields = append(fields, setting.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case setting.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setting.FieldConfigKey:
		m.ResetConfigKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldComment:
		m.ResetComment()
		return nil
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// StoragePolicyMutation represents an operation that mutates the StoragePolicy nodes in the graph.
type StoragePolicyMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	_type         *string
	flag          *string
	server        *string
	bucket_name   *string
	is_private    *bool
	access_key    *string
	secret_key    *string
	max_size      *int64
	addmax_size   *int64
	base_path     *string
	virtual_path  *string
	settings      *model.StoragePolicySettings
	node_id       *uint
	addnode_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StoragePolicy, error)
	predicates    []predicate.StoragePolicy
}

var _ ent.Mutation = (*StoragePolicyMutation)(nil)

// storagepolicyOption allows management of the mutation configuration using functional options.
type storagepolicyOption func(*StoragePolicyMutation)

// newStoragePolicyMutation creates new mutation for the StoragePolicy entity.
func newStoragePolicyMutation(c config, op Op, opts ...storagepolicyOption) *StoragePolicyMutation {
	m := &StoragePolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeStoragePolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoragePolicyID sets the ID field of the mutation.
func withStoragePolicyID(id uint) storagepolicyOption {
	return func(m *StoragePolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *StoragePolicy
		)
		m.oldValue = func(ctx context.Context) (*StoragePolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoragePolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoragePolicy sets the old StoragePolicy of the mutation.
func withStoragePolicy(node *StoragePolicy) storagepolicyOption {
	return func(m *StoragePolicyMutation) {
		m.oldValue = func(context.Context) (*StoragePolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoragePolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoragePolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoragePolicy entities.
func (m *StoragePolicyMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoragePolicyMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoragePolicyMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoragePolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoragePolicyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoragePolicyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoragePolicyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storagepolicy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoragePolicyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoragePolicyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storagepolicy.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *StoragePolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoragePolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoragePolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoragePolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoragePolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoragePolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *StoragePolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoragePolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoragePolicyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *StoragePolicyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StoragePolicyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StoragePolicyMutation) ResetType() {
	m._type = nil
}

// SetFlag sets the "flag" field.
func (m *StoragePolicyMutation) SetFlag(s string) {
	m.flag = &s
}

// Flag returns the value of the "flag" field in the mutation.
func (m *StoragePolicyMutation) Flag() (r string, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// ClearFlag clears the value of the "flag" field.
func (m *StoragePolicyMutation) ClearFlag() {
	m.flag = nil
	m.clearedFields[storagepolicy.FieldFlag] = struct{}{}
}

// FlagCleared returns if the "flag" field was cleared in this mutation.
func (m *StoragePolicyMutation) FlagCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldFlag]
	return ok
}

// ResetFlag resets all changes to the "flag" field.
func (m *StoragePolicyMutation) ResetFlag() {
	m.flag = nil
	delete(m.clearedFields, storagepolicy.FieldFlag)
}

// SetServer sets the "server" field.
func (m *StoragePolicyMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *StoragePolicyMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ClearServer clears the value of the "server" field.
func (m *StoragePolicyMutation) ClearServer() {
	m.server = nil
	m.clearedFields[storagepolicy.FieldServer] = struct{}{}
}

// ServerCleared returns if the "server" field was cleared in this mutation.
func (m *StoragePolicyMutation) ServerCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldServer]
	return ok
}

// ResetServer resets all changes to the "server" field.
func (m *StoragePolicyMutation) ResetServer() {
	m.server = nil
	delete(m.clearedFields, storagepolicy.FieldServer)
}

// SetBucketName sets the "bucket_name" field.
func (m *StoragePolicyMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *StoragePolicyMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ClearBucketName clears the value of the "bucket_name" field.
func (m *StoragePolicyMutation) ClearBucketName() {
	m.bucket_name = nil
	m.clearedFields[storagepolicy.FieldBucketName] = struct{}{}
}

// BucketNameCleared returns if the "bucket_name" field was cleared in this mutation.
func (m *StoragePolicyMutation) BucketNameCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldBucketName]
	return ok
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *StoragePolicyMutation) ResetBucketName() {
	m.bucket_name = nil
	delete(m.clearedFields, storagepolicy.FieldBucketName)
}

// SetIsPrivate sets the "is_private" field.
func (m *StoragePolicyMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *StoragePolicyMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ClearIsPrivate clears the value of the "is_private" field.
func (m *StoragePolicyMutation) ClearIsPrivate() {
	m.is_private = nil
	m.clearedFields[storagepolicy.FieldIsPrivate] = struct{}{}
}

// IsPrivateCleared returns if the "is_private" field was cleared in this mutation.
func (m *StoragePolicyMutation) IsPrivateCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldIsPrivate]
	return ok
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *StoragePolicyMutation) ResetIsPrivate() {
	m.is_private = nil
	delete(m.clearedFields, storagepolicy.FieldIsPrivate)
}

// SetAccessKey sets the "access_key" field.
func (m *StoragePolicyMutation) SetAccessKey(s string) {
	m.access_key = &s
}

// AccessKey returns the value of the "access_key" field in the mutation.
func (m *StoragePolicyMutation) AccessKey() (r string, exists bool) {
	v := m.access_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "access_key" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldAccessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ClearAccessKey clears the value of the "access_key" field.
func (m *StoragePolicyMutation) ClearAccessKey() {
	m.access_key = nil
	m.clearedFields[storagepolicy.FieldAccessKey] = struct{}{}
}

// AccessKeyCleared returns if the "access_key" field was cleared in this mutation.
func (m *StoragePolicyMutation) AccessKeyCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldAccessKey]
	return ok
}

// ResetAccessKey resets all changes to the "access_key" field.
func (m *StoragePolicyMutation) ResetAccessKey() {
	m.access_key = nil
	delete(m.clearedFields, storagepolicy.FieldAccessKey)
}

// SetSecretKey sets the "secret_key" field.
func (m *StoragePolicyMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *StoragePolicyMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "secret_key" field.
func (m *StoragePolicyMutation) ClearSecretKey() {
	m.secret_key = nil
	m.clearedFields[storagepolicy.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "secret_key" field was cleared in this mutation.
func (m *StoragePolicyMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *StoragePolicyMutation) ResetSecretKey() {
	m.secret_key = nil
	delete(m.clearedFields, storagepolicy.FieldSecretKey)
}

// SetMaxSize sets the "max_size" field.
func (m *StoragePolicyMutation) SetMaxSize(i int64) {
	m.max_size = &i
	m.addmax_size = nil
}

// MaxSize returns the value of the "max_size" field in the mutation.
func (m *StoragePolicyMutation) MaxSize() (r int64, exists bool) {
	v := m.max_size
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSize returns the old "max_size" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldMaxSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSize: %w", err)
	}
	return oldValue.MaxSize, nil
}

// AddMaxSize adds i to the "max_size" field.
func (m *StoragePolicyMutation) AddMaxSize(i int64) {
	if m.addmax_size != nil {
		*m.addmax_size += i
	} else {
		m.addmax_size = &i
	}
}

// AddedMaxSize returns the value that was added to the "max_size" field in this mutation.
func (m *StoragePolicyMutation) AddedMaxSize() (r int64, exists bool) {
	v := m.addmax_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxSize clears the value of the "max_size" field.
func (m *StoragePolicyMutation) ClearMaxSize() {
	m.max_size = nil
	m.addmax_size = nil
	m.clearedFields[storagepolicy.FieldMaxSize] = struct{}{}
}

// MaxSizeCleared returns if the "max_size" field was cleared in this mutation.
func (m *StoragePolicyMutation) MaxSizeCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldMaxSize]
	return ok
}

// ResetMaxSize resets all changes to the "max_size" field.
func (m *StoragePolicyMutation) ResetMaxSize() {
	m.max_size = nil
	m.addmax_size = nil
	delete(m.clearedFields, storagepolicy.FieldMaxSize)
}

// SetBasePath sets the "base_path" field.
func (m *StoragePolicyMutation) SetBasePath(s string) {
	m.base_path = &s
}

// BasePath returns the value of the "base_path" field in the mutation.
func (m *StoragePolicyMutation) BasePath() (r string, exists bool) {
	v := m.base_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePath returns the old "base_path" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldBasePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePath: %w", err)
	}
	return oldValue.BasePath, nil
}

// ClearBasePath clears the value of the "base_path" field.
func (m *StoragePolicyMutation) ClearBasePath() {
	m.base_path = nil
	m.clearedFields[storagepolicy.FieldBasePath] = struct{}{}
}

// BasePathCleared returns if the "base_path" field was cleared in this mutation.
func (m *StoragePolicyMutation) BasePathCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldBasePath]
	return ok
}

// ResetBasePath resets all changes to the "base_path" field.
func (m *StoragePolicyMutation) ResetBasePath() {
	m.base_path = nil
	delete(m.clearedFields, storagepolicy.FieldBasePath)
}

// SetVirtualPath sets the "virtual_path" field.
func (m *StoragePolicyMutation) SetVirtualPath(s string) {
	m.virtual_path = &s
}

// VirtualPath returns the value of the "virtual_path" field in the mutation.
func (m *StoragePolicyMutation) VirtualPath() (r string, exists bool) {
	v := m.virtual_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualPath returns the old "virtual_path" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldVirtualPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualPath: %w", err)
	}
	return oldValue.VirtualPath, nil
}

// ClearVirtualPath clears the value of the "virtual_path" field.
func (m *StoragePolicyMutation) ClearVirtualPath() {
	m.virtual_path = nil
	m.clearedFields[storagepolicy.FieldVirtualPath] = struct{}{}
}

// VirtualPathCleared returns if the "virtual_path" field was cleared in this mutation.
func (m *StoragePolicyMutation) VirtualPathCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldVirtualPath]
	return ok
}

// ResetVirtualPath resets all changes to the "virtual_path" field.
func (m *StoragePolicyMutation) ResetVirtualPath() {
	m.virtual_path = nil
	delete(m.clearedFields, storagepolicy.FieldVirtualPath)
}

// SetSettings sets the "settings" field.
func (m *StoragePolicyMutation) SetSettings(mps model.StoragePolicySettings) {
	m.settings = &mps
}

// Settings returns the value of the "settings" field in the mutation.
func (m *StoragePolicyMutation) Settings() (r model.StoragePolicySettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldSettings(ctx context.Context) (v model.StoragePolicySettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *StoragePolicyMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[storagepolicy.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *StoragePolicyMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *StoragePolicyMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, storagepolicy.FieldSettings)
}

// SetNodeID sets the "node_id" field.
func (m *StoragePolicyMutation) SetNodeID(u uint) {
	m.node_id = &u
	m.addnode_id = nil
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *StoragePolicyMutation) NodeID() (r uint, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldNodeID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// AddNodeID adds u to the "node_id" field.
func (m *StoragePolicyMutation) AddNodeID(u int) {
	if m.addnode_id != nil {
		*m.addnode_id += u
	} else {
		m.addnode_id = &u
	}
}

// AddedNodeID returns the value that was added to the "node_id" field in this mutation.
func (m *StoragePolicyMutation) AddedNodeID() (r int, exists bool) {
	v := m.addnode_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearNodeID clears the value of the "node_id" field.
func (m *StoragePolicyMutation) ClearNodeID() {
	m.node_id = nil
	m.addnode_id = nil
	m.clearedFields[storagepolicy.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *StoragePolicyMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *StoragePolicyMutation) ResetNodeID() {
	m.node_id = nil
	m.addnode_id = nil
	delete(m.clearedFields, storagepolicy.FieldNodeID)
}

// Where appends a list predicates to the StoragePolicyMutation builder.
func (m *StoragePolicyMutation) Where(ps ...predicate.StoragePolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoragePolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoragePolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoragePolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoragePolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoragePolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoragePolicy).
func (m *StoragePolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoragePolicyMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.deleted_at != nil {
		fields = append(fields, storagepolicy.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, storagepolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storagepolicy.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, storagepolicy.FieldName)
	}
	if m._type != nil {
		fields = append(fields, storagepolicy.FieldType)
	}
	if m.flag != nil {
		fields = append(fields, storagepolicy.FieldFlag)
	}
	if m.server != nil {
		fields = append(fields, storagepolicy.FieldServer)
	}
	if m.bucket_name != nil {
		fields = append(fields, storagepolicy.FieldBucketName)
	}
	if m.is_private != nil {
		fields = append(fields, storagepolicy.FieldIsPrivate)
	}
	if m.access_key != nil {
		fields = append(fields, storagepolicy.FieldAccessKey)
	}
	if m.secret_key != nil {
		fields = append(fields, storagepolicy.FieldSecretKey)
	}
	if m.max_size != nil {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.base_path != nil {
		fields = append(fields, storagepolicy.FieldBasePath)
	}
	if m.virtual_path != nil {
		fields = append(fields, storagepolicy.FieldVirtualPath)
	}
	if m.settings != nil {
		fields = append(fields, storagepolicy.FieldSettings)
	}
	if m.node_id != nil {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoragePolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagepolicy.FieldDeletedAt:
		return m.DeletedAt()
	case storagepolicy.FieldCreatedAt:
		return m.CreatedAt()
	case storagepolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case storagepolicy.FieldName:
		return m.Name()
	case storagepolicy.FieldType:
		return m.GetType()
	case storagepolicy.FieldFlag:
		return m.Flag()
	case storagepolicy.FieldServer:
		return m.Server()
	case storagepolicy.FieldBucketName:
		return m.BucketName()
	case storagepolicy.FieldIsPrivate:
		return m.IsPrivate()
	case storagepolicy.FieldAccessKey:
		return m.AccessKey()
	case storagepolicy.FieldSecretKey:
		return m.SecretKey()
	case storagepolicy.FieldMaxSize:
		return m.MaxSize()
	case storagepolicy.FieldBasePath:
		return m.BasePath()
	case storagepolicy.FieldVirtualPath:
		return m.VirtualPath()
	case storagepolicy.FieldSettings:
		return m.Settings()
	case storagepolicy.FieldNodeID:
		return m.NodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoragePolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagepolicy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storagepolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storagepolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storagepolicy.FieldName:
		return m.OldName(ctx)
	case storagepolicy.FieldType:
		return m.OldType(ctx)
	case storagepolicy.FieldFlag:
		return m.OldFlag(ctx)
	case storagepolicy.FieldServer:
		return m.OldServer(ctx)
	case storagepolicy.FieldBucketName:
		return m.OldBucketName(ctx)
	case storagepolicy.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case storagepolicy.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case storagepolicy.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case storagepolicy.FieldMaxSize:
		return m.OldMaxSize(ctx)
	case storagepolicy.FieldBasePath:
		return m.OldBasePath(ctx)
	case storagepolicy.FieldVirtualPath:
		return m.OldVirtualPath(ctx)
	case storagepolicy.FieldSettings:
		return m.OldSettings(ctx)
	case storagepolicy.FieldNodeID:
		return m.OldNodeID(ctx)
	}
	return nil, fmt.Errorf("unknown StoragePolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storagepolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storagepolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storagepolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storagepolicy.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case storagepolicy.FieldFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	case storagepolicy.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case storagepolicy.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case storagepolicy.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case storagepolicy.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case storagepolicy.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case storagepolicy.FieldMaxSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSize(v)
		return nil
	case storagepolicy.FieldBasePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePath(v)
		return nil
	case storagepolicy.FieldVirtualPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualPath(v)
		return nil
	case storagepolicy.FieldSettings:
		v, ok := value.(model.StoragePolicySettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case storagepolicy.FieldNodeID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoragePolicyMutation) AddedFields() []string {
	var fields []string
	if m.addmax_size != nil {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.addnode_id != nil {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoragePolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storagepolicy.FieldMaxSize:
		return m.AddedMaxSize()
	case storagepolicy.FieldNodeID:
		return m.AddedNodeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storagepolicy.FieldMaxSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxSize(v)
		return nil
	case storagepolicy.FieldNodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoragePolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storagepolicy.FieldDeletedAt) {
		fields = append(fields, storagepolicy.FieldDeletedAt)
	}
	if m.FieldCleared(storagepolicy.FieldFlag) {
		fields = append(fields, storagepolicy.FieldFlag)
	}
	if m.FieldCleared(storagepolicy.FieldServer) {
		fields = append(fields, storagepolicy.FieldServer)
	}
	if m.FieldCleared(storagepolicy.FieldBucketName) {
		fields = append(fields, storagepolicy.FieldBucketName)
	}
	if m.FieldCleared(storagepolicy.FieldIsPrivate) {
		fields = append(fields, storagepolicy.FieldIsPrivate)
	}
	if m.FieldCleared(storagepolicy.FieldAccessKey) {
		fields = append(fields, storagepolicy.FieldAccessKey)
	}
	if m.FieldCleared(storagepolicy.FieldSecretKey) {
		fields = append(fields, storagepolicy.FieldSecretKey)
	}
	if m.FieldCleared(storagepolicy.FieldMaxSize) {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.FieldCleared(storagepolicy.FieldBasePath) {
		fields = append(fields, storagepolicy.FieldBasePath)
	}
	if m.FieldCleared(storagepolicy.FieldVirtualPath) {
		fields = append(fields, storagepolicy.FieldVirtualPath)
	}
	if m.FieldCleared(storagepolicy.FieldSettings) {
		fields = append(fields, storagepolicy.FieldSettings)
	}
	if m.FieldCleared(storagepolicy.FieldNodeID) {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoragePolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoragePolicyMutation) ClearField(name string) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case storagepolicy.FieldFlag:
		m.ClearFlag()
		return nil
	case storagepolicy.FieldServer:
		m.ClearServer()
		return nil
	case storagepolicy.FieldBucketName:
		m.ClearBucketName()
		return nil
	case storagepolicy.FieldIsPrivate:
		m.ClearIsPrivate()
		return nil
	case storagepolicy.FieldAccessKey:
		m.ClearAccessKey()
		return nil
	case storagepolicy.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	case storagepolicy.FieldMaxSize:
		m.ClearMaxSize()
		return nil
	case storagepolicy.FieldBasePath:
		m.ClearBasePath()
		return nil
	case storagepolicy.FieldVirtualPath:
		m.ClearVirtualPath()
		return nil
	case storagepolicy.FieldSettings:
		m.ClearSettings()
		return nil
	case storagepolicy.FieldNodeID:
		m.ClearNodeID()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoragePolicyMutation) ResetField(name string) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storagepolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storagepolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storagepolicy.FieldName:
		m.ResetName()
		return nil
	case storagepolicy.FieldType:
		m.ResetType()
		return nil
	case storagepolicy.FieldFlag:
		m.ResetFlag()
		return nil
	case storagepolicy.FieldServer:
		m.ResetServer()
		return nil
	case storagepolicy.FieldBucketName:
		m.ResetBucketName()
		return nil
	case storagepolicy.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case storagepolicy.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case storagepolicy.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case storagepolicy.FieldMaxSize:
		m.ResetMaxSize()
		return nil
	case storagepolicy.FieldBasePath:
		m.ResetBasePath()
		return nil
	case storagepolicy.FieldVirtualPath:
		m.ResetVirtualPath()
		return nil
	case storagepolicy.FieldSettings:
		m.ResetSettings()
		return nil
	case storagepolicy.FieldNodeID:
		m.ResetNodeID()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoragePolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoragePolicyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoragePolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoragePolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoragePolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoragePolicyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoragePolicyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StoragePolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoragePolicyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StoragePolicy edge %s", name)
}

// SubscriberMutation represents an operation that mutates the Subscriber nodes in the graph.
type SubscriberMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	is_active     *bool
	token         *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Subscriber, error)
	predicates    []predicate.Subscriber
}

var _ ent.Mutation = (*SubscriberMutation)(nil)

// subscriberOption allows management of the mutation configuration using functional options.
type subscriberOption func(*SubscriberMutation)

// newSubscriberMutation creates new mutation for the Subscriber entity.
func newSubscriberMutation(c config, op Op, opts ...subscriberOption) *SubscriberMutation {
	m := &SubscriberMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriberID sets the ID field of the mutation.
func withSubscriberID(id int) subscriberOption {
	return func(m *SubscriberMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscriber
		)
		m.oldValue = func(ctx context.Context) (*Subscriber, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscriber.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriber sets the old Subscriber of the mutation.
func withSubscriber(node *Subscriber) subscriberOption {
	return func(m *SubscriberMutation) {
		m.oldValue = func(context.Context) (*Subscriber, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscriber.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *SubscriberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SubscriberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SubscriberMutation) ResetEmail() {
	m.email = nil
}

// SetIsActive sets the "is_active" field.
func (m *SubscriberMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SubscriberMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SubscriberMutation) ResetIsActive() {
	m.is_active = nil
}

// SetToken sets the "token" field.
func (m *SubscriberMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SubscriberMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *SubscriberMutation) ClearToken() {
	m.token = nil
	m.clearedFields[subscriber.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *SubscriberMutation) TokenCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *SubscriberMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, subscriber.FieldToken)
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SubscriberMutation builder.
func (m *SubscriberMutation) Where(ps ...predicate.Subscriber) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscriber, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscriber).
func (m *SubscriberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.email != nil {
		fields = append(fields, subscriber.FieldEmail)
	}
	if m.is_active != nil {
		fields = append(fields, subscriber.FieldIsActive)
	}
	if m.token != nil {
		fields = append(fields, subscriber.FieldToken)
	}
	if m.created_at != nil {
		fields = append(fields, subscriber.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriber.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriber.FieldEmail:
		return m.Email()
	case subscriber.FieldIsActive:
		return m.IsActive()
	case subscriber.FieldToken:
		return m.Token()
	case subscriber.FieldCreatedAt:
		return m.CreatedAt()
	case subscriber.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriber.FieldEmail:
		return m.OldEmail(ctx)
	case subscriber.FieldIsActive:
		return m.OldIsActive(ctx)
	case subscriber.FieldToken:
		return m.OldToken(ctx)
	case subscriber.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriber.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Subscriber field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriber.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case subscriber.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case subscriber.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case subscriber.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriber.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Subscriber field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscriber numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriber.FieldToken) {
		fields = append(fields, subscriber.FieldToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriberMutation) ClearField(name string) error {
	switch name {
	case subscriber.FieldToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown Subscriber nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriberMutation) ResetField(name string) error {
	switch name {
	case subscriber.FieldEmail:
		m.ResetEmail()
		return nil
	case subscriber.FieldIsActive:
		m.ResetIsActive()
		return nil
	case subscriber.FieldToken:
		m.ResetToken()
		return nil
	case subscriber.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriber.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Subscriber field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriberMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriberMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriberMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriberMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Subscriber unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriberMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Subscriber edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uint) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tag.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.deleted_at != nil {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldDeletedAt:
		return m.DeletedAt()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeletedAt) {
		fields = append(fields, tag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// URLStatMutation represents an operation that mutates the URLStat nodes in the graph.
type URLStatMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	url_path        *string
	page_title      *string
	total_views     *int64
	addtotal_views  *int64
	unique_views    *int64
	addunique_views *int64
	bounce_count    *int64
	addbounce_count *int64
	avg_duration    *float64
	addavg_duration *float64
	last_visited_at *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*URLStat, error)
	predicates      []predicate.URLStat
}

var _ ent.Mutation = (*URLStatMutation)(nil)

// urlstatOption allows management of the mutation configuration using functional options.
type urlstatOption func(*URLStatMutation)

// newURLStatMutation creates new mutation for the URLStat entity.
func newURLStatMutation(c config, op Op, opts ...urlstatOption) *URLStatMutation {
	m := &URLStatMutation{
		config:        c,
		op:            op,
		typ:           TypeURLStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withURLStatID sets the ID field of the mutation.
func withURLStatID(id uint) urlstatOption {
	return func(m *URLStatMutation) {
		var (
			err   error
			once  sync.Once
			value *URLStat
		)
		m.oldValue = func(ctx context.Context) (*URLStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().URLStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withURLStat sets the old URLStat of the mutation.
func withURLStat(node *URLStat) urlstatOption {
	return func(m *URLStatMutation) {
		m.oldValue = func(context.Context) (*URLStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m URLStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m URLStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of URLStat entities.
func (m *URLStatMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *URLStatMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *URLStatMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().URLStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *URLStatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *URLStatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *URLStatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *URLStatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *URLStatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *URLStatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetURLPath sets the "url_path" field.
func (m *URLStatMutation) SetURLPath(s string) {
	m.url_path = &s
}

// URLPath returns the value of the "url_path" field in the mutation.
func (m *URLStatMutation) URLPath() (r string, exists bool) {
	v := m.url_path
	if v == nil {
		return
	}
	return *v, true
}

// OldURLPath returns the old "url_path" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldURLPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLPath: %w", err)
	}
	return oldValue.URLPath, nil
}

// ResetURLPath resets all changes to the "url_path" field.
func (m *URLStatMutation) ResetURLPath() {
	m.url_path = nil
}

// SetPageTitle sets the "page_title" field.
func (m *URLStatMutation) SetPageTitle(s string) {
	m.page_title = &s
}

// PageTitle returns the value of the "page_title" field in the mutation.
func (m *URLStatMutation) PageTitle() (r string, exists bool) {
	v := m.page_title
	if v == nil {
		return
	}
	return *v, true
}

// OldPageTitle returns the old "page_title" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldPageTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageTitle: %w", err)
	}
	return oldValue.PageTitle, nil
}

// ClearPageTitle clears the value of the "page_title" field.
func (m *URLStatMutation) ClearPageTitle() {
	m.page_title = nil
	m.clearedFields[urlstat.FieldPageTitle] = struct{}{}
}

// PageTitleCleared returns if the "page_title" field was cleared in this mutation.
func (m *URLStatMutation) PageTitleCleared() bool {
	_, ok := m.clearedFields[urlstat.FieldPageTitle]
	return ok
}

// ResetPageTitle resets all changes to the "page_title" field.
func (m *URLStatMutation) ResetPageTitle() {
	m.page_title = nil
	delete(m.clearedFields, urlstat.FieldPageTitle)
}

// SetTotalViews sets the "total_views" field.
func (m *URLStatMutation) SetTotalViews(i int64) {
	m.total_views = &i
	m.addtotal_views = nil
}

// TotalViews returns the value of the "total_views" field in the mutation.
func (m *URLStatMutation) TotalViews() (r int64, exists bool) {
	v := m.total_views
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalViews returns the old "total_views" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldTotalViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalViews: %w", err)
	}
	return oldValue.TotalViews, nil
}

// AddTotalViews adds i to the "total_views" field.
func (m *URLStatMutation) AddTotalViews(i int64) {
	if m.addtotal_views != nil {
		*m.addtotal_views += i
	} else {
		m.addtotal_views = &i
	}
}

// AddedTotalViews returns the value that was added to the "total_views" field in this mutation.
func (m *URLStatMutation) AddedTotalViews() (r int64, exists bool) {
	v := m.addtotal_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalViews resets all changes to the "total_views" field.
func (m *URLStatMutation) ResetTotalViews() {
	m.total_views = nil
	m.addtotal_views = nil
}

// SetUniqueViews sets the "unique_views" field.
func (m *URLStatMutation) SetUniqueViews(i int64) {
	m.unique_views = &i
	m.addunique_views = nil
}

// UniqueViews returns the value of the "unique_views" field in the mutation.
func (m *URLStatMutation) UniqueViews() (r int64, exists bool) {
	v := m.unique_views
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueViews returns the old "unique_views" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldUniqueViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueViews: %w", err)
	}
	return oldValue.UniqueViews, nil
}

// AddUniqueViews adds i to the "unique_views" field.
func (m *URLStatMutation) AddUniqueViews(i int64) {
	if m.addunique_views != nil {
		*m.addunique_views += i
	} else {
		m.addunique_views = &i
	}
}

// AddedUniqueViews returns the value that was added to the "unique_views" field in this mutation.
func (m *URLStatMutation) AddedUniqueViews() (r int64, exists bool) {
	v := m.addunique_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetUniqueViews resets all changes to the "unique_views" field.
func (m *URLStatMutation) ResetUniqueViews() {
	m.unique_views = nil
	m.addunique_views = nil
}

// SetBounceCount sets the "bounce_count" field.
func (m *URLStatMutation) SetBounceCount(i int64) {
	m.bounce_count = &i
	m.addbounce_count = nil
}

// BounceCount returns the value of the "bounce_count" field in the mutation.
func (m *URLStatMutation) BounceCount() (r int64, exists bool) {
	v := m.bounce_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBounceCount returns the old "bounce_count" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldBounceCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBounceCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBounceCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounceCount: %w", err)
	}
	return oldValue.BounceCount, nil
}

// AddBounceCount adds i to the "bounce_count" field.
func (m *URLStatMutation) AddBounceCount(i int64) {
	if m.addbounce_count != nil {
		*m.addbounce_count += i
	} else {
		m.addbounce_count = &i
	}
}

// AddedBounceCount returns the value that was added to the "bounce_count" field in this mutation.
func (m *URLStatMutation) AddedBounceCount() (r int64, exists bool) {
	v := m.addbounce_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBounceCount resets all changes to the "bounce_count" field.
func (m *URLStatMutation) ResetBounceCount() {
	m.bounce_count = nil
	m.addbounce_count = nil
}

// SetAvgDuration sets the "avg_duration" field.
func (m *URLStatMutation) SetAvgDuration(f float64) {
	m.avg_duration = &f
	m.addavg_duration = nil
}

// AvgDuration returns the value of the "avg_duration" field in the mutation.
func (m *URLStatMutation) AvgDuration() (r float64, exists bool) {
	v := m.avg_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgDuration returns the old "avg_duration" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldAvgDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgDuration: %w", err)
	}
	return oldValue.AvgDuration, nil
}

// AddAvgDuration adds f to the "avg_duration" field.
func (m *URLStatMutation) AddAvgDuration(f float64) {
	if m.addavg_duration != nil {
		*m.addavg_duration += f
	} else {
		m.addavg_duration = &f
	}
}

// AddedAvgDuration returns the value that was added to the "avg_duration" field in this mutation.
func (m *URLStatMutation) AddedAvgDuration() (r float64, exists bool) {
	v := m.addavg_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgDuration resets all changes to the "avg_duration" field.
func (m *URLStatMutation) ResetAvgDuration() {
	m.avg_duration = nil
	m.addavg_duration = nil
}

// SetLastVisitedAt sets the "last_visited_at" field.
func (m *URLStatMutation) SetLastVisitedAt(t time.Time) {
	m.last_visited_at = &t
}

// LastVisitedAt returns the value of the "last_visited_at" field in the mutation.
func (m *URLStatMutation) LastVisitedAt() (r time.Time, exists bool) {
	v := m.last_visited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVisitedAt returns the old "last_visited_at" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldLastVisitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVisitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVisitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVisitedAt: %w", err)
	}
	return oldValue.LastVisitedAt, nil
}

// ClearLastVisitedAt clears the value of the "last_visited_at" field.
func (m *URLStatMutation) ClearLastVisitedAt() {
	m.last_visited_at = nil
	m.clearedFields[urlstat.FieldLastVisitedAt] = struct{}{}
}

// LastVisitedAtCleared returns if the "last_visited_at" field was cleared in this mutation.
func (m *URLStatMutation) LastVisitedAtCleared() bool {
	_, ok := m.clearedFields[urlstat.FieldLastVisitedAt]
	return ok
}

// ResetLastVisitedAt resets all changes to the "last_visited_at" field.
func (m *URLStatMutation) ResetLastVisitedAt() {
	m.last_visited_at = nil
	delete(m.clearedFields, urlstat.FieldLastVisitedAt)
}

// Where appends a list predicates to the URLStatMutation builder.
func (m *URLStatMutation) Where(ps ...predicate.URLStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the URLStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *URLStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.URLStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *URLStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *URLStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (URLStat).
func (m *URLStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *URLStatMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, urlstat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, urlstat.FieldUpdatedAt)
	}
	if m.url_path != nil {
		fields = append(fields, urlstat.FieldURLPath)
	}
	if m.page_title != nil {
		fields = append(fields, urlstat.FieldPageTitle)
	}
	if m.total_views != nil {
		fields = append(fields, urlstat.FieldTotalViews)
	}
	if m.unique_views != nil {
		fields = append(fields, urlstat.FieldUniqueViews)
	}
	if m.bounce_count != nil {
		fields = append(fields, urlstat.FieldBounceCount)
	}
	if m.avg_duration != nil {
		fields = append(fields, urlstat.FieldAvgDuration)
	}
	if m.last_visited_at != nil {
		fields = append(fields, urlstat.FieldLastVisitedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *URLStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case urlstat.FieldCreatedAt:
		return m.CreatedAt()
	case urlstat.FieldUpdatedAt:
		return m.UpdatedAt()
	case urlstat.FieldURLPath:
		return m.URLPath()
	case urlstat.FieldPageTitle:
		return m.PageTitle()
	case urlstat.FieldTotalViews:
		return m.TotalViews()
	case urlstat.FieldUniqueViews:
		return m.UniqueViews()
	case urlstat.FieldBounceCount:
		return m.BounceCount()
	case urlstat.FieldAvgDuration:
		return m.AvgDuration()
	case urlstat.FieldLastVisitedAt:
		return m.LastVisitedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *URLStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case urlstat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case urlstat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case urlstat.FieldURLPath:
		return m.OldURLPath(ctx)
	case urlstat.FieldPageTitle:
		return m.OldPageTitle(ctx)
	case urlstat.FieldTotalViews:
		return m.OldTotalViews(ctx)
	case urlstat.FieldUniqueViews:
		return m.OldUniqueViews(ctx)
	case urlstat.FieldBounceCount:
		return m.OldBounceCount(ctx)
	case urlstat.FieldAvgDuration:
		return m.OldAvgDuration(ctx)
	case urlstat.FieldLastVisitedAt:
		return m.OldLastVisitedAt(ctx)
	}
	return nil, fmt.Errorf("unknown URLStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case urlstat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case urlstat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case urlstat.FieldURLPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLPath(v)
		return nil
	case urlstat.FieldPageTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageTitle(v)
		return nil
	case urlstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalViews(v)
		return nil
	case urlstat.FieldUniqueViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueViews(v)
		return nil
	case urlstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounceCount(v)
		return nil
	case urlstat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgDuration(v)
		return nil
	case urlstat.FieldLastVisitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVisitedAt(v)
		return nil
	}
	return fmt.Errorf("unknown URLStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *URLStatMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_views != nil {
		fields = append(fields, urlstat.FieldTotalViews)
	}
	if m.addunique_views != nil {
		fields = append(fields, urlstat.FieldUniqueViews)
	}
	if m.addbounce_count != nil {
		fields = append(fields, urlstat.FieldBounceCount)
	}
	if m.addavg_duration != nil {
		fields = append(fields, urlstat.FieldAvgDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *URLStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case urlstat.FieldTotalViews:
		return m.AddedTotalViews()
	case urlstat.FieldUniqueViews:
		return m.AddedUniqueViews()
	case urlstat.FieldBounceCount:
		return m.AddedBounceCount()
	case urlstat.FieldAvgDuration:
		return m.AddedAvgDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case urlstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalViews(v)
		return nil
	case urlstat.FieldUniqueViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUniqueViews(v)
		return nil
	case urlstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBounceCount(v)
		return nil
	case urlstat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgDuration(v)
		return nil
	}
	return fmt.Errorf("unknown URLStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *URLStatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(urlstat.FieldPageTitle) {
		fields = append(fields, urlstat.FieldPageTitle)
	}
	if m.FieldCleared(urlstat.FieldLastVisitedAt) {
		fields = append(fields, urlstat.FieldLastVisitedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *URLStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *URLStatMutation) ClearField(name string) error {
	switch name {
	case urlstat.FieldPageTitle:
		m.ClearPageTitle()
		return nil
	case urlstat.FieldLastVisitedAt:
		m.ClearLastVisitedAt()
		return nil
	}
	return fmt.Errorf("unknown URLStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *URLStatMutation) ResetField(name string) error {
	switch name {
	case urlstat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case urlstat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case urlstat.FieldURLPath:
		m.ResetURLPath()
		return nil
	case urlstat.FieldPageTitle:
		m.ResetPageTitle()
		return nil
	case urlstat.FieldTotalViews:
		m.ResetTotalViews()
		return nil
	case urlstat.FieldUniqueViews:
		m.ResetUniqueViews()
		return nil
	case urlstat.FieldBounceCount:
		m.ResetBounceCount()
		return nil
	case urlstat.FieldAvgDuration:
		m.ResetAvgDuration()
		return nil
	case urlstat.FieldLastVisitedAt:
		m.ResetLastVisitedAt()
		return nil
	}
	return fmt.Errorf("unknown URLStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *URLStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *URLStatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *URLStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *URLStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *URLStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *URLStatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *URLStatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown URLStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *URLStatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown URLStat edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uint
	deleted_at                  *time.Time
	created_at                  *time.Time
	updated_at                  *time.Time
	username                    *string
	password_hash               *string
	nickname                    *string
	avatar                      *string
	email                       *string
	website                     *string
	last_login_at               *time.Time
	status                      *int
	addstatus                   *int
	clearedFields               map[string]struct{}
	user_group                  *uint
	cleareduser_group           bool
	files                       map[uint]struct{}
	removedfiles                map[uint]struct{}
	clearedfiles                bool
	comments                    map[uint]struct{}
	removedcomments             map[uint]struct{}
	clearedcomments             bool
	installed_themes            map[uint]struct{}
	removedinstalled_themes     map[uint]struct{}
	clearedinstalled_themes     bool
	notification_configs        map[uint]struct{}
	removednotification_configs map[uint]struct{}
	clearednotification_configs bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetWebsite sets the "website" field.
func (m *UserMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *UserMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *UserMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[user.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *UserMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[user.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *UserMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, user.FieldWebsite)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetUserGroupID sets the "user_group" edge to the UserGroup entity by id.
func (m *UserMutation) SetUserGroupID(id uint) {
	m.user_group = &id
}

// ClearUserGroup clears the "user_group" edge to the UserGroup entity.
func (m *UserMutation) ClearUserGroup() {
	m.cleareduser_group = true
}

// UserGroupCleared reports if the "user_group" edge to the UserGroup entity was cleared.
func (m *UserMutation) UserGroupCleared() bool {
	return m.cleareduser_group
}

// UserGroupID returns the "user_group" edge ID in the mutation.
func (m *UserMutation) UserGroupID() (id uint, exists bool) {
	if m.user_group != nil {
		return *m.user_group, true
	}
	return
}

// UserGroupIDs returns the "user_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserGroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserGroupIDs() (ids []uint) {
	if id := m.user_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserGroup resets all changes to the "user_group" edge.
func (m *UserMutation) ResetUserGroup() {
	m.user_group = nil
	m.cleareduser_group = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...uint) {
	if m.files == nil {
		m.files = make(map[uint]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...uint) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []uint) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []uint) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...uint) {
	if m.comments == nil {
		m.comments = make(map[uint]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...uint) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []uint) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []uint) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddInstalledThemeIDs adds the "installed_themes" edge to the UserInstalledTheme entity by ids.
func (m *UserMutation) AddInstalledThemeIDs(ids ...uint) {
	if m.installed_themes == nil {
		m.installed_themes = make(map[uint]struct{})
	}
	for i := range ids {
		m.installed_themes[ids[i]] = struct{}{}
	}
}

// ClearInstalledThemes clears the "installed_themes" edge to the UserInstalledTheme entity.
func (m *UserMutation) ClearInstalledThemes() {
	m.clearedinstalled_themes = true
}

// InstalledThemesCleared reports if the "installed_themes" edge to the UserInstalledTheme entity was cleared.
func (m *UserMutation) InstalledThemesCleared() bool {
	return m.clearedinstalled_themes
}

// RemoveInstalledThemeIDs removes the "installed_themes" edge to the UserInstalledTheme entity by IDs.
func (m *UserMutation) RemoveInstalledThemeIDs(ids ...uint) {
	if m.removedinstalled_themes == nil {
		m.removedinstalled_themes = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.installed_themes, ids[i])
		m.removedinstalled_themes[ids[i]] = struct{}{}
	}
}

// RemovedInstalledThemes returns the removed IDs of the "installed_themes" edge to the UserInstalledTheme entity.
func (m *UserMutation) RemovedInstalledThemesIDs() (ids []uint) {
	for id := range m.removedinstalled_themes {
		ids = append(ids, id)
	}
	return
}

// InstalledThemesIDs returns the "installed_themes" edge IDs in the mutation.
func (m *UserMutation) InstalledThemesIDs() (ids []uint) {
	for id := range m.installed_themes {
		ids = append(ids, id)
	}
	return
}

// ResetInstalledThemes resets all changes to the "installed_themes" edge.
func (m *UserMutation) ResetInstalledThemes() {
	m.installed_themes = nil
	m.clearedinstalled_themes = false
	m.removedinstalled_themes = nil
}

// AddNotificationConfigIDs adds the "notification_configs" edge to the UserNotificationConfig entity by ids.
func (m *UserMutation) AddNotificationConfigIDs(ids ...uint) {
	if m.notification_configs == nil {
		m.notification_configs = make(map[uint]struct{})
	}
	for i := range ids {
		m.notification_configs[ids[i]] = struct{}{}
	}
}

// ClearNotificationConfigs clears the "notification_configs" edge to the UserNotificationConfig entity.
func (m *UserMutation) ClearNotificationConfigs() {
	m.clearednotification_configs = true
}

// NotificationConfigsCleared reports if the "notification_configs" edge to the UserNotificationConfig entity was cleared.
func (m *UserMutation) NotificationConfigsCleared() bool {
	return m.clearednotification_configs
}

// RemoveNotificationConfigIDs removes the "notification_configs" edge to the UserNotificationConfig entity by IDs.
func (m *UserMutation) RemoveNotificationConfigIDs(ids ...uint) {
	if m.removednotification_configs == nil {
		m.removednotification_configs = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.notification_configs, ids[i])
		m.removednotification_configs[ids[i]] = struct{}{}
	}
}

// RemovedNotificationConfigs returns the removed IDs of the "notification_configs" edge to the UserNotificationConfig entity.
func (m *UserMutation) RemovedNotificationConfigsIDs() (ids []uint) {
	for id := range m.removednotification_configs {
		ids = append(ids, id)
	}
	return
}

// NotificationConfigsIDs returns the "notification_configs" edge IDs in the mutation.
func (m *UserMutation) NotificationConfigsIDs() (ids []uint) {
	for id := range m.notification_configs {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationConfigs resets all changes to the "notification_configs" edge.
func (m *UserMutation) ResetNotificationConfigs() {
	m.notification_configs = nil
	m.clearednotification_configs = false
	m.removednotification_configs = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.website != nil {
		fields = append(fields, user.FieldWebsite)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldEmail:
		return m.Email()
	case user.FieldWebsite:
		return m.Website()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldWebsite:
		return m.OldWebsite(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldWebsite) {
		fields = append(fields, user.FieldWebsite)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldWebsite:
		m.ClearWebsite()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldWebsite:
		m.ResetWebsite()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user_group != nil {
		edges = append(edges, user.EdgeUserGroup)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.installed_themes != nil {
		edges = append(edges, user.EdgeInstalledThemes)
	}
	if m.notification_configs != nil {
		edges = append(edges, user.EdgeNotificationConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserGroup:
		if id := m.user_group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstalledThemes:
		ids := make([]ent.Value, 0, len(m.installed_themes))
		for id := range m.installed_themes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationConfigs:
		ids := make([]ent.Value, 0, len(m.notification_configs))
		for id := range m.notification_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedinstalled_themes != nil {
		edges = append(edges, user.EdgeInstalledThemes)
	}
	if m.removednotification_configs != nil {
		edges = append(edges, user.EdgeNotificationConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstalledThemes:
		ids := make([]ent.Value, 0, len(m.removedinstalled_themes))
		for id := range m.removedinstalled_themes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationConfigs:
		ids := make([]ent.Value, 0, len(m.removednotification_configs))
		for id := range m.removednotification_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser_group {
		edges = append(edges, user.EdgeUserGroup)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedinstalled_themes {
		edges = append(edges, user.EdgeInstalledThemes)
	}
	if m.clearednotification_configs {
		edges = append(edges, user.EdgeNotificationConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserGroup:
		return m.cleareduser_group
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeInstalledThemes:
		return m.clearedinstalled_themes
	case user.EdgeNotificationConfigs:
		return m.clearednotification_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserGroup:
		m.ClearUserGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserGroup:
		m.ResetUserGroup()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeInstalledThemes:
		m.ResetInstalledThemes()
		return nil
	case user.EdgeNotificationConfigs:
		m.ResetNotificationConfigs()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserGroupMutation represents an operation that mutates the UserGroup nodes in the graph.
type UserGroupMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint
	deleted_at               *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	name                     *string
	description              *string
	permissions              *model.Boolset
	max_storage              *int64
	addmax_storage           *int64
	speed_limit              *int64
	addspeed_limit           *int64
	settings                 **model.GroupSettings
	storage_policy_ids       *[]uint
	appendstorage_policy_ids []uint
	clearedFields            map[string]struct{}
	users                    map[uint]struct{}
	removedusers             map[uint]struct{}
	clearedusers             bool
	done                     bool
	oldValue                 func(context.Context) (*UserGroup, error)
	predicates               []predicate.UserGroup
}

var _ ent.Mutation = (*UserGroupMutation)(nil)

// usergroupOption allows management of the mutation configuration using functional options.
type usergroupOption func(*UserGroupMutation)

// newUserGroupMutation creates new mutation for the UserGroup entity.
func newUserGroupMutation(c config, op Op, opts ...usergroupOption) *UserGroupMutation {
	m := &UserGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserGroupID sets the ID field of the mutation.
func withUserGroupID(id uint) usergroupOption {
	return func(m *UserGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserGroup
		)
		m.oldValue = func(ctx context.Context) (*UserGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserGroup sets the old UserGroup of the mutation.
func withUserGroup(node *UserGroup) usergroupOption {
	return func(m *UserGroupMutation) {
		m.oldValue = func(context.Context) (*UserGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserGroup entities.
func (m *UserGroupMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserGroupMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserGroupMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserGroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserGroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserGroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usergroup.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserGroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserGroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usergroup.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UserGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[usergroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, usergroup.FieldDescription)
}

// SetPermissions sets the "permissions" field.
func (m *UserGroupMutation) SetPermissions(value model.Boolset) {
	m.permissions = &value
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserGroupMutation) Permissions() (r model.Boolset, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldPermissions(ctx context.Context) (v model.Boolset, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserGroupMutation) ResetPermissions() {
	m.permissions = nil
}

// SetMaxStorage sets the "max_storage" field.
func (m *UserGroupMutation) SetMaxStorage(i int64) {
	m.max_storage = &i
	m.addmax_storage = nil
}

// MaxStorage returns the value of the "max_storage" field in the mutation.
func (m *UserGroupMutation) MaxStorage() (r int64, exists bool) {
	v := m.max_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxStorage returns the old "max_storage" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldMaxStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxStorage: %w", err)
	}
	return oldValue.MaxStorage, nil
}

// AddMaxStorage adds i to the "max_storage" field.
func (m *UserGroupMutation) AddMaxStorage(i int64) {
	if m.addmax_storage != nil {
		*m.addmax_storage += i
	} else {
		m.addmax_storage = &i
	}
}

// AddedMaxStorage returns the value that was added to the "max_storage" field in this mutation.
func (m *UserGroupMutation) AddedMaxStorage() (r int64, exists bool) {
	v := m.addmax_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxStorage resets all changes to the "max_storage" field.
func (m *UserGroupMutation) ResetMaxStorage() {
	m.max_storage = nil
	m.addmax_storage = nil
}

// SetSpeedLimit sets the "speed_limit" field.
func (m *UserGroupMutation) SetSpeedLimit(i int64) {
	m.speed_limit = &i
	m.addspeed_limit = nil
}

// SpeedLimit returns the value of the "speed_limit" field in the mutation.
func (m *UserGroupMutation) SpeedLimit() (r int64, exists bool) {
	v := m.speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedLimit returns the old "speed_limit" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldSpeedLimit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedLimit: %w", err)
	}
	return oldValue.SpeedLimit, nil
}

// AddSpeedLimit adds i to the "speed_limit" field.
func (m *UserGroupMutation) AddSpeedLimit(i int64) {
	if m.addspeed_limit != nil {
		*m.addspeed_limit += i
	} else {
		m.addspeed_limit = &i
	}
}

// AddedSpeedLimit returns the value that was added to the "speed_limit" field in this mutation.
func (m *UserGroupMutation) AddedSpeedLimit() (r int64, exists bool) {
	v := m.addspeed_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeedLimit resets all changes to the "speed_limit" field.
func (m *UserGroupMutation) ResetSpeedLimit() {
	m.speed_limit = nil
	m.addspeed_limit = nil
}

// SetSettings sets the "settings" field.
func (m *UserGroupMutation) SetSettings(ms *model.GroupSettings) {
	m.settings = &ms
}

// Settings returns the value of the "settings" field in the mutation.
func (m *UserGroupMutation) Settings() (r *model.GroupSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldSettings(ctx context.Context) (v *model.GroupSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *UserGroupMutation) ResetSettings() {
	m.settings = nil
}

// SetStoragePolicyIds sets the "storage_policy_ids" field.
func (m *UserGroupMutation) SetStoragePolicyIds(u []uint) {
	m.storage_policy_ids = &u
	m.appendstorage_policy_ids = nil
}

// StoragePolicyIds returns the value of the "storage_policy_ids" field in the mutation.
func (m *UserGroupMutation) StoragePolicyIds() (r []uint, exists bool) {
	v := m.storage_policy_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePolicyIds returns the old "storage_policy_ids" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldStoragePolicyIds(ctx context.Context) (v []uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePolicyIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePolicyIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePolicyIds: %w", err)
	}
	return oldValue.StoragePolicyIds, nil
}

// AppendStoragePolicyIds adds u to the "storage_policy_ids" field.
func (m *UserGroupMutation) AppendStoragePolicyIds(u []uint) {
	m.appendstorage_policy_ids = append(m.appendstorage_policy_ids, u...)
}

// AppendedStoragePolicyIds returns the list of values that were appended to the "storage_policy_ids" field in this mutation.
func (m *UserGroupMutation) AppendedStoragePolicyIds() ([]uint, bool) {
	if len(m.appendstorage_policy_ids) == 0 {
		return nil, false
	}
	return m.appendstorage_policy_ids, true
}

// ClearStoragePolicyIds clears the value of the "storage_policy_ids" field.
func (m *UserGroupMutation) ClearStoragePolicyIds() {
	m.storage_policy_ids = nil
	m.appendstorage_policy_ids = nil
	m.clearedFields[usergroup.FieldStoragePolicyIds] = struct{}{}
}

// StoragePolicyIdsCleared returns if the "storage_policy_ids" field was cleared in this mutation.
func (m *UserGroupMutation) StoragePolicyIdsCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldStoragePolicyIds]
	return ok
}

// ResetStoragePolicyIds resets all changes to the "storage_policy_ids" field.
func (m *UserGroupMutation) ResetStoragePolicyIds() {
	m.storage_policy_ids = nil
	m.appendstorage_policy_ids = nil
	delete(m.clearedFields, usergroup.FieldStoragePolicyIds)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *UserGroupMutation) AddUserIDs(ids ...uint) {
	if m.users == nil {
		m.users = make(map[uint]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserGroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserGroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *UserGroupMutation) RemoveUserIDs(ids ...uint) {
	if m.removedusers == nil {
		m.removedusers = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *UserGroupMutation) RemovedUsersIDs() (ids []uint) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *UserGroupMutation) UsersIDs() (ids []uint) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserGroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the UserGroupMutation builder.
func (m *UserGroupMutation) Where(ps ...predicate.UserGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserGroup).
func (m *UserGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserGroupMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, usergroup.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, usergroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usergroup.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, usergroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, usergroup.FieldDescription)
	}
	if m.permissions != nil {
		fields = append(fields, usergroup.FieldPermissions)
	}
	if m.max_storage != nil {
		fields = append(fields, usergroup.FieldMaxStorage)
	}
	if m.speed_limit != nil {
		fields = append(fields, usergroup.FieldSpeedLimit)
	}
	if m.settings != nil {
		fields = append(fields, usergroup.FieldSettings)
	}
	if m.storage_policy_ids != nil {
		fields = append(fields, usergroup.FieldStoragePolicyIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usergroup.FieldDeletedAt:
		return m.DeletedAt()
	case usergroup.FieldCreatedAt:
		return m.CreatedAt()
	case usergroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case usergroup.FieldName:
		return m.Name()
	case usergroup.FieldDescription:
		return m.Description()
	case usergroup.FieldPermissions:
		return m.Permissions()
	case usergroup.FieldMaxStorage:
		return m.MaxStorage()
	case usergroup.FieldSpeedLimit:
		return m.SpeedLimit()
	case usergroup.FieldSettings:
		return m.Settings()
	case usergroup.FieldStoragePolicyIds:
		return m.StoragePolicyIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usergroup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usergroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usergroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usergroup.FieldName:
		return m.OldName(ctx)
	case usergroup.FieldDescription:
		return m.OldDescription(ctx)
	case usergroup.FieldPermissions:
		return m.OldPermissions(ctx)
	case usergroup.FieldMaxStorage:
		return m.OldMaxStorage(ctx)
	case usergroup.FieldSpeedLimit:
		return m.OldSpeedLimit(ctx)
	case usergroup.FieldSettings:
		return m.OldSettings(ctx)
	case usergroup.FieldStoragePolicyIds:
		return m.OldStoragePolicyIds(ctx)
	}
	return nil, fmt.Errorf("unknown UserGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usergroup.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usergroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usergroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usergroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usergroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case usergroup.FieldPermissions:
		v, ok := value.(model.Boolset)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case usergroup.FieldMaxStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxStorage(v)
		return nil
	case usergroup.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedLimit(v)
		return nil
	case usergroup.FieldSettings:
		v, ok := value.(*model.GroupSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case usergroup.FieldStoragePolicyIds:
		v, ok := value.([]uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePolicyIds(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserGroupMutation) AddedFields() []string {
	var fields []string
	if m.addmax_storage != nil {
		fields = append(fields, usergroup.FieldMaxStorage)
	}
	if m.addspeed_limit != nil {
		fields = append(fields, usergroup.FieldSpeedLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usergroup.FieldMaxStorage:
		return m.AddedMaxStorage()
	case usergroup.FieldSpeedLimit:
		return m.AddedSpeedLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usergroup.FieldMaxStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxStorage(v)
		return nil
	case usergroup.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedLimit(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usergroup.FieldDeletedAt) {
		fields = append(fields, usergroup.FieldDeletedAt)
	}
	if m.FieldCleared(usergroup.FieldDescription) {
		fields = append(fields, usergroup.FieldDescription)
	}
	if m.FieldCleared(usergroup.FieldStoragePolicyIds) {
		fields = append(fields, usergroup.FieldStoragePolicyIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserGroupMutation) ClearField(name string) error {
	switch name {
	case usergroup.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usergroup.FieldDescription:
		m.ClearDescription()
		return nil
	case usergroup.FieldStoragePolicyIds:
		m.ClearStoragePolicyIds()
		return nil
	}
	return fmt.Errorf("unknown UserGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserGroupMutation) ResetField(name string) error {
	switch name {
	case usergroup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usergroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usergroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usergroup.FieldName:
		m.ResetName()
		return nil
	case usergroup.FieldDescription:
		m.ResetDescription()
		return nil
	case usergroup.FieldPermissions:
		m.ResetPermissions()
		return nil
	case usergroup.FieldMaxStorage:
		m.ResetMaxStorage()
		return nil
	case usergroup.FieldSpeedLimit:
		m.ResetSpeedLimit()
		return nil
	case usergroup.FieldSettings:
		m.ResetSettings()
		return nil
	case usergroup.FieldStoragePolicyIds:
		m.ResetStoragePolicyIds()
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, usergroup.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, usergroup.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, usergroup.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case usergroup.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserGroupMutation) ResetEdge(name string) error {
	switch name {
	case usergroup.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserGroup edge %s", name)
}

// UserInstalledThemeMutation represents an operation that mutates the UserInstalledTheme nodes in the graph.
type UserInstalledThemeMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	deleted_at         *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	theme_name         *string
	theme_market_id    *int
	addtheme_market_id *int
	is_current         *bool
	install_time       *time.Time
	user_theme_config  *map[string]interface{}
	installed_version  *string
	clearedFields      map[string]struct{}
	user               *uint
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserInstalledTheme, error)
	predicates         []predicate.UserInstalledTheme
}

var _ ent.Mutation = (*UserInstalledThemeMutation)(nil)

// userinstalledthemeOption allows management of the mutation configuration using functional options.
type userinstalledthemeOption func(*UserInstalledThemeMutation)

// newUserInstalledThemeMutation creates new mutation for the UserInstalledTheme entity.
func newUserInstalledThemeMutation(c config, op Op, opts ...userinstalledthemeOption) *UserInstalledThemeMutation {
	m := &UserInstalledThemeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserInstalledTheme,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserInstalledThemeID sets the ID field of the mutation.
func withUserInstalledThemeID(id uint) userinstalledthemeOption {
	return func(m *UserInstalledThemeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserInstalledTheme
		)
		m.oldValue = func(ctx context.Context) (*UserInstalledTheme, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserInstalledTheme.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserInstalledTheme sets the old UserInstalledTheme of the mutation.
func withUserInstalledTheme(node *UserInstalledTheme) userinstalledthemeOption {
	return func(m *UserInstalledThemeMutation) {
		m.oldValue = func(context.Context) (*UserInstalledTheme, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserInstalledThemeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserInstalledThemeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserInstalledTheme entities.
func (m *UserInstalledThemeMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserInstalledThemeMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserInstalledThemeMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserInstalledTheme.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserInstalledThemeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserInstalledThemeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserInstalledThemeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userinstalledtheme.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserInstalledThemeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userinstalledtheme.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserInstalledThemeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserInstalledThemeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserInstalledThemeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserInstalledThemeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserInstalledThemeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserInstalledThemeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserInstalledThemeMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserInstalledThemeMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserInstalledThemeMutation) ResetUserID() {
	m.user = nil
}

// SetThemeName sets the "theme_name" field.
func (m *UserInstalledThemeMutation) SetThemeName(s string) {
	m.theme_name = &s
}

// ThemeName returns the value of the "theme_name" field in the mutation.
func (m *UserInstalledThemeMutation) ThemeName() (r string, exists bool) {
	v := m.theme_name
	if v == nil {
		return
	}
	return *v, true
}

// OldThemeName returns the old "theme_name" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldThemeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThemeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThemeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThemeName: %w", err)
	}
	return oldValue.ThemeName, nil
}

// ResetThemeName resets all changes to the "theme_name" field.
func (m *UserInstalledThemeMutation) ResetThemeName() {
	m.theme_name = nil
}

// SetThemeMarketID sets the "theme_market_id" field.
func (m *UserInstalledThemeMutation) SetThemeMarketID(i int) {
	m.theme_market_id = &i
	m.addtheme_market_id = nil
}

// ThemeMarketID returns the value of the "theme_market_id" field in the mutation.
func (m *UserInstalledThemeMutation) ThemeMarketID() (r int, exists bool) {
	v := m.theme_market_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThemeMarketID returns the old "theme_market_id" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldThemeMarketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThemeMarketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThemeMarketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThemeMarketID: %w", err)
	}
	return oldValue.ThemeMarketID, nil
}

// AddThemeMarketID adds i to the "theme_market_id" field.
func (m *UserInstalledThemeMutation) AddThemeMarketID(i int) {
	if m.addtheme_market_id != nil {
		*m.addtheme_market_id += i
	} else {
		m.addtheme_market_id = &i
	}
}

// AddedThemeMarketID returns the value that was added to the "theme_market_id" field in this mutation.
func (m *UserInstalledThemeMutation) AddedThemeMarketID() (r int, exists bool) {
	v := m.addtheme_market_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearThemeMarketID clears the value of the "theme_market_id" field.
func (m *UserInstalledThemeMutation) ClearThemeMarketID() {
	m.theme_market_id = nil
	m.addtheme_market_id = nil
	m.clearedFields[userinstalledtheme.FieldThemeMarketID] = struct{}{}
}

// ThemeMarketIDCleared returns if the "theme_market_id" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) ThemeMarketIDCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldThemeMarketID]
	return ok
}

// ResetThemeMarketID resets all changes to the "theme_market_id" field.
func (m *UserInstalledThemeMutation) ResetThemeMarketID() {
	m.theme_market_id = nil
	m.addtheme_market_id = nil
	delete(m.clearedFields, userinstalledtheme.FieldThemeMarketID)
}

// SetIsCurrent sets the "is_current" field.
func (m *UserInstalledThemeMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *UserInstalledThemeMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *UserInstalledThemeMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetInstallTime sets the "install_time" field.
func (m *UserInstalledThemeMutation) SetInstallTime(t time.Time) {
	m.install_time = &t
}

// InstallTime returns the value of the "install_time" field in the mutation.
func (m *UserInstalledThemeMutation) InstallTime() (r time.Time, exists bool) {
	v := m.install_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallTime returns the old "install_time" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldInstallTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallTime: %w", err)
	}
	return oldValue.InstallTime, nil
}

// ResetInstallTime resets all changes to the "install_time" field.
func (m *UserInstalledThemeMutation) ResetInstallTime() {
	m.install_time = nil
}

// SetUserThemeConfig sets the "user_theme_config" field.
func (m *UserInstalledThemeMutation) SetUserThemeConfig(value map[string]interface{}) {
	m.user_theme_config = &value
}

// UserThemeConfig returns the value of the "user_theme_config" field in the mutation.
func (m *UserInstalledThemeMutation) UserThemeConfig() (r map[string]interface{}, exists bool) {
	v := m.user_theme_config
	if v == nil {
		return
	}
	return *v, true
}

// OldUserThemeConfig returns the old "user_theme_config" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldUserThemeConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserThemeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserThemeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserThemeConfig: %w", err)
	}
	return oldValue.UserThemeConfig, nil
}

// ClearUserThemeConfig clears the value of the "user_theme_config" field.
func (m *UserInstalledThemeMutation) ClearUserThemeConfig() {
	m.user_theme_config = nil
	m.clearedFields[userinstalledtheme.FieldUserThemeConfig] = struct{}{}
}

// UserThemeConfigCleared returns if the "user_theme_config" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) UserThemeConfigCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldUserThemeConfig]
	return ok
}

// ResetUserThemeConfig resets all changes to the "user_theme_config" field.
func (m *UserInstalledThemeMutation) ResetUserThemeConfig() {
	m.user_theme_config = nil
	delete(m.clearedFields, userinstalledtheme.FieldUserThemeConfig)
}

// SetInstalledVersion sets the "installed_version" field.
func (m *UserInstalledThemeMutation) SetInstalledVersion(s string) {
	m.installed_version = &s
}

// InstalledVersion returns the value of the "installed_version" field in the mutation.
func (m *UserInstalledThemeMutation) InstalledVersion() (r string, exists bool) {
	v := m.installed_version
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledVersion returns the old "installed_version" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldInstalledVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledVersion: %w", err)
	}
	return oldValue.InstalledVersion, nil
}

// ClearInstalledVersion clears the value of the "installed_version" field.
func (m *UserInstalledThemeMutation) ClearInstalledVersion() {
	m.installed_version = nil
	m.clearedFields[userinstalledtheme.FieldInstalledVersion] = struct{}{}
}

// InstalledVersionCleared returns if the "installed_version" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) InstalledVersionCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldInstalledVersion]
	return ok
}

// ResetInstalledVersion resets all changes to the "installed_version" field.
func (m *UserInstalledThemeMutation) ResetInstalledVersion() {
	m.installed_version = nil
	delete(m.clearedFields, userinstalledtheme.FieldInstalledVersion)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserInstalledThemeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userinstalledtheme.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserInstalledThemeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserInstalledThemeMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserInstalledThemeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserInstalledThemeMutation builder.
func (m *UserInstalledThemeMutation) Where(ps ...predicate.UserInstalledTheme) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserInstalledThemeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserInstalledThemeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserInstalledTheme, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserInstalledThemeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserInstalledThemeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserInstalledTheme).
func (m *UserInstalledThemeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserInstalledThemeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, userinstalledtheme.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, userinstalledtheme.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userinstalledtheme.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userinstalledtheme.FieldUserID)
	}
	if m.theme_name != nil {
		fields = append(fields, userinstalledtheme.FieldThemeName)
	}
	if m.theme_market_id != nil {
		fields = append(fields, userinstalledtheme.FieldThemeMarketID)
	}
	if m.is_current != nil {
		fields = append(fields, userinstalledtheme.FieldIsCurrent)
	}
	if m.install_time != nil {
		fields = append(fields, userinstalledtheme.FieldInstallTime)
	}
	if m.user_theme_config != nil {
		fields = append(fields, userinstalledtheme.FieldUserThemeConfig)
	}
	if m.installed_version != nil {
		fields = append(fields, userinstalledtheme.FieldInstalledVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserInstalledThemeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		return m.DeletedAt()
	case userinstalledtheme.FieldCreatedAt:
		return m.CreatedAt()
	case userinstalledtheme.FieldUpdatedAt:
		return m.UpdatedAt()
	case userinstalledtheme.FieldUserID:
		return m.UserID()
	case userinstalledtheme.FieldThemeName:
		return m.ThemeName()
	case userinstalledtheme.FieldThemeMarketID:
		return m.ThemeMarketID()
	case userinstalledtheme.FieldIsCurrent:
		return m.IsCurrent()
	case userinstalledtheme.FieldInstallTime:
		return m.InstallTime()
	case userinstalledtheme.FieldUserThemeConfig:
		return m.UserThemeConfig()
	case userinstalledtheme.FieldInstalledVersion:
		return m.InstalledVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserInstalledThemeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userinstalledtheme.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userinstalledtheme.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userinstalledtheme.FieldUserID:
		return m.OldUserID(ctx)
	case userinstalledtheme.FieldThemeName:
		return m.OldThemeName(ctx)
	case userinstalledtheme.FieldThemeMarketID:
		return m.OldThemeMarketID(ctx)
	case userinstalledtheme.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case userinstalledtheme.FieldInstallTime:
		return m.OldInstallTime(ctx)
	case userinstalledtheme.FieldUserThemeConfig:
		return m.OldUserThemeConfig(ctx)
	case userinstalledtheme.FieldInstalledVersion:
		return m.OldInstalledVersion(ctx)
	}
	return nil, fmt.Errorf("unknown UserInstalledTheme field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInstalledThemeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userinstalledtheme.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userinstalledtheme.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userinstalledtheme.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userinstalledtheme.FieldThemeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThemeName(v)
		return nil
	case userinstalledtheme.FieldThemeMarketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThemeMarketID(v)
		return nil
	case userinstalledtheme.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case userinstalledtheme.FieldInstallTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallTime(v)
		return nil
	case userinstalledtheme.FieldUserThemeConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserThemeConfig(v)
		return nil
	case userinstalledtheme.FieldInstalledVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserInstalledThemeMutation) AddedFields() []string {
	var fields []string
	if m.addtheme_market_id != nil {
		fields = append(fields, userinstalledtheme.FieldThemeMarketID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserInstalledThemeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userinstalledtheme.FieldThemeMarketID:
		return m.AddedThemeMarketID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInstalledThemeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userinstalledtheme.FieldThemeMarketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThemeMarketID(v)
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserInstalledThemeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userinstalledtheme.FieldDeletedAt) {
		fields = append(fields, userinstalledtheme.FieldDeletedAt)
	}
	if m.FieldCleared(userinstalledtheme.FieldThemeMarketID) {
		fields = append(fields, userinstalledtheme.FieldThemeMarketID)
	}
	if m.FieldCleared(userinstalledtheme.FieldUserThemeConfig) {
		fields = append(fields, userinstalledtheme.FieldUserThemeConfig)
	}
	if m.FieldCleared(userinstalledtheme.FieldInstalledVersion) {
		fields = append(fields, userinstalledtheme.FieldInstalledVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserInstalledThemeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserInstalledThemeMutation) ClearField(name string) error {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userinstalledtheme.FieldThemeMarketID:
		m.ClearThemeMarketID()
		return nil
	case userinstalledtheme.FieldUserThemeConfig:
		m.ClearUserThemeConfig()
		return nil
	case userinstalledtheme.FieldInstalledVersion:
		m.ClearInstalledVersion()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserInstalledThemeMutation) ResetField(name string) error {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userinstalledtheme.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userinstalledtheme.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userinstalledtheme.FieldUserID:
		m.ResetUserID()
		return nil
	case userinstalledtheme.FieldThemeName:
		m.ResetThemeName()
		return nil
	case userinstalledtheme.FieldThemeMarketID:
		m.ResetThemeMarketID()
		return nil
	case userinstalledtheme.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case userinstalledtheme.FieldInstallTime:
		m.ResetInstallTime()
		return nil
	case userinstalledtheme.FieldUserThemeConfig:
		m.ResetUserThemeConfig()
		return nil
	case userinstalledtheme.FieldInstalledVersion:
		m.ResetInstalledVersion()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserInstalledThemeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userinstalledtheme.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserInstalledThemeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userinstalledtheme.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserInstalledThemeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserInstalledThemeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserInstalledThemeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userinstalledtheme.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserInstalledThemeMutation) EdgeCleared(name string) bool {
	switch name {
	case userinstalledtheme.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserInstalledThemeMutation) ClearEdge(name string) error {
	switch name {
	case userinstalledtheme.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserInstalledThemeMutation) ResetEdge(name string) error {
	switch name {
	case userinstalledtheme.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme edge %s", name)
}

// UserNotificationConfigMutation represents an operation that mutates the UserNotificationConfig nodes in the graph.
type UserNotificationConfigMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint
	created_at               *time.Time
	updated_at               *time.Time
	is_enabled               *bool
	enabled_channels         *[]string
	appendenabled_channels   []string
	notification_email       *string
	custom_settings          *map[string]interface{}
	clearedFields            map[string]struct{}
	user                     *uint
	cleareduser              bool
	notification_type        *uint
	clearednotification_type bool
	done                     bool
	oldValue                 func(context.Context) (*UserNotificationConfig, error)
	predicates               []predicate.UserNotificationConfig
}

var _ ent.Mutation = (*UserNotificationConfigMutation)(nil)

// usernotificationconfigOption allows management of the mutation configuration using functional options.
type usernotificationconfigOption func(*UserNotificationConfigMutation)

// newUserNotificationConfigMutation creates new mutation for the UserNotificationConfig entity.
func newUserNotificationConfigMutation(c config, op Op, opts ...usernotificationconfigOption) *UserNotificationConfigMutation {
	m := &UserNotificationConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNotificationConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNotificationConfigID sets the ID field of the mutation.
func withUserNotificationConfigID(id uint) usernotificationconfigOption {
	return func(m *UserNotificationConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNotificationConfig
		)
		m.oldValue = func(ctx context.Context) (*UserNotificationConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNotificationConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNotificationConfig sets the old UserNotificationConfig of the mutation.
func withUserNotificationConfig(node *UserNotificationConfig) usernotificationconfigOption {
	return func(m *UserNotificationConfigMutation) {
		m.oldValue = func(context.Context) (*UserNotificationConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNotificationConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNotificationConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserNotificationConfig entities.
func (m *UserNotificationConfigMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNotificationConfigMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNotificationConfigMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNotificationConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserNotificationConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserNotificationConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserNotificationConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserNotificationConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserNotificationConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserNotificationConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserNotificationConfigMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserNotificationConfigMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserNotificationConfigMutation) ResetUserID() {
	m.user = nil
}

// SetNotificationTypeID sets the "notification_type_id" field.
func (m *UserNotificationConfigMutation) SetNotificationTypeID(u uint) {
	m.notification_type = &u
}

// NotificationTypeID returns the value of the "notification_type_id" field in the mutation.
func (m *UserNotificationConfigMutation) NotificationTypeID() (r uint, exists bool) {
	v := m.notification_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationTypeID returns the old "notification_type_id" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldNotificationTypeID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationTypeID: %w", err)
	}
	return oldValue.NotificationTypeID, nil
}

// ResetNotificationTypeID resets all changes to the "notification_type_id" field.
func (m *UserNotificationConfigMutation) ResetNotificationTypeID() {
	m.notification_type = nil
}

// SetIsEnabled sets the "is_enabled" field.
func (m *UserNotificationConfigMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *UserNotificationConfigMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *UserNotificationConfigMutation) ResetIsEnabled() {
	m.is_enabled = nil
}

// SetEnabledChannels sets the "enabled_channels" field.
func (m *UserNotificationConfigMutation) SetEnabledChannels(s []string) {
	m.enabled_channels = &s
	m.appendenabled_channels = nil
}

// EnabledChannels returns the value of the "enabled_channels" field in the mutation.
func (m *UserNotificationConfigMutation) EnabledChannels() (r []string, exists bool) {
	v := m.enabled_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabledChannels returns the old "enabled_channels" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldEnabledChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabledChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabledChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabledChannels: %w", err)
	}
	return oldValue.EnabledChannels, nil
}

// AppendEnabledChannels adds s to the "enabled_channels" field.
func (m *UserNotificationConfigMutation) AppendEnabledChannels(s []string) {
	m.appendenabled_channels = append(m.appendenabled_channels, s...)
}

// AppendedEnabledChannels returns the list of values that were appended to the "enabled_channels" field in this mutation.
func (m *UserNotificationConfigMutation) AppendedEnabledChannels() ([]string, bool) {
	if len(m.appendenabled_channels) == 0 {
		return nil, false
	}
	return m.appendenabled_channels, true
}

// ClearEnabledChannels clears the value of the "enabled_channels" field.
func (m *UserNotificationConfigMutation) ClearEnabledChannels() {
	m.enabled_channels = nil
	m.appendenabled_channels = nil
	m.clearedFields[usernotificationconfig.FieldEnabledChannels] = struct{}{}
}

// EnabledChannelsCleared returns if the "enabled_channels" field was cleared in this mutation.
func (m *UserNotificationConfigMutation) EnabledChannelsCleared() bool {
	_, ok := m.clearedFields[usernotificationconfig.FieldEnabledChannels]
	return ok
}

// ResetEnabledChannels resets all changes to the "enabled_channels" field.
func (m *UserNotificationConfigMutation) ResetEnabledChannels() {
	m.enabled_channels = nil
	m.appendenabled_channels = nil
	delete(m.clearedFields, usernotificationconfig.FieldEnabledChannels)
}

// SetNotificationEmail sets the "notification_email" field.
func (m *UserNotificationConfigMutation) SetNotificationEmail(s string) {
	m.notification_email = &s
}

// NotificationEmail returns the value of the "notification_email" field in the mutation.
func (m *UserNotificationConfigMutation) NotificationEmail() (r string, exists bool) {
	v := m.notification_email
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationEmail returns the old "notification_email" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldNotificationEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationEmail: %w", err)
	}
	return oldValue.NotificationEmail, nil
}

// ClearNotificationEmail clears the value of the "notification_email" field.
func (m *UserNotificationConfigMutation) ClearNotificationEmail() {
	m.notification_email = nil
	m.clearedFields[usernotificationconfig.FieldNotificationEmail] = struct{}{}
}

// NotificationEmailCleared returns if the "notification_email" field was cleared in this mutation.
func (m *UserNotificationConfigMutation) NotificationEmailCleared() bool {
	_, ok := m.clearedFields[usernotificationconfig.FieldNotificationEmail]
	return ok
}

// ResetNotificationEmail resets all changes to the "notification_email" field.
func (m *UserNotificationConfigMutation) ResetNotificationEmail() {
	m.notification_email = nil
	delete(m.clearedFields, usernotificationconfig.FieldNotificationEmail)
}

// SetCustomSettings sets the "custom_settings" field.
func (m *UserNotificationConfigMutation) SetCustomSettings(value map[string]interface{}) {
	m.custom_settings = &value
}

// CustomSettings returns the value of the "custom_settings" field in the mutation.
func (m *UserNotificationConfigMutation) CustomSettings() (r map[string]interface{}, exists bool) {
	v := m.custom_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomSettings returns the old "custom_settings" field's value of the UserNotificationConfig entity.
// If the UserNotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationConfigMutation) OldCustomSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomSettings: %w", err)
	}
	return oldValue.CustomSettings, nil
}

// ClearCustomSettings clears the value of the "custom_settings" field.
func (m *UserNotificationConfigMutation) ClearCustomSettings() {
	m.custom_settings = nil
	m.clearedFields[usernotificationconfig.FieldCustomSettings] = struct{}{}
}

// CustomSettingsCleared returns if the "custom_settings" field was cleared in this mutation.
func (m *UserNotificationConfigMutation) CustomSettingsCleared() bool {
	_, ok := m.clearedFields[usernotificationconfig.FieldCustomSettings]
	return ok
}

// ResetCustomSettings resets all changes to the "custom_settings" field.
func (m *UserNotificationConfigMutation) ResetCustomSettings() {
	m.custom_settings = nil
	delete(m.clearedFields, usernotificationconfig.FieldCustomSettings)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserNotificationConfigMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usernotificationconfig.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserNotificationConfigMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserNotificationConfigMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserNotificationConfigMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearNotificationType clears the "notification_type" edge to the NotificationType entity.
func (m *UserNotificationConfigMutation) ClearNotificationType() {
	m.clearednotification_type = true
	m.clearedFields[usernotificationconfig.FieldNotificationTypeID] = struct{}{}
}

// NotificationTypeCleared reports if the "notification_type" edge to the NotificationType entity was cleared.
func (m *UserNotificationConfigMutation) NotificationTypeCleared() bool {
	return m.clearednotification_type
}

// NotificationTypeIDs returns the "notification_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationTypeID instead. It exists only for internal usage by the builders.
func (m *UserNotificationConfigMutation) NotificationTypeIDs() (ids []uint) {
	if id := m.notification_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotificationType resets all changes to the "notification_type" edge.
func (m *UserNotificationConfigMutation) ResetNotificationType() {
	m.notification_type = nil
	m.clearednotification_type = false
}

// Where appends a list predicates to the UserNotificationConfigMutation builder.
func (m *UserNotificationConfigMutation) Where(ps ...predicate.UserNotificationConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNotificationConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNotificationConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNotificationConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNotificationConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNotificationConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNotificationConfig).
func (m *UserNotificationConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNotificationConfigMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, usernotificationconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usernotificationconfig.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, usernotificationconfig.FieldUserID)
	}
	if m.notification_type != nil {
		fields = append(fields, usernotificationconfig.FieldNotificationTypeID)
	}
	if m.is_enabled != nil {
		fields = append(fields, usernotificationconfig.FieldIsEnabled)
	}
	if m.enabled_channels != nil {
		fields = append(fields, usernotificationconfig.FieldEnabledChannels)
	}
	if m.notification_email != nil {
		fields = append(fields, usernotificationconfig.FieldNotificationEmail)
	}
	if m.custom_settings != nil {
		fields = append(fields, usernotificationconfig.FieldCustomSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNotificationConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernotificationconfig.FieldCreatedAt:
		return m.CreatedAt()
	case usernotificationconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case usernotificationconfig.FieldUserID:
		return m.UserID()
	case usernotificationconfig.FieldNotificationTypeID:
		return m.NotificationTypeID()
	case usernotificationconfig.FieldIsEnabled:
		return m.IsEnabled()
	case usernotificationconfig.FieldEnabledChannels:
		return m.EnabledChannels()
	case usernotificationconfig.FieldNotificationEmail:
		return m.NotificationEmail()
	case usernotificationconfig.FieldCustomSettings:
		return m.CustomSettings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNotificationConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernotificationconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usernotificationconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usernotificationconfig.FieldUserID:
		return m.OldUserID(ctx)
	case usernotificationconfig.FieldNotificationTypeID:
		return m.OldNotificationTypeID(ctx)
	case usernotificationconfig.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case usernotificationconfig.FieldEnabledChannels:
		return m.OldEnabledChannels(ctx)
	case usernotificationconfig.FieldNotificationEmail:
		return m.OldNotificationEmail(ctx)
	case usernotificationconfig.FieldCustomSettings:
		return m.OldCustomSettings(ctx)
	}
	return nil, fmt.Errorf("unknown UserNotificationConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernotificationconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usernotificationconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usernotificationconfig.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usernotificationconfig.FieldNotificationTypeID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationTypeID(v)
		return nil
	case usernotificationconfig.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case usernotificationconfig.FieldEnabledChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabledChannels(v)
		return nil
	case usernotificationconfig.FieldNotificationEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationEmail(v)
		return nil
	case usernotificationconfig.FieldCustomSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomSettings(v)
		return nil
	}
	return fmt.Errorf("unknown UserNotificationConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNotificationConfigMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNotificationConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNotificationConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNotificationConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usernotificationconfig.FieldEnabledChannels) {
		fields = append(fields, usernotificationconfig.FieldEnabledChannels)
	}
	if m.FieldCleared(usernotificationconfig.FieldNotificationEmail) {
		fields = append(fields, usernotificationconfig.FieldNotificationEmail)
	}
	if m.FieldCleared(usernotificationconfig.FieldCustomSettings) {
		fields = append(fields, usernotificationconfig.FieldCustomSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNotificationConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNotificationConfigMutation) ClearField(name string) error {
	switch name {
	case usernotificationconfig.FieldEnabledChannels:
		m.ClearEnabledChannels()
		return nil
	case usernotificationconfig.FieldNotificationEmail:
		m.ClearNotificationEmail()
		return nil
	case usernotificationconfig.FieldCustomSettings:
		m.ClearCustomSettings()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNotificationConfigMutation) ResetField(name string) error {
	switch name {
	case usernotificationconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usernotificationconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usernotificationconfig.FieldUserID:
		m.ResetUserID()
		return nil
	case usernotificationconfig.FieldNotificationTypeID:
		m.ResetNotificationTypeID()
		return nil
	case usernotificationconfig.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case usernotificationconfig.FieldEnabledChannels:
		m.ResetEnabledChannels()
		return nil
	case usernotificationconfig.FieldNotificationEmail:
		m.ResetNotificationEmail()
		return nil
	case usernotificationconfig.FieldCustomSettings:
		m.ResetCustomSettings()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNotificationConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usernotificationconfig.EdgeUser)
	}
	if m.notification_type != nil {
		edges = append(edges, usernotificationconfig.EdgeNotificationType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNotificationConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernotificationconfig.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usernotificationconfig.EdgeNotificationType:
		if id := m.notification_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNotificationConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNotificationConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNotificationConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usernotificationconfig.EdgeUser)
	}
	if m.clearednotification_type {
		edges = append(edges, usernotificationconfig.EdgeNotificationType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNotificationConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case usernotificationconfig.EdgeUser:
		return m.cleareduser
	case usernotificationconfig.EdgeNotificationType:
		return m.clearednotification_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNotificationConfigMutation) ClearEdge(name string) error {
	switch name {
	case usernotificationconfig.EdgeUser:
		m.ClearUser()
		return nil
	case usernotificationconfig.EdgeNotificationType:
		m.ClearNotificationType()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNotificationConfigMutation) ResetEdge(name string) error {
	switch name {
	case usernotificationconfig.EdgeUser:
		m.ResetUser()
		return nil
	case usernotificationconfig.EdgeNotificationType:
		m.ResetNotificationType()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationConfig edge %s", name)
}

// VisitorLogMutation represents an operation that mutates the VisitorLog nodes in the graph.
type VisitorLogMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	visitor_id    *string
	session_id    *string
	ip_address    *string
	user_agent    *string
	referer       *string
	url_path      *string
	country       *string
	region        *string
	city          *string
	browser       *string
	os            *string
	device        *string
	duration      *int
	addduration   *int
	is_bounce     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VisitorLog, error)
	predicates    []predicate.VisitorLog
}

var _ ent.Mutation = (*VisitorLogMutation)(nil)

// visitorlogOption allows management of the mutation configuration using functional options.
type visitorlogOption func(*VisitorLogMutation)

// newVisitorLogMutation creates new mutation for the VisitorLog entity.
func newVisitorLogMutation(c config, op Op, opts ...visitorlogOption) *VisitorLogMutation {
	m := &VisitorLogMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitorLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitorLogID sets the ID field of the mutation.
func withVisitorLogID(id uint) visitorlogOption {
	return func(m *VisitorLogMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitorLog
		)
		m.oldValue = func(ctx context.Context) (*VisitorLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitorLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitorLog sets the old VisitorLog of the mutation.
func withVisitorLog(node *VisitorLog) visitorlogOption {
	return func(m *VisitorLogMutation) {
		m.oldValue = func(context.Context) (*VisitorLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitorLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitorLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitorLog entities.
func (m *VisitorLogMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitorLogMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitorLogMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitorLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitorLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitorLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitorLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetVisitorID sets the "visitor_id" field.
func (m *VisitorLogMutation) SetVisitorID(s string) {
	m.visitor_id = &s
}

// VisitorID returns the value of the "visitor_id" field in the mutation.
func (m *VisitorLogMutation) VisitorID() (r string, exists bool) {
	v := m.visitor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitorID returns the old "visitor_id" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldVisitorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisitorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisitorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitorID: %w", err)
	}
	return oldValue.VisitorID, nil
}

// ResetVisitorID resets all changes to the "visitor_id" field.
func (m *VisitorLogMutation) ResetVisitorID() {
	m.visitor_id = nil
}

// SetSessionID sets the "session_id" field.
func (m *VisitorLogMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *VisitorLogMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *VisitorLogMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[visitorlog.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *VisitorLogMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *VisitorLogMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, visitorlog.FieldSessionID)
}

// SetIPAddress sets the "ip_address" field.
func (m *VisitorLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *VisitorLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *VisitorLogMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *VisitorLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *VisitorLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *VisitorLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[visitorlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *VisitorLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *VisitorLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, visitorlog.FieldUserAgent)
}

// SetReferer sets the "referer" field.
func (m *VisitorLogMutation) SetReferer(s string) {
	m.referer = &s
}

// Referer returns the value of the "referer" field in the mutation.
func (m *VisitorLogMutation) Referer() (r string, exists bool) {
	v := m.referer
	if v == nil {
		return
	}
	return *v, true
}

// OldReferer returns the old "referer" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldReferer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferer: %w", err)
	}
	return oldValue.Referer, nil
}

// ClearReferer clears the value of the "referer" field.
func (m *VisitorLogMutation) ClearReferer() {
	m.referer = nil
	m.clearedFields[visitorlog.FieldReferer] = struct{}{}
}

// RefererCleared returns if the "referer" field was cleared in this mutation.
func (m *VisitorLogMutation) RefererCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldReferer]
	return ok
}

// ResetReferer resets all changes to the "referer" field.
func (m *VisitorLogMutation) ResetReferer() {
	m.referer = nil
	delete(m.clearedFields, visitorlog.FieldReferer)
}

// SetURLPath sets the "url_path" field.
func (m *VisitorLogMutation) SetURLPath(s string) {
	m.url_path = &s
}

// URLPath returns the value of the "url_path" field in the mutation.
func (m *VisitorLogMutation) URLPath() (r string, exists bool) {
	v := m.url_path
	if v == nil {
		return
	}
	return *v, true
}

// OldURLPath returns the old "url_path" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldURLPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLPath: %w", err)
	}
	return oldValue.URLPath, nil
}

// ResetURLPath resets all changes to the "url_path" field.
func (m *VisitorLogMutation) ResetURLPath() {
	m.url_path = nil
}

// SetCountry sets the "country" field.
func (m *VisitorLogMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *VisitorLogMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *VisitorLogMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[visitorlog.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *VisitorLogMutation) CountryCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *VisitorLogMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, visitorlog.FieldCountry)
}

// SetRegion sets the "region" field.
func (m *VisitorLogMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *VisitorLogMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldRegion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *VisitorLogMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[visitorlog.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *VisitorLogMutation) RegionCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *VisitorLogMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, visitorlog.FieldRegion)
}

// SetCity sets the "city" field.
func (m *VisitorLogMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VisitorLogMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *VisitorLogMutation) ClearCity() {
	m.city = nil
	m.clearedFields[visitorlog.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *VisitorLogMutation) CityCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *VisitorLogMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, visitorlog.FieldCity)
}

// SetBrowser sets the "browser" field.
func (m *VisitorLogMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *VisitorLogMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldBrowser(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ClearBrowser clears the value of the "browser" field.
func (m *VisitorLogMutation) ClearBrowser() {
	m.browser = nil
	m.clearedFields[visitorlog.FieldBrowser] = struct{}{}
}

// BrowserCleared returns if the "browser" field was cleared in this mutation.
func (m *VisitorLogMutation) BrowserCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldBrowser]
	return ok
}

// ResetBrowser resets all changes to the "browser" field.
func (m *VisitorLogMutation) ResetBrowser() {
	m.browser = nil
	delete(m.clearedFields, visitorlog.FieldBrowser)
}

// SetOs sets the "os" field.
func (m *VisitorLogMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *VisitorLogMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldOs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *VisitorLogMutation) ClearOs() {
	m.os = nil
	m.clearedFields[visitorlog.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *VisitorLogMutation) OsCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *VisitorLogMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, visitorlog.FieldOs)
}

// SetDevice sets the "device" field.
func (m *VisitorLogMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *VisitorLogMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldDevice(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *VisitorLogMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[visitorlog.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *VisitorLogMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *VisitorLogMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, visitorlog.FieldDevice)
}

// SetDuration sets the "duration" field.
func (m *VisitorLogMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VisitorLogMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *VisitorLogMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *VisitorLogMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *VisitorLogMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetIsBounce sets the "is_bounce" field.
func (m *VisitorLogMutation) SetIsBounce(b bool) {
	m.is_bounce = &b
}

// IsBounce returns the value of the "is_bounce" field in the mutation.
func (m *VisitorLogMutation) IsBounce() (r bool, exists bool) {
	v := m.is_bounce
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBounce returns the old "is_bounce" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldIsBounce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBounce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBounce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBounce: %w", err)
	}
	return oldValue.IsBounce, nil
}

// ResetIsBounce resets all changes to the "is_bounce" field.
func (m *VisitorLogMutation) ResetIsBounce() {
	m.is_bounce = nil
}

// Where appends a list predicates to the VisitorLogMutation builder.
func (m *VisitorLogMutation) Where(ps ...predicate.VisitorLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitorLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitorLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitorLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitorLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitorLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitorLog).
func (m *VisitorLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitorLogMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, visitorlog.FieldCreatedAt)
	}
	if m.visitor_id != nil {
		fields = append(fields, visitorlog.FieldVisitorID)
	}
	if m.session_id != nil {
		fields = append(fields, visitorlog.FieldSessionID)
	}
	if m.ip_address != nil {
		fields = append(fields, visitorlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, visitorlog.FieldUserAgent)
	}
	if m.referer != nil {
		fields = append(fields, visitorlog.FieldReferer)
	}
	if m.url_path != nil {
		fields = append(fields, visitorlog.FieldURLPath)
	}
	if m.country != nil {
		fields = append(fields, visitorlog.FieldCountry)
	}
	if m.region != nil {
		fields = append(fields, visitorlog.FieldRegion)
	}
	if m.city != nil {
		fields = append(fields, visitorlog.FieldCity)
	}
	if m.browser != nil {
		fields = append(fields, visitorlog.FieldBrowser)
	}
	if m.os != nil {
		fields = append(fields, visitorlog.FieldOs)
	}
	if m.device != nil {
		fields = append(fields, visitorlog.FieldDevice)
	}
	if m.duration != nil {
		fields = append(fields, visitorlog.FieldDuration)
	}
	if m.is_bounce != nil {
		fields = append(fields, visitorlog.FieldIsBounce)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitorLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitorlog.FieldCreatedAt:
		return m.CreatedAt()
	case visitorlog.FieldVisitorID:
		return m.VisitorID()
	case visitorlog.FieldSessionID:
		return m.SessionID()
	case visitorlog.FieldIPAddress:
		return m.IPAddress()
	case visitorlog.FieldUserAgent:
		return m.UserAgent()
	case visitorlog.FieldReferer:
		return m.Referer()
	case visitorlog.FieldURLPath:
		return m.URLPath()
	case visitorlog.FieldCountry:
		return m.Country()
	case visitorlog.FieldRegion:
		return m.Region()
	case visitorlog.FieldCity:
		return m.City()
	case visitorlog.FieldBrowser:
		return m.Browser()
	case visitorlog.FieldOs:
		return m.Os()
	case visitorlog.FieldDevice:
		return m.Device()
	case visitorlog.FieldDuration:
		return m.Duration()
	case visitorlog.FieldIsBounce:
		return m.IsBounce()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitorLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitorlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitorlog.FieldVisitorID:
		return m.OldVisitorID(ctx)
	case visitorlog.FieldSessionID:
		return m.OldSessionID(ctx)
	case visitorlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case visitorlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case visitorlog.FieldReferer:
		return m.OldReferer(ctx)
	case visitorlog.FieldURLPath:
		return m.OldURLPath(ctx)
	case visitorlog.FieldCountry:
		return m.OldCountry(ctx)
	case visitorlog.FieldRegion:
		return m.OldRegion(ctx)
	case visitorlog.FieldCity:
		return m.OldCity(ctx)
	case visitorlog.FieldBrowser:
		return m.OldBrowser(ctx)
	case visitorlog.FieldOs:
		return m.OldOs(ctx)
	case visitorlog.FieldDevice:
		return m.OldDevice(ctx)
	case visitorlog.FieldDuration:
		return m.OldDuration(ctx)
	case visitorlog.FieldIsBounce:
		return m.OldIsBounce(ctx)
	}
	return nil, fmt.Errorf("unknown VisitorLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitorlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitorlog.FieldVisitorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitorID(v)
		return nil
	case visitorlog.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case visitorlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case visitorlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case visitorlog.FieldReferer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferer(v)
		return nil
	case visitorlog.FieldURLPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLPath(v)
		return nil
	case visitorlog.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case visitorlog.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case visitorlog.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case visitorlog.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case visitorlog.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case visitorlog.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case visitorlog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case visitorlog.FieldIsBounce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBounce(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitorLogMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, visitorlog.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitorLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visitorlog.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visitorlog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitorLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(visitorlog.FieldSessionID) {
		fields = append(fields, visitorlog.FieldSessionID)
	}
	if m.FieldCleared(visitorlog.FieldUserAgent) {
		fields = append(fields, visitorlog.FieldUserAgent)
	}
	if m.FieldCleared(visitorlog.FieldReferer) {
		fields = append(fields, visitorlog.FieldReferer)
	}
	if m.FieldCleared(visitorlog.FieldCountry) {
		fields = append(fields, visitorlog.FieldCountry)
	}
	if m.FieldCleared(visitorlog.FieldRegion) {
		fields = append(fields, visitorlog.FieldRegion)
	}
	if m.FieldCleared(visitorlog.FieldCity) {
		fields = append(fields, visitorlog.FieldCity)
	}
	if m.FieldCleared(visitorlog.FieldBrowser) {
		fields = append(fields, visitorlog.FieldBrowser)
	}
	if m.FieldCleared(visitorlog.FieldOs) {
		fields = append(fields, visitorlog.FieldOs)
	}
	if m.FieldCleared(visitorlog.FieldDevice) {
		fields = append(fields, visitorlog.FieldDevice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitorLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitorLogMutation) ClearField(name string) error {
	switch name {
	case visitorlog.FieldSessionID:
		m.ClearSessionID()
		return nil
	case visitorlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case visitorlog.FieldReferer:
		m.ClearReferer()
		return nil
	case visitorlog.FieldCountry:
		m.ClearCountry()
		return nil
	case visitorlog.FieldRegion:
		m.ClearRegion()
		return nil
	case visitorlog.FieldCity:
		m.ClearCity()
		return nil
	case visitorlog.FieldBrowser:
		m.ClearBrowser()
		return nil
	case visitorlog.FieldOs:
		m.ClearOs()
		return nil
	case visitorlog.FieldDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown VisitorLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitorLogMutation) ResetField(name string) error {
	switch name {
	case visitorlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitorlog.FieldVisitorID:
		m.ResetVisitorID()
		return nil
	case visitorlog.FieldSessionID:
		m.ResetSessionID()
		return nil
	case visitorlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case visitorlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case visitorlog.FieldReferer:
		m.ResetReferer()
		return nil
	case visitorlog.FieldURLPath:
		m.ResetURLPath()
		return nil
	case visitorlog.FieldCountry:
		m.ResetCountry()
		return nil
	case visitorlog.FieldRegion:
		m.ResetRegion()
		return nil
	case visitorlog.FieldCity:
		m.ResetCity()
		return nil
	case visitorlog.FieldBrowser:
		m.ResetBrowser()
		return nil
	case visitorlog.FieldOs:
		m.ResetOs()
		return nil
	case visitorlog.FieldDevice:
		m.ResetDevice()
		return nil
	case visitorlog.FieldDuration:
		m.ResetDuration()
		return nil
	case visitorlog.FieldIsBounce:
		m.ResetIsBounce()
		return nil
	}
	return fmt.Errorf("unknown VisitorLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitorLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitorLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitorLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitorLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitorLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitorLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitorLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VisitorLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitorLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VisitorLog edge %s", name)
}

// VisitorStatMutation represents an operation that mutates the VisitorStat nodes in the graph.
type VisitorStatMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	created_at         *time.Time
	updated_at         *time.Time
	date               *time.Time
	unique_visitors    *int64
	addunique_visitors *int64
	total_views        *int64
	addtotal_views     *int64
	page_views         *int64
	addpage_views      *int64
	bounce_count       *int64
	addbounce_count    *int64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*VisitorStat, error)
	predicates         []predicate.VisitorStat
}

var _ ent.Mutation = (*VisitorStatMutation)(nil)

// visitorstatOption allows management of the mutation configuration using functional options.
type visitorstatOption func(*VisitorStatMutation)

// newVisitorStatMutation creates new mutation for the VisitorStat entity.
func newVisitorStatMutation(c config, op Op, opts ...visitorstatOption) *VisitorStatMutation {
	m := &VisitorStatMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitorStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitorStatID sets the ID field of the mutation.
func withVisitorStatID(id uint) visitorstatOption {
	return func(m *VisitorStatMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitorStat
		)
		m.oldValue = func(ctx context.Context) (*VisitorStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitorStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitorStat sets the old VisitorStat of the mutation.
func withVisitorStat(node *VisitorStat) visitorstatOption {
	return func(m *VisitorStatMutation) {
		m.oldValue = func(context.Context) (*VisitorStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitorStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitorStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitorStat entities.
func (m *VisitorStatMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitorStatMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitorStatMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitorStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitorStatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitorStatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitorStatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VisitorStatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VisitorStatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VisitorStatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDate sets the "date" field.
func (m *VisitorStatMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *VisitorStatMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *VisitorStatMutation) ResetDate() {
	m.date = nil
}

// SetUniqueVisitors sets the "unique_visitors" field.
func (m *VisitorStatMutation) SetUniqueVisitors(i int64) {
	m.unique_visitors = &i
	m.addunique_visitors = nil
}

// UniqueVisitors returns the value of the "unique_visitors" field in the mutation.
func (m *VisitorStatMutation) UniqueVisitors() (r int64, exists bool) {
	v := m.unique_visitors
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueVisitors returns the old "unique_visitors" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldUniqueVisitors(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueVisitors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueVisitors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueVisitors: %w", err)
	}
	return oldValue.UniqueVisitors, nil
}

// AddUniqueVisitors adds i to the "unique_visitors" field.
func (m *VisitorStatMutation) AddUniqueVisitors(i int64) {
	if m.addunique_visitors != nil {
		*m.addunique_visitors += i
	} else {
		m.addunique_visitors = &i
	}
}

// AddedUniqueVisitors returns the value that was added to the "unique_visitors" field in this mutation.
func (m *VisitorStatMutation) AddedUniqueVisitors() (r int64, exists bool) {
	v := m.addunique_visitors
	if v == nil {
		return
	}
	return *v, true
}

// ResetUniqueVisitors resets all changes to the "unique_visitors" field.
func (m *VisitorStatMutation) ResetUniqueVisitors() {
	m.unique_visitors = nil
	m.addunique_visitors = nil
}

// SetTotalViews sets the "total_views" field.
func (m *VisitorStatMutation) SetTotalViews(i int64) {
	m.total_views = &i
	m.addtotal_views = nil
}

// TotalViews returns the value of the "total_views" field in the mutation.
func (m *VisitorStatMutation) TotalViews() (r int64, exists bool) {
	v := m.total_views
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalViews returns the old "total_views" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldTotalViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalViews: %w", err)
	}
	return oldValue.TotalViews, nil
}

// AddTotalViews adds i to the "total_views" field.
func (m *VisitorStatMutation) AddTotalViews(i int64) {
	if m.addtotal_views != nil {
		*m.addtotal_views += i
	} else {
		m.addtotal_views = &i
	}
}

// AddedTotalViews returns the value that was added to the "total_views" field in this mutation.
func (m *VisitorStatMutation) AddedTotalViews() (r int64, exists bool) {
	v := m.addtotal_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalViews resets all changes to the "total_views" field.
func (m *VisitorStatMutation) ResetTotalViews() {
	m.total_views = nil
	m.addtotal_views = nil
}

// SetPageViews sets the "page_views" field.
func (m *VisitorStatMutation) SetPageViews(i int64) {
	m.page_views = &i
	m.addpage_views = nil
}

// PageViews returns the value of the "page_views" field in the mutation.
func (m *VisitorStatMutation) PageViews() (r int64, exists bool) {
	v := m.page_views
	if v == nil {
		return
	}
	return *v, true
}

// OldPageViews returns the old "page_views" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldPageViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageViews: %w", err)
	}
	return oldValue.PageViews, nil
}

// AddPageViews adds i to the "page_views" field.
func (m *VisitorStatMutation) AddPageViews(i int64) {
	if m.addpage_views != nil {
		*m.addpage_views += i
	} else {
		m.addpage_views = &i
	}
}

// AddedPageViews returns the value that was added to the "page_views" field in this mutation.
func (m *VisitorStatMutation) AddedPageViews() (r int64, exists bool) {
	v := m.addpage_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageViews resets all changes to the "page_views" field.
func (m *VisitorStatMutation) ResetPageViews() {
	m.page_views = nil
	m.addpage_views = nil
}

// SetBounceCount sets the "bounce_count" field.
func (m *VisitorStatMutation) SetBounceCount(i int64) {
	m.bounce_count = &i
	m.addbounce_count = nil
}

// BounceCount returns the value of the "bounce_count" field in the mutation.
func (m *VisitorStatMutation) BounceCount() (r int64, exists bool) {
	v := m.bounce_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBounceCount returns the old "bounce_count" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldBounceCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBounceCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBounceCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounceCount: %w", err)
	}
	return oldValue.BounceCount, nil
}

// AddBounceCount adds i to the "bounce_count" field.
func (m *VisitorStatMutation) AddBounceCount(i int64) {
	if m.addbounce_count != nil {
		*m.addbounce_count += i
	} else {
		m.addbounce_count = &i
	}
}

// AddedBounceCount returns the value that was added to the "bounce_count" field in this mutation.
func (m *VisitorStatMutation) AddedBounceCount() (r int64, exists bool) {
	v := m.addbounce_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBounceCount resets all changes to the "bounce_count" field.
func (m *VisitorStatMutation) ResetBounceCount() {
	m.bounce_count = nil
	m.addbounce_count = nil
}

// Where appends a list predicates to the VisitorStatMutation builder.
func (m *VisitorStatMutation) Where(ps ...predicate.VisitorStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitorStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitorStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitorStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitorStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitorStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitorStat).
func (m *VisitorStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitorStatMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, visitorstat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, visitorstat.FieldUpdatedAt)
	}
	if m.date != nil {
		fields = append(fields, visitorstat.FieldDate)
	}
	if m.unique_visitors != nil {
		fields = append(fields, visitorstat.FieldUniqueVisitors)
	}
	if m.total_views != nil {
		fields = append(fields, visitorstat.FieldTotalViews)
	}
	if m.page_views != nil {
		fields = append(fields, visitorstat.FieldPageViews)
	}
	if m.bounce_count != nil {
		fields = append(fields, visitorstat.FieldBounceCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitorStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitorstat.FieldCreatedAt:
		return m.CreatedAt()
	case visitorstat.FieldUpdatedAt:
		return m.UpdatedAt()
	case visitorstat.FieldDate:
		return m.Date()
	case visitorstat.FieldUniqueVisitors:
		return m.UniqueVisitors()
	case visitorstat.FieldTotalViews:
		return m.TotalViews()
	case visitorstat.FieldPageViews:
		return m.PageViews()
	case visitorstat.FieldBounceCount:
		return m.BounceCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitorStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitorstat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitorstat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case visitorstat.FieldDate:
		return m.OldDate(ctx)
	case visitorstat.FieldUniqueVisitors:
		return m.OldUniqueVisitors(ctx)
	case visitorstat.FieldTotalViews:
		return m.OldTotalViews(ctx)
	case visitorstat.FieldPageViews:
		return m.OldPageViews(ctx)
	case visitorstat.FieldBounceCount:
		return m.OldBounceCount(ctx)
	}
	return nil, fmt.Errorf("unknown VisitorStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitorstat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitorstat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case visitorstat.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case visitorstat.FieldUniqueVisitors:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueVisitors(v)
		return nil
	case visitorstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalViews(v)
		return nil
	case visitorstat.FieldPageViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageViews(v)
		return nil
	case visitorstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounceCount(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitorStatMutation) AddedFields() []string {
	var fields []string
	if m.addunique_visitors != nil {
		fields = append(fields, visitorstat.FieldUniqueVisitors)
	}
	if m.addtotal_views != nil {
		fields = append(fields, visitorstat.FieldTotalViews)
	}
	if m.addpage_views != nil {
		fields = append(fields, visitorstat.FieldPageViews)
	}
	if m.addbounce_count != nil {
		fields = append(fields, visitorstat.FieldBounceCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitorStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visitorstat.FieldUniqueVisitors:
		return m.AddedUniqueVisitors()
	case visitorstat.FieldTotalViews:
		return m.AddedTotalViews()
	case visitorstat.FieldPageViews:
		return m.AddedPageViews()
	case visitorstat.FieldBounceCount:
		return m.AddedBounceCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visitorstat.FieldUniqueVisitors:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUniqueVisitors(v)
		return nil
	case visitorstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalViews(v)
		return nil
	case visitorstat.FieldPageViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageViews(v)
		return nil
	case visitorstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBounceCount(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitorStatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitorStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitorStatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VisitorStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitorStatMutation) ResetField(name string) error {
	switch name {
	case visitorstat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitorstat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case visitorstat.FieldDate:
		m.ResetDate()
		return nil
	case visitorstat.FieldUniqueVisitors:
		m.ResetUniqueVisitors()
		return nil
	case visitorstat.FieldTotalViews:
		m.ResetTotalViews()
		return nil
	case visitorstat.FieldPageViews:
		m.ResetPageViews()
		return nil
	case visitorstat.FieldBounceCount:
		m.ResetBounceCount()
		return nil
	}
	return fmt.Errorf("unknown VisitorStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitorStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitorStatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitorStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitorStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitorStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitorStatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitorStatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VisitorStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitorStatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VisitorStat edge %s", name)
}
